###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                21/Apr/2017  13:46:18
# Copyright 2004-2015 IAR Systems AB.
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x04000000 -DZDAPP_CONFIG_PAN_ID=0x0100
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=5
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -DCHANNEL_CNT=0x01 "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Components\stack\zdo\ZDSecMgr.c" -D ZTOOL_P1 -D MT_TASK -D
#        MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -D xNV_RESTORE -D
#        NV_INIT -D OPEN_FCS -D PANID_INCREASE -D MAKE_CRC_SHDW -lC "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB-SBL\List"
#        -lA "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB-SBL\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB-SBL\Obj" -e
#        --no_code_motion --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\Source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Application\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes
#    List file          =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB-SBL\List\ZDSecMgr.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB-SBL\Obj\ZDSecMgr.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh 1.0.0\Components\stack\zdo\ZDSecMgr.c
      1          /******************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2014-06-05 11:25:00 -0700 (Thu, 05 Jun 2014) $
      4            Revision:       $Revision: 38833 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "ZDConfig.h"
     60          #include "ZDSecMgr.h"
     61          #if NODE_AUTH
     62          #include "NodeAuth.h"
     63          #endif
     64          
     65          
     66          /******************************************************************************
     67           * CONSTANTS
     68           */
     69          // maximum number of devices managed by this Security Manager
     70          #if !defined ( ZDSECMGR_DEVICE_MAX )
     71            #define ZDSECMGR_DEVICE_MAX 3
     72          #endif
     73          
     74          // maximum number of LINK keys this device may store
     75          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     76          
     77          // total number of stored devices
     78          #if !defined ( ZDSECMGR_STORED_DEVICES )
     79            #define ZDSECMGR_STORED_DEVICES 3
     80          #endif
     81          
     82          // Total number of preconfigured trust center link key
     83          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     84            #define ZDSECMGR_TC_DEVICE_MAX 1
     85          #endif
     86          
     87          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     88            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     89          #endif
     90          
     91          // APSME Stub Implementations
     92          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
     93          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
     94          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
     95          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
     96          
     97          /******************************************************************************
     98           * TYPEDEFS
     99           */
    100          typedef struct
    101          {
    102            uint16            ami;
    103            uint16            keyNvId;   // index to the Link Key table in NV
    104            ZDSecMgr_Authentication_Option authenticateOption;
    105          } ZDSecMgrEntry_t;
    106          
    107          typedef struct
    108          {
    109            uint16          nwkAddr;
    110            uint8*          extAddr;
    111            uint16          parentAddr;
    112            uint8           secure;
    113            uint8           devStatus;
    114          } ZDSecMgrDevice_t;
    115          
    116          /******************************************************************************
    117           * EXTERNAL VARIABLES
    118           */
    119          extern pfnZdoCb zdoCBFunc[MAX_ZDO_CB_FUNC];
    120          
    121          /******************************************************************************
    122           * LOCAL VARIABLES
    123           */
    124          #if 0 // Taken out because the following functionality is only used for test
    125                // purpose. A more efficient (above) way is used. It can be put
    126                // back in if customers request for a white/black list feature.
    127          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    128          {
    129            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    130            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    131            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    132          };
    133          #endif
    134          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    136            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    137          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    138          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    139          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    141          
    142          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    143          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    144          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    145          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    146          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    147          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    148          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    149          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    150          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    151          
    152          /******************************************************************************
    153           * PRIVATE FUNCTIONS
    154           *
    155           *   ZDSecMgrAddrStore
    156           *   ZDSecMgrExtAddrStore
    157           *   ZDSecMgrExtAddrLookup
    158           *   ZDSecMgrEntryInit
    159           *   ZDSecMgrEntryLookup
    160           *   ZDSecMgrEntryLookupAMI
    161           *   ZDSecMgrEntryLookupExt
    162           *   ZDSecMgrEntryLookupExtGetIndex
    163           *   ZDSecMgrEntryFree
    164           *   ZDSecMgrEntryNew
    165           *   ZDSecMgrAppKeyGet
    166           *   ZDSecMgrAppKeyReq
    167           *   ZDSecMgrSendNwkKey
    168           *   ZDSecMgrDeviceRemove
    169           *   ZDSecMgrDeviceValidateRM
    170           *   ZDSecMgrDeviceValidate
    171           *   ZDSecMgrDeviceJoin
    172           *   ZDSecMgrDeviceJoinDirect
    173           *   ZDSecMgrDeviceJoinFwd
    174           *   ZDSecMgrDeviceNew
    175           *   ZDSecMgrAssocDeviceAuth
    176           *   ZDSecMgrAuthNwkKey
    177           *   APSME_TCLinkKeyInit
    178           *   APSME_IsDefaultTCLK
    179           */
    180          
    181          //-----------------------------------------------------------------------------
    182          // address management
    183          //-----------------------------------------------------------------------------
    184          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    185          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    186          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    187          
    188          //-----------------------------------------------------------------------------
    189          // Trust Center management
    190          //-----------------------------------------------------------------------------
    191          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );
    192          void ZDSecMgrTCDataLoad( uint8* extAddr );
    193          
    194          //-----------------------------------------------------------------------------
    195          // entry data
    196          //-----------------------------------------------------------------------------
    197          void ZDSecMgrEntryInit(uint8 state);
    198          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    199          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    200          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    201          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    202          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex );
    203          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    204          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    205          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    206          void ZDSecMgrApsLinkKeyInit(void);
    207          #if defined ( NV_RESTORE )
    208          static void ZDSecMgrWriteNV(void);
    209          static void ZDSecMgrRestoreFromNV(void);
    210          static void ZDSecMgrUpdateNV( uint16 index );
    211          #endif
    212          
    213          //-----------------------------------------------------------------------------
    214          // key support
    215          //-----------------------------------------------------------------------------
    216          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    217                                       uint8*  initExtAddr,
    218                                       uint16  partNwkAddr,
    219                                       uint8*  partExtAddr,
    220                                       uint8** key,
    221                                       uint8*  keyType );
    222          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    223          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    224          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    225          
    226          //-----------------------------------------------------------------------------
    227          // device management
    228          //-----------------------------------------------------------------------------
    229          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    230          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    231          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    232          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    233          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    234          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    235          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    236          
    237          //-----------------------------------------------------------------------------
    238          // association management
    239          //-----------------------------------------------------------------------------
    240          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    241          
    242          //-----------------------------------------------------------------------------
    243          // authentication management
    244          //-----------------------------------------------------------------------------
    245          void ZDSecMgrAuthNwkKey( void );
    246          
    247          //-----------------------------------------------------------------------------
    248          // APSME function
    249          //-----------------------------------------------------------------------------
    250          void APSME_TCLinkKeyInit( uint8 setDefault );
    251          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    252          
    253          /******************************************************************************
    254           * @fn          ZDSecMgrAddrStore
    255           *
    256           * @brief       Store device addresses.
    257           *
    258           * @param       nwkAddr - [in] NWK address
    259           * @param       extAddr - [in] EXT address
    260           * @param       ami     - [out] Address Manager index
    261           *
    262           * @return      ZStatus_t
    263           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    264          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    265          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    266            ZStatus_t      status;
    267            AddrMgrEntry_t entry;
    268          
    269          
    270            // add entry
    271            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    272            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine17 & 0xFFFF
    273            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_6:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   AA82         MOV     R2,DPL
   \   00001F   AB83         MOV     R3,DPH
   \   000021   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV     A,#0x16
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine24 & 0xFFFF
    274          
    275            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_20:
   \   00002C   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00002F   E9           MOV     A,R1
   \   000030   6401         XRL     A,#0x1
   \   000032   700A         JNZ     ??ZDSecMgrAddrStore_0
    276            {
    277              // return successful results
    278              *ami   = entry.index;
   \   000034   740B         MOV     A,#0xb
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine12 & 0xFFFF
    279              status = ZSuccess;
    280            }
   \                     ??CrossCallReturnLabel_52:
   \   00003C   8008         SJMP    ??CrossCallReturnLabel_9
    281            else
    282            {
    283              // return failed results
    284              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine18 & 0xFFFF
    285              status = ZNwkUnknownDevice;
    286            }
    287          
    288            return status;
   \                     ??CrossCallReturnLabel_9:
   \   000046   02....       LJMP    ?Subroutine0 & 0xFFFF
    289          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   000003   FE           MOV     R6,A
   \   000004   E9           MOV     A,R1
   \   000005   FF           MOV     R7,A
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000006   AA..         MOV     R2,?XSP + 0
   \   000008   AB..         MOV     R3,?XSP + 1
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_125:
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007   E8           MOV     A,R0
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   E9           MOV     A,R1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   79C8         MOV     R1,#-0x38
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   12....       LCALL   ?Subroutine39 & 0xFFFF
   \                     ??CrossCallReturnLabel_51:
   \   000003                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000003                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000003                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000003   7403         MOV     A,#0x3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004                REQUIRE ??Subroutine43_0
   \   000004                ; // Fall through to label ??Subroutine43_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine43_0:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine44_0
   \   000005                ; // Fall through to label ??Subroutine44_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine44_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   7900         MOV     R1,#0x0
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   E8           MOV     A,R0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine48_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   740D         MOV     A,#0xd
   \   000002                REQUIRE ??Subroutine57_0
   \   000002                ; // Fall through to label ??Subroutine57_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine57_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine58_0
   \   000003                ; // Fall through to label ??Subroutine58_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine58_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    290          
    291          /******************************************************************************
    292           * @fn          ZDSecMgrExtAddrStore
    293           *
    294           * @brief       Store EXT address.
    295           *
    296           * @param       extAddr - [in] EXT address
    297           * @param       ami     - [out] Address Manager index
    298           *
    299           * @return      ZStatus_t
    300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    301          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    302          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    303            ZStatus_t      status;
    304            AddrMgrEntry_t entry;
    305          
    306          
    307            // add entry
    308            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7402         MOV     A,#0x2
   \   000012   F0           MOVX    @DPTR,A
    309            entry.nwkAddr = nwkAddr;
   \   000013   14           DEC     A
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   12....       LCALL   ?Subroutine17 & 0xFFFF
    310            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_7:
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   AA82         MOV     R2,DPL
   \   00001F   AB83         MOV     R3,DPH
   \   000021   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   \   000024   7416         MOV     A,#0x16
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine24 & 0xFFFF
    311          
    312            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_21:
   \   00002C   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00002F   E9           MOV     A,R1
   \   000030   6401         XRL     A,#0x1
   \   000032   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    313            {
    314              // return successful results
    315              *ami   = entry.index;
   \   000034   740B         MOV     A,#0xb
   \   000036   12....       LCALL   ?XSTACK_DISP0_8
   \   000039   12....       LCALL   ?Subroutine12 & 0xFFFF
    316              status = ZSuccess;
    317            }
   \                     ??CrossCallReturnLabel_53:
   \   00003C   8008         SJMP    ??CrossCallReturnLabel_10
    318            else
    319            {
    320              // return failed results
    321              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   12....       LCALL   ?Subroutine18 & 0xFFFF
    322              status = ZNwkUnknownDevice;
    323            }
    324          
    325            return status;
   \                     ??CrossCallReturnLabel_10:
   \   000046   02....       LJMP    ?Subroutine0 & 0xFFFF
    326          }
    327          
    328          /******************************************************************************
    329           * @fn          ZDSecMgrExtAddrLookup
    330           *
    331           * @brief       Lookup index for specified EXT address.
    332           *
    333           * @param       extAddr - [in] EXT address
    334           * @param       ami     - [out] Address Manager index
    335           *
    336           * @return      ZStatus_t
    337           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    338          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    339          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    340            ZStatus_t      status;
    341            AddrMgrEntry_t entry;
    342          
    343          
    344            // lookup entry
    345            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7402         MOV     A,#0x2
   \   000016   F0           MOVX    @DPTR,A
    346            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   AA82         MOV     R2,DPL
   \   000022   AB83         MOV     R3,DPH
   \   000024   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    347          
    348            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   000027                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000027   AA..         MOV     R2,?XSP + 0
   \   000029   AB..         MOV     R3,?XSP + 1
   \   00002B   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   00002E   E9           MOV     A,R1
   \   00002F   6401         XRL     A,#0x1
   \   000031   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    349            {
    350              // return successful results
    351              *ami   = entry.index;
   \   000033   740B         MOV     A,#0xb
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   12....       LCALL   ?Subroutine12 & 0xFFFF
    352              status = ZSuccess;
    353            }
   \                     ??CrossCallReturnLabel_54:
   \   00003B   8008         SJMP    ??CrossCallReturnLabel_11
    354            else
    355            {
    356              // return failed results
    357              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   00003D   740B         MOV     A,#0xb
   \   00003F   12....       LCALL   ?XSTACK_DISP0_8
   \   000042   12....       LCALL   ?Subroutine18 & 0xFFFF
    358              status = ZNwkUnknownDevice;
    359            }
    360          
    361            return status;
   \                     ??CrossCallReturnLabel_11:
   \   000045   02....       LJMP    ?Subroutine0 & 0xFFFF
    362          }
    363          
    364          /******************************************************************************
    365           * @fn          ZDSecMgrAddrClear
    366           *
    367           * @brief       Clear security bit from Address Manager for specific device.
    368           *
    369           * @param       extAddr - [in] EXT address
    370           *
    371           * @return      ZStatus_t
    372           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    373          ZStatus_t ZDSecMgrAddrClear( uint8* extAddr )
   \                     ZDSecMgrAddrClear:
    374          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    375            ZStatus_t status;
    376            uint16 entryAmi;
    377          
    378            // get Address Manager Index
    379            status = ZDSecMgrExtAddrLookup( extAddr, &entryAmi );
   \   00000A                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000A   AC..         MOV     R4,?XSP + 0
   \   00000C   AD..         MOV     R5,?XSP + 1
   \   00000E   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000011   E9           MOV     A,R1
   \   000012   FE           MOV     R6,A
    380          
    381            if ( status == ZSuccess )
   \   000013   7026         JNZ     ??ZDSecMgrAddrClear_0
    382            {
    383              AddrMgrEntry_t addrEntry;
    384          
    385              // Clear SECURITY User bit from the address manager
    386              addrEntry.user = ADDRMGR_USER_SECURITY;
   \   000015   7402         MOV     A,#0x2
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   7402         MOV     A,#0x2
   \   00001C   F0           MOVX    @DPTR,A
    387              addrEntry.index = entryAmi;
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_119:
   \   000026   740D         MOV     A,#0xd
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   12....       LCALL   ?Subroutine19 & 0xFFFF
    388          
    389              if ( AddrMgrEntryRelease( &addrEntry ) != TRUE )
   \                     ??CrossCallReturnLabel_12:
   \   00002E   12....       LCALL   ?XSTACK_DISP101_8
   \   000031   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   6002         JZ      ??ZDSecMgrAddrClear_0
    390              {
    391                // return failure results
    392                status = ZFailure;
   \   000039   7E01         MOV     R6,#0x1
    393              }
    394            }
    395          
    396            return status;
   \                     ??ZDSecMgrAddrClear_0:
   \   00003B   EE           MOV     A,R6
   \   00003C   F9           MOV     R1,A
   \   00003D   740F         MOV     A,#0xf
   \   00003F   02....       LJMP    ??Subroutine57_0 & 0xFFFF
    397          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005                ; Setup parameters for call to function AddrMgrEntryRelease
   \   000005                ; Setup parameters for indirect call
   \   000005   7402         MOV     A,#0x2
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine61_0:
   \   000000   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_130:
   \   000003   22           RET
    398          
    399          /******************************************************************************
    400           * @fn          ZDSecMgrEntryInit
    401           *
    402           * @brief       Initialize entry sub module
    403           *
    404           * @param       state - device initialization state
    405           *
    406           * @return      none
    407           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    409          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    410            if (ZDSecMgrEntries == NULL)
   \   000004   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000007   7036         JNZ     ??ZDSecMgrEntryInit_0
    411            {
    412              uint16 index;
    413          
    414              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A0F         MOV     R2,#0xf
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000013   EA           MOV     A,R2
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EB           MOV     A,R3
   \   000017   12....       LCALL   ??Subroutine46_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00001A   6023         JZ      ??ZDSecMgrEntryInit_0
    415              {
    416                return;
    417              }
    418          
    419              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   00001C   7800         MOV     R0,#0x0
   \   00001E   7900         MOV     R1,#0x0
    420              {
    421                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_1:
   \   000020   12....       LCALL   ?Subroutine32 & 0xFFFF
    422          
    423                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
    424              }
   \                     ??CrossCallReturnLabel_27:
   \   000023   8A82         MOV     DPL,R2
   \   000025   8B83         MOV     DPH,R3
   \   000027   74FE         MOV     A,#-0x2
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   A3           INC     DPTR
   \   00002B   04           INC     A
   \   00002C   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_40:
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   E4           CLR     A
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   F0           MOVX    @DPTR,A
   \   000035   08           INC     R0
   \   000036   E8           MOV     A,R0
   \   000037   7001         JNZ     ??ZDSecMgrEntryInit_2
   \   000039   09           INC     R1
   \                     ??ZDSecMgrEntryInit_2:
   \   00003A   12....       LCALL   ?Subroutine31 & 0xFFFF
    425            }
   \                     ??CrossCallReturnLabel_60:
   \   00003D   40E1         JC      ??ZDSecMgrEntryInit_1
    426          
    427          #if defined NV_RESTORE
    428            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
    429            {
    430              ZDSecMgrRestoreFromNV();
    431            }
    432          #else
    433            (void)state;
    434          #endif
    435          }
   \                     ??ZDSecMgrEntryInit_0:
   \   00003F   02....       LJMP    ??Subroutine52_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   C3           CLR     C
   \   000001                REQUIRE ??Subroutine45_0
   \   000001                ; // Fall through to label ??Subroutine45_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine45_0:
   \   000000   9403         SUBB    A,#0x3
   \   000002   E9           MOV     A,R1
   \   000003   9400         SUBB    A,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine46_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000004   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   000007   49           ORL     A,R1
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E8           MOV     A,R0
   \   000001   FA           MOV     R2,A
   \   000002   E9           MOV     A,R1
   \   000003   FB           MOV     R3,A
   \   000004   EA           MOV     A,R2
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   FA           MOV     R2,A
   \   00000A   ACF0         MOV     R4,B
   \   00000C   75F005       MOV     B,#0x5
   \   00000F   EB           MOV     A,R3
   \   000010   A4           MUL     AB
   \   000011   2C           ADD     A,R4
   \   000012   FB           MOV     R3,A
   \   000013   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000016   E0           MOVX    A,@DPTR
   \   000017   2A           ADD     A,R2
   \   000018   FA           MOV     R2,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   3B           ADDC    A,R3
   \   00001C   FB           MOV     R3,A
   \   00001D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithShort
   \   000001   8A82         MOV     DPL,R2
   \   000003   8B83         MOV     DPH,R3
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine52_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000003                REQUIRE ??Subroutine65_0
   \   000003                ; // Fall through to label ??Subroutine65_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine65_0:
   \   000000   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000003   49           ORL     A,R1
   \   000004   22           RET
    436          
    437          /******************************************************************************
    438           * @fn          ZDSecMgrEntryLookup
    439           *
    440           * @brief       Lookup entry index using specified NWK address.
    441           *
    442           * @param       nwkAddr - [in] NWK address
    443           * @param       entry   - [out] valid entry
    444           *
    445           * @return      ZStatus_t
    446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    447          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    448          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    449            uint16         index;
    450            AddrMgrEntry_t addrMgrEntry;
    451          
    452            // initialize results
    453            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine10 & 0xFFFF
    454          
    455            // verify data is available
    456            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_66:
   \   000015   607A         JZ      ??ZDSecMgrEntryLookup_0
    457            {
    458              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   7402         MOV     A,#0x2
   \   00001F   F0           MOVX    @DPTR,A
    459              addrMgrEntry.nwkAddr = nwkAddr;
   \   000020   14           DEC     A
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine14 & 0xFFFF
    460          
    461              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_105:
   \   000027   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00002A   E9           MOV     A,R1
   \   00002B   6401         XRL     A,#0x1
   \   00002D   7062         JNZ     ??ZDSecMgrEntryLookup_0
    462              {
    463                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002F   7800         MOV     R0,#0x0
   \   000031   7900         MOV     R1,#0x0
    464                {
    465                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_1:
   \   000033   740B         MOV     A,#0xb
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FC           MOV     R4,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FD           MOV     R5,A
   \   00003D   E8           MOV     A,R0
   \   00003E   FA           MOV     R2,A
   \   00003F   E9           MOV     A,R1
   \   000040   FB           MOV     R3,A
   \   000041   EA           MOV     A,R2
   \   000042   75F005       MOV     B,#0x5
   \   000045   A4           MUL     AB
   \   000046   FA           MOV     R2,A
   \   000047   85F0..       MOV     ?V0,B
   \   00004A   75F005       MOV     B,#0x5
   \   00004D   EB           MOV     A,R3
   \   00004E   A4           MUL     AB
   \   00004F   25..         ADD     A,?V0
   \   000051   FB           MOV     R3,A
   \   000052   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000055   E0           MOVX    A,@DPTR
   \   000056   2A           ADD     A,R2
   \   000057   F5..         MOV     ?V0,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   3B           ADDC    A,R3
   \   00005C   85..82       MOV     DPL,?V0
   \   00005F   F583         MOV     DPH,A
   \   000061   E0           MOVX    A,@DPTR
   \   000062   6C           XRL     A,R4
   \   000063   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_2:
   \   000068   701D         JNZ     ??ZDSecMgrEntryLookup_3
    466                  {
    467                    // return successful results
    468                    *entry = &ZDSecMgrEntries[index];
   \   00006A   E8           MOV     A,R0
   \   00006B   75F005       MOV     B,#0x5
   \   00006E   A4           MUL     AB
   \   00006F   F8           MOV     R0,A
   \   000070   AAF0         MOV     R2,B
   \   000072   75F005       MOV     B,#0x5
   \   000075   E9           MOV     A,R1
   \   000076   A4           MUL     AB
   \   000077   2A           ADD     A,R2
   \   000078   F9           MOV     R1,A
   \   000079   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   28           ADD     A,R0
   \   00007E   F8           MOV     R0,A
   \   00007F   A3           INC     DPTR
   \   000080   E0           MOVX    A,@DPTR
   \   000081   39           ADDC    A,R1
   \   000082   12....       LCALL   ??Subroutine43_0 & 0xFFFF
    469          
    470                    // break from loop
    471                    return ZSuccess;
    472                  }
    473                }
   \                     ??CrossCallReturnLabel_55:
   \   000085   800C         SJMP    ??ZDSecMgrEntryLookup_4
   \                     ??ZDSecMgrEntryLookup_3:
   \   000087   08           INC     R0
   \   000088   E8           MOV     A,R0
   \   000089   7001         JNZ     ??ZDSecMgrEntryLookup_5
   \   00008B   09           INC     R1
   \                     ??ZDSecMgrEntryLookup_5:
   \   00008C   12....       LCALL   ?Subroutine31 & 0xFFFF
    474              }
    475            }
   \                     ??CrossCallReturnLabel_61:
   \   00008F   40A2         JC      ??ZDSecMgrEntryLookup_1
    476          
    477            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookup_0:
   \   000091   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   000093   02....       LJMP    ?Subroutine0 & 0xFFFF
    478          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003                REQUIRE ??Subroutine46_0
   \   000003                ; // Fall through to label ??Subroutine46_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine56_0
   \   000004                ; // Fall through to label ??Subroutine56_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine56_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001   AA..         MOV     R2,?XSP + 0
   \   000003   AB..         MOV     R3,?XSP + 1
   \   000005   22           RET
    479          
    480          /******************************************************************************
    481           * @fn          ZDSecMgrEntryLookupAMI
    482           *
    483           * @brief       Lookup entry using specified address index
    484           *
    485           * @param       ami   - [in] Address Manager index
    486           * @param       entry - [out] valid entry
    487           *
    488           * @return      ZStatus_t
    489           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    490          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    491          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    492            uint16 index;
    493          
    494            // initialize results
    495            *entry = NULL;
   \   000005   8C82         MOV     DPL,R4
   \   000007   8D83         MOV     DPH,R5
   \   000009   12....       LCALL   ?Subroutine10 & 0xFFFF
    496          
    497            // verify data is available
    498            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_67:
   \   00000C   6039         JZ      ??ZDSecMgrEntryLookupAMI_0
    499            {
    500              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7800         MOV     R0,#0x0
   \   000010   7900         MOV     R1,#0x0
    501              {
    502                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000012   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000015   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \   000019   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   00001A   7021         JNZ     ??ZDSecMgrEntryLookupAMI_3
    503                {
    504                  // return successful results
    505                  *entry = &ZDSecMgrEntries[index];
   \   00001C   E8           MOV     A,R0
   \   00001D   75F005       MOV     B,#0x5
   \   000020   A4           MUL     AB
   \   000021   AAF0         MOV     R2,B
   \   000023   75F005       MOV     B,#0x5
   \   000026   E9           MOV     A,R1
   \   000027   A4           MUL     AB
   \   000028   2A           ADD     A,R2
   \   000029   F9           MOV     R1,A
   \   00002A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   2E           ADD     A,R6
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   39           ADDC    A,R1
   \   000033   F9           MOV     R1,A
   \   000034   8C82         MOV     DPL,R4
   \   000036   8D83         MOV     DPH,R5
   \   000038   12....       LCALL   ??Subroutine44_0 & 0xFFFF
    506          
    507                  // break from loop
    508                  return ZSuccess;
    509                }
    510              }
   \                     ??CrossCallReturnLabel_56:
   \   00003B   800C         SJMP    ??ZDSecMgrEntryLookupAMI_4
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   00003D   08           INC     R0
   \   00003E   E8           MOV     A,R0
   \   00003F   7001         JNZ     ??ZDSecMgrEntryLookupAMI_5
   \   000041   09           INC     R1
   \                     ??ZDSecMgrEntryLookupAMI_5:
   \   000042   12....       LCALL   ?Subroutine31 & 0xFFFF
    511            }
   \                     ??CrossCallReturnLabel_62:
   \   000045   40CB         JC      ??ZDSecMgrEntryLookupAMI_1
    512          
    513            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000047   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   000049   02....       LJMP    ??Subroutine58_0 & 0xFFFF
    514          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   E8           MOV     A,R0
   \   000001   FE           MOV     R6,A
   \   000002   E9           MOV     A,R1
   \   000003   FF           MOV     R7,A
   \   000004   EE           MOV     A,R6
   \   000005   75F005       MOV     B,#0x5
   \   000008   A4           MUL     AB
   \   000009   FE           MOV     R6,A
   \   00000A   85F0..       MOV     ?V0,B
   \   00000D   75F005       MOV     B,#0x5
   \   000010   EF           MOV     A,R7
   \   000011   A4           MUL     AB
   \   000012   25..         ADD     A,?V0
   \   000014   FF           MOV     R7,A
   \   000015   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000018   E0           MOVX    A,@DPTR
   \   000019   2E           ADD     A,R6
   \   00001A   F5..         MOV     ?V0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   3F           ADDC    A,R7
   \   00001F   85..82       MOV     DPL,?V0
   \   000022   F583         MOV     DPH,A
   \   000024   E0           MOVX    A,@DPTR
   \   000025   6A           XRL     A,R2
   \   000026   22           RET
    515          
    516          /******************************************************************************
    517           * @fn          ZDSecMgrEntryLookupExt
    518           *
    519           * @brief       Lookup entry index using specified EXT address.
    520           *
    521           * @param       extAddr - [in] EXT address
    522           * @param       entry   - [out] valid entry
    523           *
    524           * @return      ZStatus_t
    525           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    526          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    527          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    528            ZStatus_t status;
    529            uint16    ami;
    530          
    531            // initialize results
    532            *entry = NULL;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E4           CLR     A
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   F0           MOVX    @DPTR,A
    533            status = ZNwkUnknownDevice;
   \   000016   75..C8       MOV     ?V0,#-0x38
    534          
    535            // lookup address index
    536            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000019                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000019   AC..         MOV     R4,?XSP + 0
   \   00001B   AD..         MOV     R5,?XSP + 1
   \   00001D   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000020   E9           MOV     A,R1
   \   000021   7013         JNZ     ??ZDSecMgrEntryLookupExt_0
    537            {
    538              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   000023                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000023   EE           MOV     A,R6
   \   000024   FC           MOV     R4,A
   \   000025   EF           MOV     A,R7
   \   000026   FD           MOV     R5,A
   \   000027   85..82       MOV     DPL,?XSP + 0
   \   00002A   85..83       MOV     DPH,?XSP + 1
   \   00002D   12....       LCALL   ??Subroutine50_0 & 0xFFFF
    539            }
   \                     ??CrossCallReturnLabel_74:
   \   000030   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000033   E9           MOV     A,R1
   \   000034   F5..         MOV     ?V0,A
    540          
    541            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000036   A9..         MOV     R1,?V0
   \   000038   02....       LJMP    ?Subroutine6 & 0xFFFF
    542          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   7402         MOV     A,#0x2
   \   000002   02....       LJMP    ??Subroutine57_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine50_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET
    543          
    544          /******************************************************************************
    545           * @fn          ZDSecMgrEntryLookupExtGetIndex
    546           *
    547           * @brief       Lookup entry index using specified EXT address.
    548           *
    549           * @param       extAddr - [in] EXT address
    550           * @param       entryIndex - [out] valid index to the entry table
    551           *
    552           * @return      ZStatus_t
    553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    555          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    556            uint16 ami;
    557            uint16 index;
    558          
    559            // lookup address index
    560            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000015   E9           MOV     A,R1
   \   000016   7056         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_0
    561            {
    562              // verify data is available
    563              if ( ZDSecMgrEntries != NULL )
   \   000018   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   00001B   6051         JZ      ??ZDSecMgrEntryLookupExtGetIndex_0
    564              {
    565                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00001D   7800         MOV     R0,#0x0
   \   00001F   7900         MOV     R1,#0x0
    566                {
    567                  if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000021   E8           MOV     A,R0
   \   000022   FA           MOV     R2,A
   \   000023   E9           MOV     A,R1
   \   000024   FB           MOV     R3,A
   \   000025   EA           MOV     A,R2
   \   000026   75F005       MOV     B,#0x5
   \   000029   A4           MUL     AB
   \   00002A   FA           MOV     R2,A
   \   00002B   ACF0         MOV     R4,B
   \   00002D   75F005       MOV     B,#0x5
   \   000030   EB           MOV     A,R3
   \   000031   A4           MUL     AB
   \   000032   2C           ADD     A,R4
   \   000033   FB           MOV     R3,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000037   E0           MOVX    A,@DPTR
   \   000038   2A           ADD     A,R2
   \   000039   FC           MOV     R4,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   3B           ADDC    A,R3
   \   00003D   8C82         MOV     DPL,R4
   \   00003F   F583         MOV     DPH,A
   \   000041   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_25:
   \   000044   E0           MOVX    A,@DPTR
   \   000045   6A           XRL     A,R2
   \   000046   7003         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_2
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   00004B   7017         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_3
    568                  {
    569                    // return successful results
    570                    *entry = &ZDSecMgrEntries[index];
   \   00004D   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_28:
   \   000050   8E82         MOV     DPL,R6
   \   000052   8F83         MOV     DPH,R7
   \   000054   12....       LCALL   ?Subroutine39 & 0xFFFF
    571                    *entryIndex = index;
   \                     ??CrossCallReturnLabel_46:
   \   000057   740B         MOV     A,#0xb
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   12....       LCALL   ??Subroutine62_0 & 0xFFFF
    572          
    573                    // break from loop
    574                    return ZSuccess;
    575                  }
    576                }
   \                     ??CrossCallReturnLabel_131:
   \   00005F   12....       LCALL   ??Subroutine44_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   000062   800C         SJMP    ??ZDSecMgrEntryLookupExtGetIndex_4
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   000064   08           INC     R0
   \   000065   E8           MOV     A,R0
   \   000066   7001         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_5
   \   000068   09           INC     R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   000069   12....       LCALL   ?Subroutine31 & 0xFFFF
    577              }
    578            }
   \                     ??CrossCallReturnLabel_63:
   \   00006C   40B3         JC      ??ZDSecMgrEntryLookupExtGetIndex_1
    579          
    580            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   00006E   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   000070   02....       LJMP    ?Subroutine6 & 0xFFFF
    581          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   85..82       MOV     DPL,?XSP + 0
   \   000008   85..83       MOV     DPH,?XSP + 1
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine62_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8A82         MOV     DPL,R2
   \   000008   22           RET
    582          
    583          /******************************************************************************
    584           * @fn          ZDSecMgrEntryLookupAMIGetIndex
    585           *
    586           * @brief       Lookup entry using specified address index
    587           *
    588           * @param       ami   - [in] Address Manager index
    589           * @param       entryIndex - [out] valid index to the entry table
    590           *
    591           * @return      ZStatus_t
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupAMIGetIndex:
    594          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    595            uint16 index;
    596          
    597            // verify data is available
    598            if ( ZDSecMgrEntries != NULL )
   \   000005   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   000008   6021         JZ      ??ZDSecMgrEntryLookupAMIGetIndex_0
    599            {
    600              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000A   7800         MOV     R0,#0x0
   \   00000C   7900         MOV     R1,#0x0
    601              {
    602                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_1:
   \   00000E   12....       LCALL   ?Subroutine23 & 0xFFFF
   \                     ??CrossCallReturnLabel_19:
   \   000011   7003         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_2
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_2:
   \   000016   7009         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_3
    603                {
    604                  // return successful results
    605                  *entryIndex = index;
   \   000018   8C82         MOV     DPL,R4
   \   00001A   8D83         MOV     DPH,R5
   \   00001C   12....       LCALL   ??Subroutine44_0 & 0xFFFF
    606          
    607                  // break from loop
    608                  return ZSuccess;
    609                }
    610              }
   \                     ??CrossCallReturnLabel_58:
   \   00001F   800C         SJMP    ??ZDSecMgrEntryLookupAMIGetIndex_4
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_3:
   \   000021   08           INC     R0
   \   000022   E8           MOV     A,R0
   \   000023   7001         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_5
   \   000025   09           INC     R1
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_5:
   \   000026   12....       LCALL   ?Subroutine31 & 0xFFFF
    611            }
   \                     ??CrossCallReturnLabel_64:
   \   000029   40E3         JC      ??ZDSecMgrEntryLookupAMIGetIndex_1
    612          
    613            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_0:
   \   00002B   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_4:
   \   00002D   02....       LJMP    ??Subroutine58_0 & 0xFFFF
    614          }
    615          
    616          /******************************************************************************
    617           * @fn          ZDSecMgrEntryFree
    618           *
    619           * @brief       Free entry.
    620           *
    621           * @param       entry - [in] valid entry
    622           *
    623           * @return      ZStatus_t
    624           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    625          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    626          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    627            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
    628          
    629          #if defined ( NV_RESTORE )
    630            ZStatus_t status;
    631            uint16 entryIndex;
    632          
    633            status = ZDSecMgrEntryLookupAMIGetIndex( entry->ami, &entryIndex );
    634          #endif
    635          
    636            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000009                ; Setup parameters for call to function osal_mem_alloc
   \   000009   7A18         MOV     R2,#0x18
   \   00000B   7B00         MOV     R3,#0x0
   \   00000D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
    637          
    638            if (pApsLinkKey != NULL)
   \   000014   EA           MOV     A,R2
   \   000015   45..         ORL     A,?V3
   \   000017   6049         JZ      ??ZDSecMgrEntryFree_0
    639            {
    640              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000019                ; Setup parameters for call to function osal_memset
   \   000019   7C18         MOV     R4,#0x18
   \   00001B   7D00         MOV     R5,#0x0
   \   00001D   7900         MOV     R1,#0x0
   \   00001F   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    641          
    642              // Clear the APS Link key in NV
    643              osal_nv_write( entry->keyNvId, 0,
    644                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   000022   EE           MOV     A,R6
   \   000023   2402         ADD     A,#0x2
   \   000025   F8           MOV     R0,A
   \   000026   E4           CLR     A
   \   000027   3F           ADDC    A,R7
   \   000028   F9           MOV     R1,A
   \   000029   88..         MOV     ?V0,R0
   \   00002B   89..         MOV     ?V1,R1
   \   00002D                ; Setup parameters for call to function osal_nv_write
   \   00002D   78..         MOV     R0,#?V2
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75..18       MOV     ?V4,#0x18
   \   000035   75..00       MOV     ?V5,#0x0
   \   000038   78..         MOV     R0,#?V4
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   7C00         MOV     R4,#0x0
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   85..82       MOV     DPL,?V0
   \   000044   8983         MOV     DPH,R1
   \   000046   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000049   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00004C   7404         MOV     A,#0x4
   \   00004E   12....       LCALL   ?DEALLOC_XSTACK8
    645          
    646              // set entry to invalid Key
    647              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   000051   85..82       MOV     DPL,?V0
   \   000054   85..83       MOV     DPH,?V1
   \   000057   E4           CLR     A
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   F0           MOVX    @DPTR,A
    648          
    649              osal_mem_free(pApsLinkKey);
   \   00005B                ; Setup parameters for call to function osal_mem_free
   \   00005B   AA..         MOV     R2,?V2
   \   00005D   AB..         MOV     R3,?V3
   \   00005F   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    650            }
    651          
    652            // marking the entry as INVALID_NODE_ADDR
    653            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   000062   8E82         MOV     DPL,R6
   \   000064   8F83         MOV     DPH,R7
   \   000066   74FE         MOV     A,#-0x2
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   04           INC     A
   \   00006B   12....       LCALL   ?Subroutine38 & 0xFFFF
    654          
    655            // set to default value
    656            entry->authenticateOption = ZDSecMgr_Not_Authenticated;
   \                     ??CrossCallReturnLabel_44:
   \   00006E   E4           CLR     A
   \   00006F   F0           MOVX    @DPTR,A
    657          
    658          #if defined ( NV_RESTORE )
    659            if ( status == ZSuccess )
    660            {
    661              ZDSecMgrUpdateNV(entryIndex);
    662            }
    663          #endif
    664          }
   \   000070                REQUIRE ?Subroutine2
   \   000070                ; // Fall through to label ?Subroutine2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7F06         MOV     R7,#0x6
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   A3           INC     DPTR
   \   000006   A3           INC     DPTR
   \   000007   A3           INC     DPTR
   \   000008   A3           INC     DPTR
   \   000009   22           RET
    665          
    666          /******************************************************************************
    667           * @fn          ZDSecMgrEntryNew
    668           *
    669           * @brief       Get a new entry.
    670           *
    671           * @param       entry - [out] valid entry
    672           *
    673           * @return      ZStatus_t
    674           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    675          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    676          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    677            uint16 index;
    678          
    679            // initialize results
    680            *entry = NULL;
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ?Subroutine10 & 0xFFFF
    681          
    682            // verify data is available
    683            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_68:
   \   00000C   6070         JZ      ??ZDSecMgrEntryNew_0
    684            {
    685              // find available entry
    686              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00000E   7800         MOV     R0,#0x0
   \   000010   7900         MOV     R1,#0x0
    687              {
    688                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_1:
   \   000012   E8           MOV     A,R0
   \   000013   FC           MOV     R4,A
   \   000014   E9           MOV     A,R1
   \   000015   FD           MOV     R5,A
   \   000016   EC           MOV     A,R4
   \   000017   75F005       MOV     B,#0x5
   \   00001A   A4           MUL     AB
   \   00001B   FC           MOV     R4,A
   \   00001C   AEF0         MOV     R6,B
   \   00001E   75F005       MOV     B,#0x5
   \   000021   ED           MOV     A,R5
   \   000022   A4           MUL     AB
   \   000023   2E           ADD     A,R6
   \   000024   FD           MOV     R5,A
   \   000025   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000028   E0           MOVX    A,@DPTR
   \   000029   2C           ADD     A,R4
   \   00002A   FE           MOV     R6,A
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   3D           ADDC    A,R5
   \   00002E   8E82         MOV     DPL,R6
   \   000030   F583         MOV     DPH,A
   \   000032   E0           MOVX    A,@DPTR
   \   000033   64FE         XRL     A,#0xfe
   \   000035   7003         JNZ     ??ZDSecMgrEntryNew_2
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   F4           CPL     A
   \                     ??ZDSecMgrEntryNew_2:
   \   00003A   7038         JNZ     ??ZDSecMgrEntryNew_3
    689                {
    690                  // return successful result
    691                  *entry = &ZDSecMgrEntries[index];
   \   00003C   E8           MOV     A,R0
   \   00003D   75F005       MOV     B,#0x5
   \   000040   A4           MUL     AB
   \   000041   F8           MOV     R0,A
   \   000042   ACF0         MOV     R4,B
   \   000044   75F005       MOV     B,#0x5
   \   000047   E9           MOV     A,R1
   \   000048   A4           MUL     AB
   \   000049   2C           ADD     A,R4
   \   00004A   F9           MOV     R1,A
   \   00004B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   28           ADD     A,R0
   \   000050   FC           MOV     R4,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   39           ADDC    A,R1
   \   000054   FD           MOV     R5,A
   \   000055   8A82         MOV     DPL,R2
   \   000057   8B83         MOV     DPH,R3
   \   000059   EC           MOV     A,R4
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   ED           MOV     A,R5
   \   00005D   F0           MOVX    @DPTR,A
    692          
    693                  // Set the authentication option to default
    694                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00005E   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000061   E0           MOVX    A,@DPTR
   \   000062   28           ADD     A,R0
   \   000063   FA           MOV     R2,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   39           ADDC    A,R1
   \   000067   8A82         MOV     DPL,R2
   \   000069   F583         MOV     DPH,A
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   E4           CLR     A
   \   000070   F0           MOVX    @DPTR,A
    695          
    696                  // break from loop
    697                  return ZSuccess;
   \   000071   F9           MOV     R1,A
   \   000072   800C         SJMP    ??ZDSecMgrEntryNew_4
    698                }
    699              }
   \                     ??ZDSecMgrEntryNew_3:
   \   000074   08           INC     R0
   \   000075   E8           MOV     A,R0
   \   000076   7001         JNZ     ??ZDSecMgrEntryNew_5
   \   000078   09           INC     R1
   \                     ??ZDSecMgrEntryNew_5:
   \   000079   12....       LCALL   ?Subroutine31 & 0xFFFF
    700            }
   \                     ??CrossCallReturnLabel_65:
   \   00007C   4094         JC      ??ZDSecMgrEntryNew_1
    701          
    702            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryNew_0:
   \   00007E   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryNew_4:
   \   000080   02....       LJMP    ??Subroutine58_0 & 0xFFFF
    703          }
    704          
    705          /******************************************************************************
    706           * @fn          ZDSecMgrAppKeyGet
    707           *
    708           * @brief       get an APP key - option APP(MASTER or LINK) key
    709           *
    710           * @param       initNwkAddr - [in] NWK address of initiator device
    711           * @param       initExtAddr - [in] EXT address of initiator device
    712           * @param       partNwkAddr - [in] NWK address of partner device
    713           * @param       partExtAddr - [in] EXT address of partner device
    714           * @param       key         - [out] APP(MASTER or LINK) key
    715           * @param       keyType     - [out] APP(MASTER or LINK) key type
    716           *
    717           * @return      ZStatus_t
    718           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    719          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
    720                                                           // to KEY_TYPE_APP_LINK since
    721                                                           // only specific requirement
    722                                                           // right now comes from SE profile
    723          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    724          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
    725                                       uint8*  initExtAddr,
    726                                       uint16  partNwkAddr,
    727                                       uint8*  partExtAddr,
    728                                       uint8** key,
    729                                       uint8*  keyType )
    730          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    731            // Intentionally unreferenced parameters
    732            (void)initNwkAddr;
    733            (void)initExtAddr;
    734            (void)partNwkAddr;
    735            (void)partExtAddr;
    736          
    737            //---------------------------------------------------------------------------
    738            // note:
    739            // should use a robust mechanism to generate keys, for example
    740            // combine EXT addresses and call a hash function
    741            //---------------------------------------------------------------------------
    742            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000004                ; Setup parameters for call to function SSP_GetTrueRand
   \   000004   7404         MOV     A,#0x4
   \   000006   12....       LCALL   ?XSTACK_DISP0_8
   \   000009   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_112:
   \   00000C   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   00000F   7910         MOV     R1,#0x10
   \   000011   12....       LCALL   `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
    743          
    744            *keyType = ZDSecMgrAppKeyType;
   \   000014   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000017   E0           MOVX    A,@DPTR
   \   000018   C0E0         PUSH    A
   \   00001A   7406         MOV     A,#0x6
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_113:
   \   000022   D0E0         POP     A
   \   000024   F0           MOVX    @DPTR,A
    745          
    746            return ZSuccess;
   \   000025   7900         MOV     R1,#0x0
   \   000027   02....       LJMP    ??Subroutine52_0 & 0xFFFF
    747          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine59_0:
   \   000000   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_118:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    748          
    749          /******************************************************************************
    750           * @fn          ZDSecMgrAppKeyReq
    751           *
    752           * @brief       Process request for APP key between two devices.
    753           *
    754           * @param       device - [in] ZDO_RequestKeyInd_t, request info
    755           *
    756           * @return      none
    757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    758          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
    759          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    760            APSME_TransportKeyReq_t req;
    761            uint8                   initExtAddr[Z_EXTADDR_LEN];
    762            uint16                  partNwkAddr;
    763            uint8                   key[SEC_KEY_LEN];
    764          
    765          
    766            // validate initiator and partner
    767            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
    768                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   2405         ADD     A,#0x5
   \   000015   FA           MOV     R2,A
   \   000016   E4           CLR     A
   \   000017   3F           ADDC    A,R7
   \   000018   FB           MOV     R3,A
   \   000019   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00001C   E9           MOV     A,R1
   \   00001D   6401         XRL     A,#0x1
   \   00001F   6003         JZ      $+5
   \   000021   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000024                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000024   740F         MOV     A,#0xf
   \   000026   12....       LCALL   ?XSTACK_DISP102_8
   \   000029   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   00002C   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   00002F   E9           MOV     A,R1
   \   000030   6401         XRL     A,#0x1
   \   000032   6003         JZ      $+5
   \   000034   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
    769            {
    770              // point the key to some memory
    771              req.key = key;
   \   000037   7417         MOV     A,#0x17
   \   000039   12....       LCALL   ?XSTACK_DISP100_8
   \   00003C   7406         MOV     A,#0x6
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ??Subroutine51_0 & 0xFFFF
    772          
    773              // get an APP key - option APP (MASTER or LINK) key
    774              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
    775                                      initExtAddr,
    776                                      partNwkAddr,
    777                                      ind->partExtAddr,
    778                                      &req.key,
    779                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_88:
   \   000044                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   000044   7404         MOV     A,#0x4
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   8582..       MOV     ?V0,DPL
   \   00004C   8583..       MOV     ?V1,DPH
   \   00004F   78..         MOV     R0,#?V0
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   7408         MOV     A,#0x8
   \   000056   12....       LCALL   ?XSTACK_DISP0_8
   \   000059   8582..       MOV     ?V0,DPL
   \   00005C   8583..       MOV     ?V1,DPH
   \   00005F   78..         MOV     R0,#?V0
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   EE           MOV     A,R6
   \   000065   2405         ADD     A,#0x5
   \   000067   F5..         MOV     ?V0,A
   \   000069   E4           CLR     A
   \   00006A   3F           ADDC    A,R7
   \   00006B   F5..         MOV     ?V1,A
   \   00006D   78..         MOV     R0,#?V0
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   7406         MOV     A,#0x6
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   00007A   7417         MOV     A,#0x17
   \   00007C   12....       LCALL   ?XSTACK_DISP102_8
   \   00007F   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_86:
   \   000082   12....       LCALL   `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   000085   7408         MOV     A,#0x8
   \   000087   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008A   E9           MOV     A,R1
   \   00008B   707A         JNZ     ??ZDSecMgrAppKeyReq_0
    780              {
    781                // always secure
    782                req.nwkSecure = TRUE;
   \   00008D   740C         MOV     A,#0xc
   \   00008F   12....       LCALL   ?XSTACK_DISP0_8
   \   000092   7401         MOV     A,#0x1
   \   000094   F0           MOVX    @DPTR,A
    783                req.apsSecure = TRUE;
   \   000095   740B         MOV     A,#0xb
   \   000097   12....       LCALL   ?XSTACK_DISP0_8
   \   00009A   7401         MOV     A,#0x1
   \   00009C   F0           MOVX    @DPTR,A
    784                req.tunnel    = NULL;
   \   00009D   740D         MOV     A,#0xd
   \   00009F   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A2   E4           CLR     A
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   A3           INC     DPTR
   \   0000A5   12....       LCALL   ??Subroutine47_0 & 0xFFFF
    785          
    786                // send key to initiator device
    787                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_72:
   \   0000A8   7402         MOV     A,#0x2
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   12....       LCALL   ??Subroutine51_0 & 0xFFFF
    788                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_89:
   \   0000B0   EE           MOV     A,R6
   \   0000B1   2405         ADD     A,#0x5
   \   0000B3   F8           MOV     R0,A
   \   0000B4   E4           CLR     A
   \   0000B5   3F           ADDC    A,R7
   \   0000B6   F9           MOV     R1,A
   \   0000B7   7408         MOV     A,#0x8
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   12....       LCALL   ??Subroutine51_0 & 0xFFFF
    789                req.initiator = TRUE;
   \                     ??CrossCallReturnLabel_90:
   \   0000BF   740A         MOV     A,#0xa
   \   0000C1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C4   7401         MOV     A,#0x1
   \   0000C6   F0           MOVX    @DPTR,A
    790                APSME_TransportKeyReq( &req );
   \   0000C7                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000C7   04           INC     A
   \   0000C8   12....       LCALL   ?XSTACK_DISP101_8
   \   0000CB   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
    791          
    792                // send key to partner device
    793                req.dstAddr   = partNwkAddr;
   \   0000CE   85..82       MOV     DPL,?XSP + 0
   \   0000D1   85..83       MOV     DPH,?XSP + 1
   \   0000D4   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   12....       LCALL   ??Subroutine51_0 & 0xFFFF
    794                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_91:
   \   0000DD   740F         MOV     A,#0xf
   \   0000DF   12....       LCALL   ?XSTACK_DISP100_8
   \   0000E2   7408         MOV     A,#0x8
   \   0000E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E7   12....       LCALL   ??Subroutine51_0 & 0xFFFF
    795                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_92:
   \   0000EA   740A         MOV     A,#0xa
   \   0000EC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EF   E4           CLR     A
   \   0000F0   F0           MOVX    @DPTR,A
    796          
    797                APSME_TransportKeyReq( &req );
   \   0000F1                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000F1   7402         MOV     A,#0x2
   \   0000F3   12....       LCALL   ?XSTACK_DISP101_8
   \   0000F6   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
    798          
    799                // clear copy of key in RAM
    800                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   0000F9                ; Setup parameters for call to function osal_memset
   \   0000F9   7C10         MOV     R4,#0x10
   \   0000FB   7D00         MOV     R5,#0x0
   \   0000FD   7900         MOV     R1,#0x0
   \   0000FF   7417         MOV     A,#0x17
   \   000101   12....       LCALL   ?XSTACK_DISP101_8
   \   000104   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    801          
    802              }
    803            }
    804          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   000107   7427         MOV     A,#0x27
   \   000109   02....       LJMP    ??Subroutine53_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine47_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_129:
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine48_0
   \   000002                ; // Fall through to label ??Subroutine48_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine49_0
   \   000004                ; // Fall through to label ??Subroutine49_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine49_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine50_0
   \   000002                ; // Fall through to label ??Subroutine50_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine51_0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine53_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine54_0
   \   000003                ; // Fall through to label ??Subroutine54_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine54_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    805          
    806          /******************************************************************************
    807           * @fn          ZDSecMgrSendNwkKey
    808           *
    809           * @brief       Send NWK key to device joining network.
    810           *
    811           * @param       device - [in] ZDSecMgrDevice_t, device info
    812           *
    813           * @return      ZStatus_t
    814           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    815          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
    816          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    817            ZStatus_t status;
    818            APSME_TransportKeyReq_t req;
    819            APSDE_FrameTunnel_t tunnel;
    820            nwkKeyDesc tmpKey;
    821          
    822            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   12....       LCALL   ?Subroutine9 & 0xFFFF
    823            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_70:
   \   00001E   7406         MOV     A,#0x6
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ?Subroutine19 & 0xFFFF
    824          
    825            req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_13:
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   7401         MOV     A,#0x1
   \   00002B   F0           MOVX    @DPTR,A
    826          
    827            // get the Active Key into a local variable
    828            if ( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
    829                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   00002C                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   00002C   75..3A       MOV     ?V0,#0x3a
   \   00002F   75..00       MOV     ?V1,#0x0
   \   000032   78..         MOV     R0,#?V0
   \   000034   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000037   740F         MOV     A,#0xf
   \   000039   12....       LCALL   ?XSTACK_DISP100_8
   \   00003C   88..         MOV     ?V0,R0
   \   00003E   89..         MOV     ?V1,R1
   \   000040   78..         MOV     R0,#?V0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   7C11         MOV     R4,#0x11
   \   000047   7D00         MOV     R5,#0x0
   \   000049   7A00         MOV     R2,#0x0
   \   00004B   7B00         MOV     R3,#0x0
   \   00004D   12....       LCALL   `??NLME_ReadNwkKeyInfo::?relay`; Banked call to: NLME_ReadNwkKeyInfo
   \   000050   7404         MOV     A,#0x4
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   \   000055   E9           MOV     A,R1
   \   000056   600E         JZ      ??ZDSecMgrSendNwkKey_0
    830            {
    831              // set key data to all 0s if NV read fails
    832              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   000058                ; Setup parameters for call to function osal_memset
   \   000058   7C11         MOV     R4,#0x11
   \   00005A   7D00         MOV     R5,#0x0
   \   00005C   7900         MOV     R1,#0x0
   \   00005E   740D         MOV     A,#0xd
   \   000060   12....       LCALL   ?XSTACK_DISP101_8
   \   000063   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    833            }
    834          
    835            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
    836            {
    837              // set values
    838              req.keySeqNum = tmpKey.keySeqNum;
    839              req.key       = tmpKey.key;
    840          
    841              //devtag.pro.security.todo - make sure that if there is no link key the NWK
    842              //key isn't used to secure the frame at the APS layer -- since the receiving
    843              //device may not have a NWK key yet
    844              req.apsSecure = TRUE;
    845          
    846              // check if using secure hop to parent
    847              if ( device->parentAddr == NLME_GetShortAddr() )
    848              {
    849                req.nwkSecure = FALSE;
    850                req.tunnel    = NULL;
    851              }
    852              else
    853              {
    854                req.nwkSecure   = TRUE;
    855                req.tunnel      = &tunnel;
    856                req.tunnel->tna = device->parentAddr;
    857                req.tunnel->dea = device->extAddr;
    858              }
    859            }
    860            else
    861            {
    862              // default values
    863              //devtag.0604.verify
    864              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000066   740A         MOV     A,#0xa
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   7401         MOV     A,#0x1
   \   00006D   F0           MOVX    @DPTR,A
    865              req.apsSecure = FALSE;
   \   00006E   7409         MOV     A,#0x9
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E4           CLR     A
   \   000074   F0           MOVX    @DPTR,A
    866              req.tunnel    = NULL;
   \   000075   740B         MOV     A,#0xb
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   E4           CLR     A
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   F0           MOVX    @DPTR,A
    867          
    868              if ( device->parentAddr != NLME_GetShortAddr() )
   \   00007E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00007E   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000081   8A..         MOV     ?V0,R2
   \   000083   8B..         MOV     ?V1,R3
   \   000085   A8..         MOV     R0,?V0
   \   000087   A9..         MOV     R1,?V1
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   68           XRL     A,R0
   \   000093   7003         JNZ     ??ZDSecMgrSendNwkKey_1
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_1:
   \   000098   600B         JZ      ??CrossCallReturnLabel_102
    869              {
    870                req.dstAddr = device->parentAddr;
   \   00009A   8E82         MOV     DPL,R6
   \   00009C   8F83         MOV     DPH,R7
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   A3           INC     DPTR
   \   0000A2   12....       LCALL   ?Subroutine20 & 0xFFFF
    871              }
    872          
    873              // send the real key
    874              if ( zgPreConfigKeys == FALSE )
   \                     ??CrossCallReturnLabel_102:
   \   0000A5   90....       MOV     DPTR,#zgPreConfigKeys
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   7041         JNZ     ??ZDSecMgrSendNwkKey_2
    875              {
    876                req.keySeqNum = tmpKey.keySeqNum;
   \   0000AB   740D         MOV     A,#0xd
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   C0E0         PUSH    A
   \   0000B3   7403         MOV     A,#0x3
   \   0000B5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B8   D0E0         POP     A
   \   0000BA   F0           MOVX    @DPTR,A
    877                req.key       = tmpKey.key;
   \   0000BB   740E         MOV     A,#0xe
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   A882         MOV     R0,DPL
   \   0000C2   A983         MOV     R1,DPH
   \   0000C4   7404         MOV     A,#0x4
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   12....       LCALL   ??Subroutine51_0 & 0xFFFF
    878          
    879                // check if using secure hop to to parent
    880                if ( device->parentAddr == NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_93:
   \   0000CC                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000CC   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   0000CF   8A..         MOV     ?V0,R2
   \   0000D1   8B..         MOV     ?V1,R3
   \   0000D3   A8..         MOV     R0,?V0
   \   0000D5   A9..         MOV     R1,?V1
   \   0000D7   8E82         MOV     DPL,R6
   \   0000D9   8F83         MOV     DPH,R7
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   E0           MOVX    A,@DPTR
   \   0000E0   68           XRL     A,R0
   \   0000E1   7003         JNZ     ??ZDSecMgrSendNwkKey_3
   \   0000E3   A3           INC     DPTR
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000E6   7014         JNZ     ??ZDSecMgrSendNwkKey_4
    881                {
    882                  req.nwkSecure = FALSE;
   \   0000E8   740A         MOV     A,#0xa
   \   0000EA   800B         SJMP    ??ZDSecMgrSendNwkKey_5
    883                }
    884              }
    885              else
    886              {
    887                // this is to send the all zero key when the NWK key has been preconfigured
    888                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000EC   7404         MOV     A,#0x4
   \   0000EE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F1   E4           CLR     A
   \   0000F2   F0           MOVX    @DPTR,A
   \   0000F3   A3           INC     DPTR
   \   0000F4   F0           MOVX    @DPTR,A
    889                req.keySeqNum = 0;
   \   0000F5   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_5:
   \   0000F7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000FA   E4           CLR     A
   \   0000FB   F0           MOVX    @DPTR,A
    890              }
    891            }
    892          
    893            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000FC                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000FC   AA..         MOV     R2,?XSP + 0
   \   0000FE   AB..         MOV     R3,?XSP + 1
   \   000100   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   000103   E9           MOV     A,R1
   \   000104   FE           MOV     R6,A
    894          
    895            // clear copy of key in RAM before return
    896            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   000105                ; Setup parameters for call to function osal_memset
   \   000105   7C11         MOV     R4,#0x11
   \   000107   7D00         MOV     R5,#0x0
   \   000109   7900         MOV     R1,#0x0
   \   00010B   740D         MOV     A,#0xd
   \   00010D   12....       LCALL   ?XSTACK_DISP101_8
   \   000110   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    897          
    898            return status;
   \   000113   EE           MOV     A,R6
   \   000114   F9           MOV     R1,A
   \   000115   741E         MOV     A,#0x1e
   \   000117   02....       LJMP    ??Subroutine53_0 & 0xFFFF
    899          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004                REQUIRE ??Subroutine47_0
   \   000004                ; // Fall through to label ??Subroutine47_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ??Subroutine48_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_126:
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009                REQUIRE ??Subroutine51_0
   \   000009                ; // Fall through to label ??Subroutine51_0
    900          
    901          /******************************************************************************
    902           * @fn          ZDSecMgrDeviceRemoveByExtAddr
    903           *
    904           * @brief       Remove device entry by its ext address.
    905           *
    906           * @param       pAddr - pointer to the extended address
    907           *
    908           * @return      ZStatus_t
    909           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    910          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
    911          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    912            ZDSecMgrEntry_t *pEntry;
    913            uint8           retValue;
    914          
    915            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000A                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000A   AC..         MOV     R4,?XSP + 0
   \   00000C   AD..         MOV     R5,?XSP + 1
   \   00000E   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000011   E9           MOV     A,R1
   \   000012   FE           MOV     R6,A
    916          
    917            if( retValue == ZSuccess )
   \   000013   700C         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
    918            {
    919              // remove device from entry data
    920              ZDSecMgrEntryFree( pEntry );
   \   000015                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   12....       LCALL   ??Subroutine50_0 & 0xFFFF
    921            }
   \                     ??CrossCallReturnLabel_77:
   \   00001E   12....       LCALL   `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
    922          
    923            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   000021   EE           MOV     A,R6
   \   000022   F9           MOV     R1,A
   \   000023                REQUIRE ?Subroutine6
   \   000023                ; // Fall through to label ?Subroutine6
    924          }
    925          
    926          /******************************************************************************
    927           * @fn          ZDSecMgrDeviceRemove
    928           *
    929           * @brief       Remove device from network.
    930           *
    931           * @param       device - [in] ZDSecMgrDevice_t, device info
    932           *
    933           * @return      none
    934           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    935          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
    936          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    937            APSME_RemoveDeviceReq_t remDevReq;
    938            NLME_LeaveReq_t         leaveReq;
    939            associated_devices_t*   assoc;
    940          
    941            // check if parent, remove the device
    942            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV     ?V0,R2
   \   000013   8B..         MOV     ?V1,R3
   \   000015   A8..         MOV     R0,?V0
   \   000017   A9..         MOV     R1,?V1
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   68           XRL     A,R0
   \   000023   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??ZDSecMgrDeviceRemove_1 & 0xFFFF
    943            {
    944              // this is the parent of the device
    945              leaveReq.extAddr        = device->extAddr;
   \   00002D   EE           MOV     A,R6
   \   00002E   2402         ADD     A,#0x2
   \   000030   F8           MOV     R0,A
   \   000031   E4           CLR     A
   \   000032   3F           ADDC    A,R7
   \   000033   F9           MOV     R1,A
   \   000034   8882         MOV     DPL,R0
   \   000036   8983         MOV     DPH,R1
   \   000038   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_26:
   \   00003B   12....       LCALL   ?Subroutine39 & 0xFFFF
    946              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_47:
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E4           CLR     A
   \   000044   F0           MOVX    @DPTR,A
    947              leaveReq.rejoin         = FALSE;
   \   000045   7403         MOV     A,#0x3
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E4           CLR     A
   \   00004B   F0           MOVX    @DPTR,A
    948          
    949              // find child association
    950              assoc = AssocGetWithExt( device->extAddr );
   \   00004C                ; Setup parameters for call to function AssocGetWithExt
   \   00004C   8882         MOV     DPL,R0
   \   00004E   8983         MOV     DPH,R1
   \   000050   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   000053   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000056   8A..         MOV     ?V0,R2
   \   000058   8B..         MOV     ?V1,R3
   \   00005A   A8..         MOV     R0,?V0
   \   00005C   A9..         MOV     R1,?V1
    951          
    952              if ( ( assoc != NULL                            ) &&
    953                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
    954                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00005E   E8           MOV     A,R0
   \   00005F   49           ORL     A,R1
   \   000060   6027         JZ      ??ZDSecMgrDeviceRemove_2
   \   000062   8882         MOV     DPL,R0
   \   000064   8983         MOV     DPH,R1
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   601C         JZ      ??ZDSecMgrDeviceRemove_2
   \   00006D   C3           CLR     C
   \   00006E   9405         SUBB    A,#0x5
   \   000070   5017         JNC     ??ZDSecMgrDeviceRemove_2
    955              {
    956                // check if associated device is authenticated
    957                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000072   8882         MOV     DPL,R0
   \   000074   8983         MOV     DPH,R1
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   A2E3         MOV     C,0xE0 /* A   */.3
   \   00007E   7404         MOV     A,#0x4
   \   000080   402B         JC      ??ZDSecMgrDeviceRemove_3
    958                {
    959                  leaveReq.silent = FALSE;
    960                }
    961                else
    962                {
    963                  leaveReq.silent = TRUE;
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   7401         MOV     A,#0x1
   \   000087   8028         SJMP    ??ZDSecMgrDeviceRemove_4
   \   000089                ; Setup parameters for call to function NLME_LeaveReq
    964                }
    965          
    966                NLME_LeaveReq( &leaveReq );
    967              }
    968              else if ( device->nwkAddr == NLME_GetShortAddr() )
   \                     ??ZDSecMgrDeviceRemove_2:
   \   000089                ; Setup parameters for call to function NLME_GetShortAddr
   \   000089   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00008C   8A..         MOV     ?V0,R2
   \   00008E   8B..         MOV     ?V1,R3
   \   000090   A8..         MOV     R0,?V0
   \   000092   A9..         MOV     R1,?V1
   \   000094   8E82         MOV     DPL,R6
   \   000096   8F83         MOV     DPH,R7
   \   000098   E0           MOVX    A,@DPTR
   \   000099   68           XRL     A,R0
   \   00009A   7003         JNZ     ??ZDSecMgrDeviceRemove_5
   \   00009C   A3           INC     DPTR
   \   00009D   E0           MOVX    A,@DPTR
   \   00009E   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_5:
   \   00009F   703A         JNZ     ??ZDSecMgrDeviceRemove_6
    969              {
    970                // this is when ZC wants that ZR removes itself from the network
    971                leaveReq.extAddr = NULL;
   \   0000A1   85..82       MOV     DPL,?XSP + 0
   \   0000A4   85..83       MOV     DPH,?XSP + 1
   \   0000A7   E4           CLR     A
   \   0000A8   F0           MOVX    @DPTR,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   F0           MOVX    @DPTR,A
    972                leaveReq.silent = FALSE;
   \   0000AB   7404         MOV     A,#0x4
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   E4           CLR     A
    973          
    974                NLME_LeaveReq( &leaveReq );
    975              }
    976            }
   \                     ??ZDSecMgrDeviceRemove_4:
   \   0000B1   12....       LCALL   ??Subroutine56_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   0000B4   12....       LCALL   `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   0000B7   8022         SJMP    ??ZDSecMgrDeviceRemove_6
    977            else
    978            {
    979              // this is not the parent of the device
    980              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000B9   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   0000BC   7405         MOV     A,#0x5
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   12....       LCALL   ?Subroutine9 & 0xFFFF
    981              remDevReq.childExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_71:
   \   0000C4   7407         MOV     A,#0x7
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   12....       LCALL   ??Subroutine51_0 & 0xFFFF
    982          
    983          #if defined ( APP_TP2_TEST_MODE )
    984              if ( guTxApsSecON == TRUE )
    985              {
    986                remDevReq.apsSecure = TRUE;
    987              }
    988              else
    989              {
    990                remDevReq.apsSecure = FALSE;
    991              }
    992          
    993              APSME_RemoveDeviceReq( &remDevReq );
    994          
    995          #else
    996              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
    997              {
    998                // For ZG_GLOBAL_LINK_KEY the message has to be sent twice, one
    999                // APS un-encrypted and one APS encrypted, to make sure that it can interoperate
   1000                // with legacy Coordinator devices which can only handle one or the other.
   1001                if ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY )
   1002                {
   1003                  remDevReq.apsSecure = FALSE;
   1004          
   1005                  APSME_RemoveDeviceReq( &remDevReq );
   1006                }
   1007          
   1008                remDevReq.apsSecure = TRUE;
   1009          
   1010                APSME_RemoveDeviceReq( &remDevReq );
   1011              }
   1012              else
   1013              {
   1014                remDevReq.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_94:
   \   0000CC   7409         MOV     A,#0x9
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   E4           CLR     A
   \   0000D2   F0           MOVX    @DPTR,A
   1015          
   1016                APSME_RemoveDeviceReq( &remDevReq );
   \   0000D3                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   0000D3   7405         MOV     A,#0x5
   \   0000D5   12....       LCALL   ?XSTACK_DISP101_8
   \   0000D8   12....       LCALL   `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   1017              }
   1018          #endif
   1019            }
   1020          }
   \                     ??ZDSecMgrDeviceRemove_6:
   \   0000DB   740A         MOV     A,#0xa
   \   0000DD   02....       LJMP    ??Subroutine53_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004   A3           INC     DPTR
   \   000005   A3           INC     DPTR
   \   000006                REQUIRE ??Subroutine60_0
   \   000006                ; // Fall through to label ??Subroutine60_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine60_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine61_0
   \   000002                ; // Fall through to label ??Subroutine61_0
   1021          
   1022          /******************************************************************************
   1023           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1024           *
   1025           * @brief       Decide whether device is allowed.
   1026           *
   1027           * @param       device - [in] ZDSecMgrDevice_t, device info
   1028           *
   1029           * @return      ZStatus_t
   1030           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1031          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1032          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1033            ZStatus_t status;
   1034          
   1035            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1036          
   1037            (void)device;  // Intentionally unreferenced parameter
   1038          
   1039            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1040            // the trust center to reject any newly joining devices by sending
   1041            // Remove-device to the parents.
   1042            if ( zgSecurePermitJoin == FALSE )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1043            {
   1044              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1045            }
   1046          
   1047          
   1048          
   1049          #if 0  // Taken out because the following functionality is only used for test
   1050                 // purpose. A more efficient (above) way is used. It can be put
   1051                 // back in if customers request for a white/black list feature.
   1052                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1053          
   1054            // The following code processes the device black list (stored device list)
   1055            // If the joining device is not part of the forbidden device list
   1056            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1057            // will send Remove-device and ban the device from joining.
   1058          
   1059            uint8     index;
   1060            uint8*    restricted;
   1061          
   1062            // Look through the stored device list - used for restricted devices
   1063            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1064            {
   1065              restricted = ZDSecMgrStoredDeviceList[index];
   1066          
   1067              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1068              {
   1069                // return as unknown device in regards to validation
   1070                status = ZNwkUnknownDevice;
   1071          
   1072                // break from loop
   1073                index = ZDSECMGR_STORED_DEVICES;
   1074              }
   1075            }
   1076          
   1077          #endif
   1078          
   1079            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   1080          }
   1081          
   1082          /******************************************************************************
   1083           * @fn          ZDSecMgrDeviceValidate
   1084           *
   1085           * @brief       Decide whether device is allowed.
   1086           *
   1087           * @param       device - [in] ZDSecMgrDevice_t, device info
   1088           *
   1089           * @return      ZStatus_t
   1090           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1091          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1092          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1093            ZStatus_t status;
   1094          
   1095            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7007         JNZ     ??ZDSecMgrDeviceValidate_0
   1096            {
   1097              status = ZDSecMgrDeviceValidateRM( device );
   \   00000C                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   00000C   12....       LCALL   `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   00000F   E9           MOV     A,R1
   \   000010   F9           MOV     R1,A
   \   000011   8002         SJMP    ??ZDSecMgrDeviceValidate_1
   1098            }
   1099            else
   1100            {
   1101              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   000013   79C8         MOV     R1,#-0x38
   1102            }
   1103          
   1104            return status;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000015   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   1105          }
   1106          
   1107          /******************************************************************************
   1108           * @fn          ZDSecMgrDeviceJoin
   1109           *
   1110           * @brief       Try to join this device.
   1111           *
   1112           * @param       device - [in] ZDSecMgrDevice_t, device info
   1113           *
   1114           * @return      ZStatus_t
   1115           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1116          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   1117          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1118            ZStatus_t status = ZSuccess;
   \   00000E   75..00       MOV     ?V0,#0x0
   1119            uint16    ami;
   1120          
   1121            // attempt to validate device that joined/rejoined without security
   1122            if ( device->secure == FALSE )
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   7008         JNZ     ??ZDSecMgrDeviceJoin_0
   1123            {
   1124              status = ZDSecMgrDeviceValidate( device );
   \   00001E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00001E   12....       LCALL   `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   000021   E9           MOV     A,R1
   \   000022   F5..         MOV     ?V0,A
   1125            }
   1126          
   1127          #if 0  //chaokw panid
   1128          #if NODE_AUTH   //chaokw
   1129            if ( status == ZSuccess )
   1130            {
   1131              if (!Authlist_verify_device(device->nwkAddr, device->extAddr, 0, 0))
   1132                status = ZNwkUnknownDevice;
   1133            }
   1134          #endif
   1135          #endif
   1136          
   1137            if ( status == ZSuccess )
   \   000024   7058         JNZ     ??ZDSecMgrDeviceJoin_1
   1138            {
   1139              // Add the device to the address manager
   1140              ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000026                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000026   A8..         MOV     R0,?XSP + 0
   \   000028   A9..         MOV     R1,?XSP + 1
   \   00002A   88..         MOV     ?V2,R0
   \   00002C   89..         MOV     ?V3,R1
   \   00002E   78..         MOV     R0,#?V2
   \   000030   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FC           MOV     R4,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   FD           MOV     R5,A
   \   00003E   8E82         MOV     DPL,R6
   \   000040   8F83         MOV     DPH,R7
   \   000042   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000045   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000048   7402         MOV     A,#0x2
   \   00004A   12....       LCALL   ?DEALLOC_XSTACK8
   1141          
   1142              // Only send the key to devices that have not been authenticated
   1143              if ( ( device->devStatus & DEV_SEC_INIT_STATUS ) &&
   1144                   ( device->secure == FALSE ) )
   \   00004D   8E82         MOV     DPL,R6
   \   00004F   8F83         MOV     DPH,R7
   \   000051   A3           INC     DPTR
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   A2E2         MOV     C,0xE0 /* A   */.2
   \   00005B   5021         JNC     ??ZDSecMgrDeviceJoin_1
   \   00005D   8E82         MOV     DPL,R6
   \   00005F   8F83         MOV     DPH,R7
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   7014         JNZ     ??ZDSecMgrDeviceJoin_1
   1145              {
   1146                //send the nwk key data to the joining device
   1147                status = ZDSecMgrSendNwkKey( device );
   \   00006A                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00006A   EE           MOV     A,R6
   \   00006B   FA           MOV     R2,A
   \   00006C   EF           MOV     A,R7
   \   00006D   FB           MOV     R3,A
   \   00006E   12....       LCALL   `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   000071   E9           MOV     A,R1
   \   000072   F5..         MOV     ?V0,A
   1148              }
   1149          
   1150              if ( status != ZSuccess )
   \   000074   6015         JZ      ??ZDSecMgrDeviceJoin_2
   1151              {
   1152                ZDSecMgrAddrClear( device->extAddr );
   \   000076                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   000076   12....       LCALL   ?Subroutine30 & 0xFFFF
   1153              }
   1154            }
   \                     ??CrossCallReturnLabel_87:
   \   000079   12....       LCALL   `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
   \   00007C   8004         SJMP    ??ZDSecMgrDeviceJoin_3
   1155          
   1156            if ( status != ZSuccess )
   \                     ??ZDSecMgrDeviceJoin_1:
   \   00007E   E5..         MOV     A,?V0
   \   000080   6009         JZ      ??ZDSecMgrDeviceJoin_2
   1157            {
   1158              // not allowed or transport key failed, remove the device
   1159              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_3:
   \   000082                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000082   EE           MOV     A,R6
   \   000083   FA           MOV     R2,A
   \   000084   EF           MOV     A,R7
   \   000085   FB           MOV     R3,A
   \   000086   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   \   000089   8056         SJMP    ??ZDSecMgrDeviceJoin_4
   1160            }
   1161            else
   1162            {
   1163              // Pass the Trust Center Device Indication to higher layer if callback registered
   1164              if (zdoCBFunc[ZDO_TC_DEVICE_CBID] != NULL )
   \                     ??ZDSecMgrDeviceJoin_2:
   \   00008B   90....       MOV     DPTR,#zdoCBFunc + 16
   \   00008E   12....       LCALL   ??Subroutine65_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   000091   604E         JZ      ??ZDSecMgrDeviceJoin_4
   1165              {
   1166                ZDO_TC_Device_t dev;
   1167          
   1168                dev.nwkAddr = device->nwkAddr;
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   00009A   12....       LCALL   ?XSTACK_DISP0_8
   \   00009D   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   1169                osal_memcpy( dev.extAddr, device->extAddr, Z_EXTADDR_LEN );
   \                     ??CrossCallReturnLabel_95:
   \   0000A0                ; Setup parameters for call to function osal_memcpy
   \   0000A0   8E82         MOV     DPL,R6
   \   0000A2   8F83         MOV     DPH,R7
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   F5..         MOV     ?V4,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   F5..         MOV     ?V5,A
   \   0000AD   75..00       MOV     ?V6,#0x0
   \   0000B0   78..         MOV     R0,#?V4
   \   0000B2   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000B5   7C08         MOV     R4,#0x8
   \   0000B7   7D00         MOV     R5,#0x0
   \   0000B9   7407         MOV     A,#0x7
   \   0000BB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BE   AA82         MOV     R2,DPL
   \   0000C0   AB83         MOV     R3,DPH
   \   0000C2   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000C5   7403         MOV     A,#0x3
   \   0000C7   12....       LCALL   ?DEALLOC_XSTACK8
   1170                dev.parentAddr = device->parentAddr;
   \   0000CA   12....       LCALL   ?Subroutine27 & 0xFFFF
   1171          
   1172                zdoCBFunc[ZDO_TC_DEVICE_CBID]( (void*)&dev );
   1173              }
   1174            }
   \                     ??CrossCallReturnLabel_124:
   \   0000CD   740C         MOV     A,#0xc
   \   0000CF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D2   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   0000D5   12....       LCALL   ?XSTACK_DISP101_8
   \   0000D8   90....       MOV     DPTR,#zdoCBFunc + 16
   \   0000DB   12....       LCALL   ??Subroutine59_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_114:
   \   0000DE   12....       LCALL   ?CALL_IND
   1175          
   1176            return status;
   \                     ??ZDSecMgrDeviceJoin_4:
   \   0000E1   A9..         MOV     R1,?V0
   \   0000E3   740E         MOV     A,#0xe
   \   0000E5                REQUIRE ?Subroutine4
   \   0000E5                ; // Fall through to label ?Subroutine4
   1177          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F07         MOV     R7,#0x7
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA
   1178          
   1179          /******************************************************************************
   1180           * @fn          ZDSecMgrDeviceJoinDirect
   1181           *
   1182           * @brief       Try to join this device as a direct child.
   1183           *
   1184           * @param       device - [in] ZDSecMgrDevice_t, device info
   1185           *
   1186           * @return      ZStatus_t
   1187           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1188          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   1189          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1190            ZStatus_t status;
   1191          
   1192            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0,A
   1193          
   1194            if ( status == ZSuccess )
   \   00000F   700D         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   1195            {
   1196              // set association status to authenticated
   1197              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   1198            }
   \                     ??CrossCallReturnLabel_80:
   \   000018   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   00001B   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1199          
   1200            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001E   A9..         MOV     R1,?V0
   \   000020   02....       LJMP    ??Subroutine58_0 & 0xFFFF
   1201          }
   1202          
   1203          /******************************************************************************
   1204           * @fn          ZDSecMgrDeviceJoinFwd
   1205           *
   1206           * @brief       Forward join to Trust Center.
   1207           *
   1208           * @param       device - [in] ZDSecMgrDevice_t, device info
   1209           *
   1210           * @return      ZStatus_t
   1211           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1212          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   1213          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1214            ZStatus_t               status;
   1215            APSME_UpdateDeviceReq_t req;
   1216          
   1217            // forward any joining device to the Trust Center -- the Trust Center will
   1218            // decide if the device is allowed to join
   1219            status = ZSuccess;
   1220          
   1221            // forward authorization to the Trust Center
   1222            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ?Subroutine37 & 0xFFFF
   1223            req.devAddr    = device->nwkAddr;
   \                     ??CrossCallReturnLabel_41:
   \   000016   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_24:
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine13 & 0xFFFF
   1224            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_0:
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   1225          
   1226            // set security status, option for router to reject if policy set
   1227            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_96:
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   A2E7         MOV     C,0xE0 /* A   */.7
   \   000033   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   1228            {
   1229              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000035   A2E6         MOV     C,0xE0 /* A   */.6
   \   000037   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   1230              {
   1231                if ( device->secure == TRUE )
   \   000039   8A82         MOV     DPL,R2
   \   00003B   8B83         MOV     DPH,R3
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   6401         XRL     A,#0x1
   \   000046   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   1232                {
   1233                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000048   7406         MOV     A,#0x6
   \   00004A   12....       LCALL   ?XSTACK_DISP0_8
   \   00004D   7404         MOV     A,#0x4
   \   00004F   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1234                }
   1235                else
   1236                {
   1237                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   000051   7406         MOV     A,#0x6
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   7407         MOV     A,#0x7
   \   000058   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1238                }
   1239              }
   1240              else
   1241              {
   1242                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   00005A   7406         MOV     A,#0x6
   \   00005C   12....       LCALL   ?XSTACK_DISP0_8
   \   00005F   7405         MOV     A,#0x5
   \   000061   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1243              }
   1244            }
   1245            else
   1246            {
   1247              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000063   A2E6         MOV     C,0xE0 /* A   */.6
   \   000065   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   1248              {
   1249                if ( device->secure == TRUE )
   \   000067   8A82         MOV     DPL,R2
   \   000069   8B83         MOV     DPH,R3
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   6401         XRL     A,#0x1
   \   000074   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   1250                {
   1251                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   000076   7406         MOV     A,#0x6
   \   000078   12....       LCALL   ?XSTACK_DISP0_8
   \   00007B   E4           CLR     A
   \   00007C   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1252                }
   1253                else
   1254                {
   1255                  req.status = APSME_UD_STANDARD_TRUST_CENTER_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   00007E   7406         MOV     A,#0x6
   \   000080   12....       LCALL   ?XSTACK_DISP0_8
   \   000083   7403         MOV     A,#0x3
   \   000085   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1256                }
   1257              }
   1258              else
   1259              {
   1260                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000087   7406         MOV     A,#0x6
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   7401         MOV     A,#0x1
   1261              }
   1262            }
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   00008E   12....       LCALL   ?Subroutine37 & 0xFFFF
   1263          
   1264            // set association status to authenticated
   1265            ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \                     ??CrossCallReturnLabel_42:
   \   000091   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000094   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   000097                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000097   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1266          
   1267          #if defined ( APP_TP2_TEST_MODE )
   1268            if ( guTxApsSecON == TRUE )
   1269            {
   1270              req.apsSecure = TRUE;
   1271            }
   1272            else
   1273            {
   1274              req.apsSecure = FALSE;
   1275            }
   1276          
   1277            // send and APSME_UPDATE_DEVICE request to the trust center
   1278            status = APSME_UpdateDeviceReq( &req );
   1279          
   1280          #else
   1281            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1282            {
   1283              // For ZG_GLOBAL_LINK_KEY the message has to be sent twice one
   1284              // un-encrypted and one APS encrypted, to make sure that it can interoperate
   1285              // with legacy Coordinator devices which can only handle one or the other.
   1286              if ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY )
   1287              {
   1288                req.apsSecure = FALSE;
   1289          
   1290                // send and APSME_UPDATE_DEVICE request to the trust center
   1291                status = APSME_UpdateDeviceReq( &req );
   1292              }
   1293          
   1294              // send the message APS encrypted
   1295              req.apsSecure = TRUE;
   1296          
   1297              // send and APSME_UPDATE_DEVICE request to the trust center
   1298              status = APSME_UpdateDeviceReq( &req );
   1299            }
   1300            else
   1301            {
   1302              req.apsSecure = FALSE;
   \   00009A   7407         MOV     A,#0x7
   \   00009C   12....       LCALL   ?XSTACK_DISP0_8
   \   00009F   E4           CLR     A
   \   0000A0   12....       LCALL   ??Subroutine56_0 & 0xFFFF
   1303          
   1304              // send and APSME_UPDATE_DEVICE request to the trust center
   1305              status = APSME_UpdateDeviceReq( &req );
   1306            }
   1307          #endif
   1308          
   1309            return status;
   \                     ??CrossCallReturnLabel_108:
   \   0000A3   12....       LCALL   `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   0000A6   02....       LJMP    ?Subroutine3 & 0xFFFF
   1310          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7408         MOV     A,#0x8
   \   000002                REQUIRE ??Subroutine53_0
   \   000002                ; // Fall through to label ??Subroutine53_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_43:
   \   000007   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   00000A   7404         MOV     A,#0x4
   \   00000C   22           RET
   1311          
   1312          /******************************************************************************
   1313           * @fn          ZDSecMgrDeviceNew
   1314           *
   1315           * @brief       Process a new device.
   1316           *
   1317           * @param       device - [in] ZDSecMgrDevice_t, device info
   1318           *
   1319           * @return      ZStatus_t
   1320           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1321          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   1322          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1323            ZStatus_t status;
   1324          
   1325            if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1326                || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   \   000009                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000009   12....       LCALL   `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   00000C   E9           MOV     A,R1
   \   00000D   6009         JZ      ??ZDSecMgrDeviceNew_0
   1327            {
   1328              // try to join this device
   1329              status = ZDSecMgrDeviceJoinDirect( joiner );
   \   00000F                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   00000F   EE           MOV     A,R6
   \   000010   FA           MOV     R2,A
   \   000011   EF           MOV     A,R7
   \   000012   FB           MOV     R3,A
   \   000013   12....       LCALL   `??ZDSecMgrDeviceJoinDirect::?relay`; Banked call to: ZDSecMgrDeviceJoinDirect
   \   000016   8007         SJMP    ??ZDSecMgrDeviceNew_1
   1330            }
   1331            else
   1332            {
   1333              status = ZDSecMgrDeviceJoinFwd( joiner );
   \                     ??ZDSecMgrDeviceNew_0:
   \   000018                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000018   EE           MOV     A,R6
   \   000019   FA           MOV     R2,A
   \   00001A   EF           MOV     A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   `??ZDSecMgrDeviceJoinFwd::?relay`; Banked call to: ZDSecMgrDeviceJoinFwd
   \                     ??ZDSecMgrDeviceNew_1:
   \   00001F   E9           MOV     A,R1
   \   000020   F9           MOV     R1,A
   1334            }
   1335          
   1336            return status;
   \   000021   02....       LJMP    ??Subroutine58_0 & 0xFFFF
   1337          }
   1338          
   1339          /******************************************************************************
   1340           * @fn          ZDSecMgrAssocDeviceAuth
   1341           *
   1342           * @brief       Set associated device status to authenticated
   1343           *
   1344           * @param       assoc - [in, out] associated_devices_t
   1345           *
   1346           * @return      none
   1347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1348          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   1349          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1350            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   1351            {
   1352              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   1353            }
   1354          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   80..         SJMP    ??Subroutine52_0
   1355          
   1356          /******************************************************************************
   1357           * @fn          ZDSecMgrAuthNwkKey
   1358           *
   1359           * @brief       Handle next step in authentication process
   1360           *
   1361           * @param       none
   1362           *
   1363           * @return      none
   1364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1365          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   1366          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1367            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   1368            {
   1369              // inform ZDO that device has been authenticated
   1370              osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   1371            }
   1372          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine52_0
   1373          
   1374          /******************************************************************************
   1375           * PUBLIC FUNCTIONS
   1376           */
   1377          /******************************************************************************
   1378           * @fn          ZDSecMgrInit
   1379           *
   1380           * @brief       Initialize ZigBee Device Security Manager.
   1381           *
   1382           * @param       state - device initialization state
   1383           *
   1384           * @return      none
   1385           */
   1386          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1387          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   1388          void ZDSecMgrAddrMgrCB( uint8           update,
   1389                                  AddrMgrEntry_t* newEntry,
   1390                                  AddrMgrEntry_t* oldEntry )
   1391          {
   1392            (void)update;
   1393            (void)newEntry;
   1394            (void)oldEntry;
   1395          }
   1396          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1397          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1398          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   1399          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1400            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1401            {
   1402              // initialize sub modules
   1403              ZDSecMgrEntryInit(state);
   1404          
   1405              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1406              {
   1407                APSME_SetRequest( apsTrustCenterAddress, 0, NLME_GetExtAddr() );
   1408              }
   1409          
   1410              // register with Address Manager
   1411          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1412              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   1413          #endif
   1414            }
   1415          
   1416            if ( ZG_SECURE_ENABLED )
   1417            {
   1418              if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1419                   || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   \   000004                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000004   12....       LCALL   `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   000007   E9           MOV     A,R1
   \   000008   600B         JZ      ??ZDSecMgrInit_0
   1420              {
   1421                // setup joining permissions
   1422                ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00000A   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000D   7401         MOV     A,#0x1
   \   00000F   F0           MOVX    @DPTR,A
   1423                ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000010   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000013   E4           CLR     A
   \   000014   F0           MOVX    @DPTR,A
   1424              }
   1425            }
   1426          
   1427            // configure security based on security mode and type of device
   1428            ZDSecMgrConfig();
   \                     ??ZDSecMgrInit_0:
   \   000015                ; Setup parameters for call to function SSP_Init
   \   000015   80..         SJMP    ?Subroutine1
   1429          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   `??SSP_Init::?relay` ; Banked call to: SSP_Init
   \   000003                ; Setup parameters for call to function APSME_SecurityRM_RD
   \   000003                ; Setup parameters for call to function APSME_SecurityRM_RD
   \   000003   12....       LCALL   `??APSME_SecurityRM_RD::?relay`; Banked call to: APSME_SecurityRM_RD
   \   000006                REQUIRE ??Subroutine52_0
   \   000006                ; // Fall through to label ??Subroutine52_0
   1430          
   1431          /******************************************************************************
   1432           * @fn          ZDSecMgrConfig
   1433           *
   1434           * @brief       Configure ZigBee Device Security Manager.
   1435           *
   1436           * @param       none
   1437           *
   1438           * @return      none
   1439           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1440          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   1441          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1442            if ( ZG_SECURE_ENABLED )
   1443            {
   1444              SSP_Init();
   \   000004                ; Setup parameters for call to function SSP_Init
   \   000004   80..         SJMP    ?Subroutine1
   1445          
   1446              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1447              {
   1448                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1449                {
   1450                  // COMMERCIAL MODE - COORDINATOR DEVICE
   1451                  APSME_SecurityCM_CD();
   1452                }
   1453                else if ( ZSTACK_ROUTER_BUILD )
   1454                {
   1455                  // COMMERCIAL MODE - ROUTER DEVICE
   1456                  APSME_SecurityCM_RD();
   1457                }
   1458                else
   1459                {
   1460                  // COMMERCIAL MODE - END DEVICE
   1461                  APSME_SecurityCM_ED();
   1462                }
   1463              }
   1464              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1465              {
   1466                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1467                {
   1468                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   1469                  APSME_SecurityRM_CD();
   1470                }
   1471                else if ( ZSTACK_ROUTER_BUILD )
   1472                {
   1473                  // RESIDENTIAL MODE - ROUTER DEVICE
   1474                  APSME_SecurityRM_RD();
   1475                }
   1476                else
   1477                {
   1478                  // RESIDENTIAL MODE - END DEVICE
   1479                  APSME_SecurityRM_ED();
   1480                }
   1481              }
   1482            }
   1483            else
   1484            {
   1485              // NO SECURITY
   1486              APSME_SecurityNM();
   1487            }
   1488          }
   1489          
   1490          /******************************************************************************
   1491           * @fn          ZDSecMgrPermitJoining
   1492           *
   1493           * @brief       Process request to change joining permissions.
   1494           *
   1495           * @param       duration - [in] timed duration for join in seconds
   1496           *                         - 0x00 not allowed
   1497           *                         - 0xFF allowed without timeout
   1498           *
   1499           * @return      uint8 - success(TRUE:FALSE)
   1500           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1501          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   1502          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   1503            uint8 accept;
   1504          
   1505            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   E4           CLR     A
   \   00000A   F0           MOVX    @DPTR,A
   1506          
   1507            if ( duration > 0 )
   \   00000B   E8           MOV     A,R0
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   600F         JZ      ??ZDSecMgrPermitJoining_0
   1508            {
   1509              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000011   7401         MOV     A,#0x1
   \   000013   F0           MOVX    @DPTR,A
   1510          
   1511              if ( duration != 0xFF )
   \   000014   74FF         MOV     A,#-0x1
   \   000016   68           XRL     A,R0
   \   000017   6009         JZ      ??ZDSecMgrPermitJoining_1
   1512              {
   1513                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrPermitJoining_2
   1514              }
   1515            }
   1516            else
   1517            {
   1518              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrPermitJoining_2:
   \   000021   F0           MOVX    @DPTR,A
   1519            }
   1520          
   1521            accept = TRUE;
   1522          
   1523            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000022   7901         MOV     R1,#0x1
   \   000024   80..         SJMP    ??Subroutine52_0
   1524          }
   1525          
   1526          /******************************************************************************
   1527           * @fn          ZDSecMgrPermitJoiningTimeout
   1528           *
   1529           * @brief       Process permit joining timeout
   1530           *
   1531           * @param       none
   1532           *
   1533           * @return      none
   1534           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1535          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   1536          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1537            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   1538            {
   1539              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   1540              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   1541            }
   1542          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   80..         SJMP    ??Subroutine52_0
   1543          
   1544          /******************************************************************************
   1545           * @fn          ZDSecMgrNewDeviceEvent
   1546           *
   1547           * @brief       Process a the new device event, if found reset new device
   1548           *              event/timer.
   1549           *
   1550           * @param       ShortAddr - of New Device to process
   1551           *
   1552           * @return      uint8 - found(TRUE:FALSE)
   1553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1554          uint8 ZDSecMgrNewDeviceEvent( uint16 ShortAddr )
   \                     ZDSecMgrNewDeviceEvent:
   1555          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   1556            uint8                 found;
   1557            ZDSecMgrDevice_t      device;
   1558            AddrMgrEntry_t        addrEntry;
   1559            associated_devices_t* assoc;
   1560            ZStatus_t             status;
   1561          
   1562            // initialize return results
   1563            found = FALSE;
   \   00000A   75..00       MOV     ?V0,#0x0
   1564          
   1565            assoc = AssocGetWithShort( ShortAddr );
   \   00000D                ; Setup parameters for call to function AssocGetWithShort
   \   00000D   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   000010   8A..         MOV     ?V2,R2
   \   000012   8B..         MOV     ?V3,R3
   \   000014   AE..         MOV     R6,?V2
   \   000016   AF..         MOV     R7,?V3
   1566          
   1567            if ( assoc != NULL )
   \   000018   EE           MOV     A,R6
   \   000019   4F           ORL     A,R7
   \   00001A   7003         JNZ     $+5
   \   00001C   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   1568            {
   1569              // device found
   1570              found = TRUE;
   \   00001F   75..01       MOV     ?V0,#0x1
   1571          
   1572              // check for preconfigured security
   1573              if ( zgPreConfigKeys == TRUE )
   \   000022   90....       MOV     DPTR,#zgPreConfigKeys
   \   000025   E0           MOVX    A,@DPTR
   \   000026   6401         XRL     A,#0x1
   \   000028   7003         JNZ     ??ZDSecMgrNewDeviceEvent_1
   1574              {
   1575                // set association status to authenticated
   1576                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002A                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002A   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1577              }
   1578          
   1579              // set up device info
   1580              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   00002D   7408         MOV     A,#0x8
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E4           CLR     A
   \   000033   12....       LCALL   ??Subroutine47_0 & 0xFFFF
   1581              addrEntry.index = assoc->addrIdx;
   \                     ??CrossCallReturnLabel_73:
   \   000036   7413         MOV     A,#0x13
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   1582              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_97:
   \   00003E                ; Setup parameters for call to function AddrMgrEntryGet
   \   00003E   7408         MOV     A,#0x8
   \   000040   12....       LCALL   ?XSTACK_DISP101_8
   \   000043   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   1583          
   1584              device.nwkAddr    = assoc->shortAddr;
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   12....       LCALL   ?Subroutine20 & 0xFFFF
   1585              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_103:
   \   00004D   740B         MOV     A,#0xb
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   A882         MOV     R0,DPL
   \   000054   A983         MOV     R1,DPH
   \   000056   7402         MOV     A,#0x2
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   1586              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_98:
   \   00005E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00005E   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000061   7404         MOV     A,#0x4
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   EA           MOV     A,R2
   \   000067   F0           MOVX    @DPTR,A
   \   000068   A3           INC     DPTR
   \   000069   EB           MOV     A,R3
   \   00006A   12....       LCALL   ?Subroutine16 & 0xFFFF
   1587          
   1588              // the new device performed Secured Rejoin
   1589              if ( ( assoc->devStatus & DEV_SECURED_JOIN ) &&
   1590                   ( assoc->devStatus & DEV_REJOIN_STATUS ) )
   \                     ??CrossCallReturnLabel_4:
   \   00006D   5460         ANL     A,#0x60
   \   00006F   6460         XRL     A,#0x60
   \   000071   7009         JNZ     ??ZDSecMgrNewDeviceEvent_2
   1591              {
   1592                device.secure     = TRUE;
   \   000073   7406         MOV     A,#0x6
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   7401         MOV     A,#0x1
   \   00007A   8006         SJMP    ??ZDSecMgrNewDeviceEvent_3
   1593              }
   1594              else
   1595              {
   1596                device.secure     = FALSE;
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   00007C   7406         MOV     A,#0x6
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E4           CLR     A
   1597              }
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   000082   12....       LCALL   ?Subroutine16 & 0xFFFF
   1598              device.devStatus  = assoc->devStatus;
   \                     ??CrossCallReturnLabel_5:
   \   000085   C0E0         PUSH    A
   \   000087   7407         MOV     A,#0x7
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   D0E0         POP     A
   \   00008E   12....       LCALL   ??Subroutine56_0 & 0xFFFF
   1599          
   1600              // process new device
   1601              status = ZDSecMgrDeviceNew( &device );
   1602          
   1603              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_109:
   \   000091   12....       LCALL   `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   000094   E9           MOV     A,R1
   \   000095   700F         JNZ     ??ZDSecMgrNewDeviceEvent_4
   1604              {
   1605                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000097   8E82         MOV     DPL,R6
   \   000099   8F83         MOV     DPH,R7
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   A3           INC     DPTR
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   C2E2         CLR     0xE0 /* A   */.2
   \   0000A3   F0           MOVX    @DPTR,A
   \   0000A4   8018         SJMP    ??ZDSecMgrNewDeviceEvent_0
   1606              }
   1607              else
   1608              {
   1609                // Clear SECURITY bit from Address Manager
   1610                ZDSecMgrAddrClear( addrEntry.extAddr );
   \                     ??ZDSecMgrNewDeviceEvent_4:
   \   0000A6                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   0000A6   740B         MOV     A,#0xb
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   AA82         MOV     R2,DPL
   \   0000AD   AB83         MOV     R3,DPH
   \   0000AF   12....       LCALL   `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
   1611          
   1612                // Remove the Association completely
   1613                AssocRemove( addrEntry.extAddr );
   \   0000B2                ; Setup parameters for call to function AssocRemove
   \   0000B2   740B         MOV     A,#0xb
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   AA82         MOV     R2,DPL
   \   0000B9   AB83         MOV     R3,DPH
   \   0000BB   12....       LCALL   `??AssocRemove::?relay`; Banked call to: AssocRemove
   1614              }
   1615            }
   1616          
   1617            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   0000BE   A9..         MOV     R1,?V0
   \   0000C0   7415         MOV     A,#0x15
   \   0000C2   02....       LJMP    ?Subroutine5 & 0xFFFF
   1618          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ?Subroutine38 & 0xFFFF
   \                     ??CrossCallReturnLabel_45:
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine66_0
   \   000003                ; // Fall through to label ??Subroutine66_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine66_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1619          
   1620          /******************************************************************************
   1621           * @fn          ZDSecMgrTCExtAddrCheck
   1622           *
   1623           * @brief       Verifies if received ext. address matches TC ext. address.
   1624           *
   1625           * @param       extAddr - Extended address to be verified.
   1626           *
   1627           * @return      TRUE - extended address matches
   1628           *              FALSE - otherwise
   1629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1630          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   1631          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1632            uint8  lookup[Z_EXTADDR_LEN];
   1633            APSME_GetRequest( apsTrustCenterAddress, 0, lookup );
   \   00000E                ; Setup parameters for call to function APSME_GetRequest
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   7A00         MOV     R2,#0x0
   \   000014   7B00         MOV     R3,#0x0
   \   000016   79AB         MOV     R1,#-0x55
   \   000018   12....       LCALL   `??APSME_GetRequest::?relay`; Banked call to: APSME_GetRequest
   1634            return osal_ExtAddrEqual( extAddr, lookup );
   \   00001B                ; Setup parameters for call to function sAddrExtCmp
   \   00001B   AC..         MOV     R4,?XSP + 0
   \   00001D   AD..         MOV     R5,?XSP + 1
   \   00001F   EE           MOV     A,R6
   \   000020   FA           MOV     R2,A
   \   000021   EF           MOV     A,R7
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   `??sAddrExtCmp::?relay`; Banked call to: sAddrExtCmp
   \   000026                REQUIRE ?Subroutine7
   \   000026                ; // Fall through to label ?Subroutine7
   1635          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   7408         MOV     A,#0x8
   \   000002   02....       LJMP    ??Subroutine57_0 & 0xFFFF
   1636          
   1637          /******************************************************************************
   1638           * @fn          ZDSecMgrTCDataLoad
   1639           *
   1640           * @brief       Stores the address of TC into address manager.
   1641           *
   1642           * @param       extAddr - Extended address to be verified.
   1643           *
   1644           * @return      none
   1645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1646          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   1647          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1648            uint16 ami;
   1649            AddrMgrEntry_t entry;
   1650          
   1651            // lookup using TC short address
   1652            entry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   F0           MOVX    @DPTR,A
   1653            osal_cpyExtAddr( entry.extAddr, extAddr );
   \   000015                ; Setup parameters for call to function sAddrExtCpy
   \   000015   EE           MOV     A,R6
   \   000016   FC           MOV     R4,A
   \   000017   EF           MOV     A,R7
   \   000018   FD           MOV     R5,A
   \   000019   7405         MOV     A,#0x5
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   AA82         MOV     R2,DPL
   \   000020   AB83         MOV     R3,DPH
   \   000022   12....       LCALL   `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
   1654          
   1655            // Verify if TC address has been added to Address Manager
   1656            if ( !APSME_IsDistributedSecurity() && ( AddrMgrEntryLookupExt( &entry ) != TRUE ) )
   \   000025                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000025   12....       LCALL   `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   000028   E9           MOV     A,R1
   \   000029   702A         JNZ     ??ZDSecMgrTCDataLoad_0
   \   00002B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP101_8
   \   000030   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   000033   E9           MOV     A,R1
   \   000034   6401         XRL     A,#0x1
   \   000036   601D         JZ      ??ZDSecMgrTCDataLoad_0
   1657            {
   1658              ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami );
   \   000038                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000038   A8..         MOV     R0,?XSP + 0
   \   00003A   A9..         MOV     R1,?XSP + 1
   \   00003C   88..         MOV     ?V0,R0
   \   00003E   89..         MOV     ?V1,R1
   \   000040   78..         MOV     R0,#?V0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   EE           MOV     A,R6
   \   000046   FC           MOV     R4,A
   \   000047   EF           MOV     A,R7
   \   000048   FD           MOV     R5,A
   \   000049   7A00         MOV     R2,#0x0
   \   00004B   7B00         MOV     R3,#0x0
   \   00004D   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000050   7402         MOV     A,#0x2
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   1659            }
   1660          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000055   740F         MOV     A,#0xf
   \   000057   02....       LJMP    ??Subroutine53_0 & 0xFFFF
   1661          
   1662          /******************************************************************************
   1663           * @fn          ZDSecMgrTransportKeyInd
   1664           *
   1665           * @brief       Process the ZDO_TransportKeyInd_t message.
   1666           *
   1667           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   1668           *
   1669           * @return      none
   1670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1671          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   1672          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1673            uint8 index;
   1674            uint8 zgPreConfigKey[SEC_KEY_LEN];
   1675          
   1676            ZDSecMgrUpdateTCAddress( ind->srcExtAddr );
   \   00000E   EE           MOV     A,R6
   \   00000F   2416         ADD     A,#0x16
   \   000011   F5..         MOV     ?V0,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F5..         MOV     ?V1,A
   \   000017                ; Setup parameters for call to function ZDSecMgrUpdateTCAddress
   \   000017   AA..         MOV     R2,?V0
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   `??ZDSecMgrUpdateTCAddress::?relay`; Banked call to: ZDSecMgrUpdateTCAddress
   1677            // check for distributed security
   1678            if ( ( ZG_BUILD_RTR_TYPE ) && osal_isbufset( ind->srcExtAddr, 0xFF, Z_EXTADDR_LEN ) )
   \   00001D                ; Setup parameters for call to function osal_isbufset
   \   00001D   7C08         MOV     R4,#0x8
   \   00001F   79FF         MOV     R1,#-0x1
   \   000021   AA..         MOV     R2,?V0
   \   000023   AB..         MOV     R3,?V1
   \   000025   12....       LCALL   `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   000028   E9           MOV     A,R1
   \   000029   6006         JZ      ??ZDSecMgrTransportKeyInd_0
   1679            {
   1680              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00002B   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00002E   7401         MOV     A,#0x1
   \   000030   F0           MOVX    @DPTR,A
   1681            }
   1682          
   1683            // load Trust Center data if needed
   1684            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000031                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000031   EE           MOV     A,R6
   \   000032   2416         ADD     A,#0x16
   \   000034   FA           MOV     R2,A
   \   000035   E4           CLR     A
   \   000036   3F           ADDC    A,R7
   \   000037   FB           MOV     R3,A
   \   000038   12....       LCALL   `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   1685          
   1686            if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   1687                 ( ind->keyType == 6            ) )
   \   00003B   8E82         MOV     DPL,R6
   \   00003D   8F83         MOV     DPH,R7
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   6401         XRL     A,#0x1
   \   000046   600D         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000048   8E82         MOV     DPL,R6
   \   00004A   8F83         MOV     DPH,R7
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   E0           MOVX    A,@DPTR
   \   000051   6406         XRL     A,#0x6
   \   000053   7077         JNZ     ??ZDSecMgrTransportKeyInd_2
   1688            {
   1689              // check for dummy NWK key (all zeros)
   1690              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000055   7A00         MOV     R2,#0x0
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000057   EA           MOV     A,R2
   \   000058   F8           MOV     R0,A
   \   000059   EE           MOV     A,R6
   \   00005A   28           ADD     A,R0
   \   00005B   F582         MOV     DPL,A
   \   00005D   E4           CLR     A
   \   00005E   3F           ADDC    A,R7
   \   00005F   F583         MOV     DPH,A
   \   000061   A3           INC     DPTR
   \   000062   A3           INC     DPTR
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   E0           MOVX    A,@DPTR
   \   000068   7007         JNZ     ??ZDSecMgrTransportKeyInd_4
   1691                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   1692                    index++ );
   \   00006A   0A           INC     R2
   \   00006B   EA           MOV     A,R2
   \   00006C   C3           CLR     C
   \   00006D   9410         SUBB    A,#0x10
   \   00006F   40E6         JC      ??ZDSecMgrTransportKeyInd_3
   1693          
   1694              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000071   7410         MOV     A,#0x10
   \   000073   6A           XRL     A,R2
   \   000074   702E         JNZ     ??ZDSecMgrTransportKeyInd_5
   1695              {
   1696                // load preconfigured key - once!!
   1697                if ( !_NIB.nwkKeyLoaded )
   \   000076   90....       MOV     DPTR,#_NIB + 61
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   704D         JNZ     ??ZDSecMgrTransportKeyInd_6
   1698                {
   1699                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   00007C                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   00007C   AC..         MOV     R4,?XSP + 0
   \   00007E   AD..         MOV     R5,?XSP + 1
   \   000080   7A62         MOV     R2,#0x62
   \   000082   7B00         MOV     R3,#0x0
   \   000084   12....       LCALL   `??ZDSecMgrReadKeyFromNv::?relay`; Banked call to: ZDSecMgrReadKeyFromNv
   1700                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000087                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000087   7900         MOV     R1,#0x0
   \   000089   AA..         MOV     R2,?XSP + 0
   \   00008B   AB..         MOV     R3,?XSP + 1
   \   00008D   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   1701                  SSP_SwitchNwkKey( 0 );
   \   000090                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000090   7900         MOV     R1,#0x0
   \   000092   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1702          
   1703                  // clear local copy of key
   1704                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   000095                ; Setup parameters for call to function osal_memset
   \   000095   7C10         MOV     R4,#0x10
   \   000097   7D00         MOV     R5,#0x0
   \   000099   7900         MOV     R1,#0x0
   \   00009B   AA..         MOV     R2,?XSP + 0
   \   00009D   AB..         MOV     R3,?XSP + 1
   \   00009F   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   \   0000A2   8025         SJMP    ??ZDSecMgrTransportKeyInd_6
   1705                }
   1706              }
   1707              else
   1708              {
   1709                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000A4                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   0000A4   8E82         MOV     DPL,R6
   \   0000A6   8F83         MOV     DPH,R7
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   F9           MOV     R1,A
   \   0000AF   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_29:
   \   0000B2   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   1710                if ( !_NIB.nwkKeyLoaded )
   \   0000B5   90....       MOV     DPTR,#_NIB + 61
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   700E         JNZ     ??ZDSecMgrTransportKeyInd_6
   1711                {
   1712                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000BB                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000BB   8E82         MOV     DPL,R6
   \   0000BD   8F83         MOV     DPH,R7
   \   0000BF   A3           INC     DPTR
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   F9           MOV     R1,A
   \   0000C6   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1713                }
   1714              }
   1715          
   1716              // handle next step in authentication process
   1717              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   0000C9                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000C9   12....       LCALL   `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   1718            }
   1719            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   1720            {
   1721              // This should not happen because TCLK should not be Tx
   1722            }
   1723            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   1724            {
   1725              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1726              {
   1727                uint16           ami;
   1728                ZDSecMgrEntry_t* entry;
   1729          
   1730                // get the address index
   1731                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   1732                {
   1733                  // store new EXT address
   1734                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   1735                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   1736                }
   1737          
   1738                ZDSecMgrEntryLookupAMI( ami, &entry );
   1739          
   1740                if ( entry == NULL )
   1741                {
   1742                  // get new entry
   1743                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   1744                  {
   1745                    // finish setting up entry
   1746                    entry->ami = ami;
   1747                  }
   1748                }
   1749          
   1750                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   1751          
   1752          #if defined NV_RESTORE
   1753                ZDSecMgrWriteNV();  // Write the control record for the new established link key to NV.
   1754          #endif
   1755              }
   1756            }
   1757          }
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   0000CC   7410         MOV     A,#0x10
   \   0000CE   80..         SJMP    ??Subroutine53_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   EE           MOV     A,R6
   \   000001   2406         ADD     A,#0x6
   \   000003   FA           MOV     R2,A
   \   000004   E4           CLR     A
   \   000005   3F           ADDC    A,R7
   \   000006   FB           MOV     R3,A
   \   000007   22           RET
   1758          
   1759          /******************************************************************************
   1760           * @fn          ZDSecMgrUpdateDeviceInd
   1761           *
   1762           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   1763           *
   1764           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   1765           *
   1766           * @return      none
   1767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1768          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   1769          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1770            ZDSecMgrDevice_t device;
   1771          
   1772            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   E4           CLR     A
   \   00000F   3B           ADDC    A,R3
   \   000010   F583         MOV     DPH,A
   \   000012   12....       LCALL   ?Subroutine20 & 0xFFFF
   1773            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_104:
   \   000015   EA           MOV     A,R2
   \   000016   2404         ADD     A,#0x4
   \   000018   F8           MOV     R0,A
   \   000019   E4           CLR     A
   \   00001A   3B           ADDC    A,R3
   \   00001B   F9           MOV     R1,A
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   12....       LCALL   ?Subroutine13 & 0xFFFF
   1774            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_1:
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   1775            device.devStatus  = DEV_SEC_INIT_STATUS;
   \                     ??CrossCallReturnLabel_99:
   \   00002A   7407         MOV     A,#0x7
   \   00002C   12....       LCALL   ?XSTACK_DISP0_8
   \   00002F   7404         MOV     A,#0x4
   \   000031   F0           MOVX    @DPTR,A
   1776            device.secure     = FALSE;
   \   000032   7406         MOV     A,#0x6
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   E4           CLR     A
   \   000038   F0           MOVX    @DPTR,A
   1777          
   1778            // Trust Center should identify the type of JOIN/REJOIN and
   1779            // Transport the NWK key accordingly, it will only be transported for:
   1780            //              APSME_UD_STANDARD_UNSECURED_JOIN
   1781            //   OR         APSME_UD_STANDARD_TRUST_CENTER_REJOIN
   1782            if ( ind->status != APSME_UD_DEVICE_LEFT )
   \   000039   EA           MOV     A,R2
   \   00003A   240E         ADD     A,#0xe
   \   00003C   F582         MOV     DPL,A
   \   00003E   E4           CLR     A
   \   00003F   3B           ADDC    A,R3
   \   000040   F583         MOV     DPH,A
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6402         XRL     A,#0x2
   \   000045   601A         JZ      ??ZDSecMgrUpdateDeviceInd_0
   1783            {
   1784              if ( ind->status == APSME_UD_STANDARD_SECURED_REJOIN )
   \   000047   E0           MOVX    A,@DPTR
   \   000048   7010         JNZ     ??ZDSecMgrUpdateDeviceInd_1
   1785              {
   1786                device.devStatus &= ~DEV_SEC_INIT_STATUS;
   1787                device.devStatus |=  DEV_SEC_AUTH_STATUS;
   \   00004A   7407         MOV     A,#0x7
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   7408         MOV     A,#0x8
   \   000051   F0           MOVX    @DPTR,A
   1788                device.secure = TRUE;
   \   000052   7406         MOV     A,#0x6
   \   000054   12....       LCALL   ?XSTACK_DISP0_8
   \   000057   7401         MOV     A,#0x1
   \   000059   F0           MOVX    @DPTR,A
   1789              }
   1790          
   1791              ZDSecMgrDeviceJoin( &device );
   \                     ??ZDSecMgrUpdateDeviceInd_1:
   \   00005A                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   00005A   AA..         MOV     R2,?XSP + 0
   \   00005C   AB..         MOV     R3,?XSP + 1
   \   00005E   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   1792            }
   1793          }
   \                     ??ZDSecMgrUpdateDeviceInd_0:
   \   000061                REQUIRE ?Subroutine8
   \   000061                ; // Fall through to label ?Subroutine8

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7408         MOV     A,#0x8
   \   000002                REQUIRE ??Subroutine55_0
   \   000002                ; // Fall through to label ??Subroutine55_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine55_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   1794          
   1795          /******************************************************************************
   1796           * @fn          ZDSecMgrRemoveDeviceInd
   1797           *
   1798           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   1799           *
   1800           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   1801           *
   1802           * @return      none
   1803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1804          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   1805          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1806            ZDSecMgrDevice_t device;
   1807          
   1808            // only accept from Trust Center
   1809            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   12....       LCALL   ??Subroutine65_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   000017   7034         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   1810            {
   1811              // look up NWK address
   1812              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000019                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000019   AC..         MOV     R4,?XSP + 0
   \   00001B   AD..         MOV     R5,?XSP + 1
   \   00001D   EE           MOV     A,R6
   \   00001E   2404         ADD     A,#0x4
   \   000020   FA           MOV     R2,A
   \   000021   E4           CLR     A
   \   000022   3F           ADDC    A,R7
   \   000023   FB           MOV     R3,A
   \   000024   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   000027   E9           MOV     A,R1
   \   000028   6401         XRL     A,#0x1
   \   00002A   7021         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   1813              {
   1814                device.parentAddr = NLME_GetShortAddr();
   \   00002C                ; Setup parameters for call to function NLME_GetShortAddr
   \   00002C   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ?Subroutine39 & 0xFFFF
   1815                device.extAddr    = ind->childExtAddr;
   \                     ??CrossCallReturnLabel_48:
   \   000037   EE           MOV     A,R6
   \   000038   2404         ADD     A,#0x4
   \   00003A   F8           MOV     R0,A
   \   00003B   E4           CLR     A
   \   00003C   3F           ADDC    A,R7
   \   00003D   F9           MOV     R1,A
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E8           MOV     A,R0
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   E9           MOV     A,R1
   \   000047   12....       LCALL   ??Subroutine56_0 & 0xFFFF
   1816          
   1817                // remove device
   1818                ZDSecMgrDeviceRemove( &device );
   1819              }
   1820            }
   \                     ??CrossCallReturnLabel_110:
   \   00004A   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   1821          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   00004D   02....       LJMP    ?Subroutine7 & 0xFFFF
   1822          
   1823          /******************************************************************************
   1824           * @fn          ZDSecMgrRequestKeyInd
   1825           *
   1826           * @brief       Process the ZDO_RequestKeyInd_t message.
   1827           *
   1828           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   1829           *
   1830           * @return      none
   1831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1832          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   1833          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1834            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   6010         JZ      ??ZDSecMgrRequestKeyInd_0
   1835            {
   1836            }
   1837            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000011   8A82         MOV     DPL,R2
   \   000013   8B83         MOV     DPH,R3
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   6402         XRL     A,#0x2
   \   00001C   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   1838            {
   1839              ZDSecMgrAppKeyReq( ind );
   \   00001E                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   00001E   12....       LCALL   `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   1840            }
   1841            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   1842            {
   1843            }
   1844            //else ignore
   1845          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   000021   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   1846          
   1847          /******************************************************************************
   1848           * @fn          ZDSecMgrSwitchKeyInd
   1849           *
   1850           * @brief       Process the ZDO_SwitchKeyInd_t message.
   1851           *
   1852           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   1853           *
   1854           * @return      none
   1855           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1856          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   1857          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1858            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1859          
   1860            // Save if nv
   1861            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   1862          }
   \   000014   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   1863          
   1864          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1865          /******************************************************************************
   1866           * @fn          ZDSecMgrUpdateNwkKey
   1867           *
   1868           * @brief       Load a new NWK key and trigger a network update to the dstAddr.
   1869           *
   1870           * @param       key       - [in] new NWK key
   1871           * @param       keySeqNum - [in] new NWK key sequence number
   1872           *
   1873           * @return      ZStatus_t
   1874           */
   1875          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   1876          {
   1877            ZStatus_t               status;
   1878            APSME_TransportKeyReq_t req;
   1879          
   1880            // initialize common elements of local variables
   1881            req.keyType   = KEY_TYPE_NWK;
   1882          
   1883            req.dstAddr   = dstAddr;
   1884            req.keySeqNum = keySeqNum;
   1885            req.key       = key;
   1886            req.extAddr   = NULL;
   1887            req.nwkSecure = TRUE;
   1888            req.tunnel    = NULL;
   1889          
   1890            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1891            {
   1892              // Broadcast transport NWK key
   1893              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   1894                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   1895                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   1896              {
   1897                req.apsSecure = FALSE;
   1898                status = APSME_TransportKeyReq( &req );
   1899              }
   1900              else
   1901              {
   1902                AddrMgrEntry_t          addrEntry;
   1903          
   1904                addrEntry.user = ADDRMGR_USER_SECURITY;
   1905                addrEntry.nwkAddr = dstAddr;
   1906          
   1907                status = ZFailure;
   1908          
   1909                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   1910                {
   1911                  req.extAddr = addrEntry.extAddr;
   1912                  req.apsSecure = TRUE;
   1913                  status = APSME_TransportKeyReq( &req );
   1914                }
   1915              }
   1916            }
   1917            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1918            {
   1919              req.apsSecure = FALSE;
   1920              status = APSME_TransportKeyReq( &req );
   1921            }
   1922          
   1923            SSP_UpdateNwkKey( key, keySeqNum );
   1924          
   1925            // Save if nv
   1926            ZDApp_NVUpdate();
   1927          
   1928            return status;
   1929          }
   1930          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   1931          
   1932          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1933          /******************************************************************************
   1934           * @fn          ZDSecMgrSwitchNwkKey
   1935           *
   1936           * @brief       Causes the NWK key to switch via a network command to the dstAddr.
   1937           *
   1938           * @param       keySeqNum - [in] new NWK key sequence number
   1939           *
   1940           * @return      ZStatus_t
   1941           */
   1942          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   1943          {
   1944            ZStatus_t            status;
   1945            APSME_SwitchKeyReq_t req;
   1946          
   1947            // initialize common elements of local variables
   1948            req.dstAddr = dstAddr;
   1949            req.keySeqNum = keySeqNum;
   1950          
   1951            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1952            {
   1953              // Broadcast switch NWK key
   1954              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   1955                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   1956                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   1957              {
   1958                req.apsSecure = FALSE;
   1959                status = APSME_SwitchKeyReq( &req );
   1960              }
   1961              else
   1962              {
   1963                AddrMgrEntry_t          addrEntry;
   1964          
   1965                addrEntry.user = ADDRMGR_USER_SECURITY;
   1966                addrEntry.nwkAddr = dstAddr;
   1967          
   1968                status = ZFailure;
   1969          
   1970                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   1971                {
   1972                  req.dstAddr = addrEntry.nwkAddr;
   1973                  req.apsSecure = TRUE;
   1974                  status = APSME_SwitchKeyReq( &req );
   1975                }
   1976              }
   1977            }
   1978            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1979            {
   1980              req.apsSecure = FALSE;
   1981              status = APSME_SwitchKeyReq( &req );
   1982            }
   1983          
   1984            SSP_SwitchNwkKey( keySeqNum );
   1985          
   1986            // Save if nv
   1987            ZDApp_NVUpdate();
   1988          
   1989            return status;
   1990          }
   1991          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   1992          
   1993          /******************************************************************************
   1994           * @fn          ZDSecMgrRequestAppKey
   1995           *
   1996           * @brief       Request an application key with partner.
   1997           *
   1998           * @param       partExtAddr - [in] partner extended address
   1999           *
   2000           * @return      ZStatus_t
   2001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2002          ZStatus_t ZDSecMgrRequestAppKey( uint8 *partExtAddr )
   \                     ZDSecMgrRequestAppKey:
   2003          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2004            ZStatus_t status;
   2005            APSME_RequestKeyReq_t req;
   2006          
   2007            req.dstAddr = 0;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   2008            req.keyType = KEY_TYPE_APP_MASTER;
   \   000011   04           INC     A
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   7402         MOV     A,#0x2
   \   000017   F0           MOVX    @DPTR,A
   2009          
   2010            req.partExtAddr = partExtAddr;
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine14 & 0xFFFF
   2011            status = APSME_RequestKeyReq( &req );
   2012          
   2013            return status;
   \                     ??CrossCallReturnLabel_106:
   \   00001E   12....       LCALL   `??APSME_RequestKeyReq::?relay`; Banked call to: APSME_RequestKeyReq
   \   000021   7404         MOV     A,#0x4
   \   000023   02....       LJMP    ??Subroutine55_0 & 0xFFFF
   2014          }
   2015          
   2016          #if ( ZG_BUILD_JOINING_TYPE )
   2017          /******************************************************************************
   2018           * @fn          ZDSecMgrSetupPartner
   2019           *
   2020           * @brief       Setup for application key partner.
   2021           *
   2022           * @param       partNwkAddr - [in] partner network address
   2023           *
   2024           * @return      ZStatus_t
   2025           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2026          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   2027          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   2028            AddrMgrEntry_t entry;
   2029            ZStatus_t      status;
   2030          
   2031            status = ZFailure;
   \   000012   75..01       MOV     ?V0,#0x1
   2032          
   2033            // update the address manager
   2034            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   85..82       MOV     DPL,?XSP + 0
   \   000018   85..83       MOV     DPH,?XSP + 1
   \   00001B   7402         MOV     A,#0x2
   \   00001D   F0           MOVX    @DPTR,A
   2035            entry.nwkAddr = partNwkAddr;
   \   00001E   14           DEC     A
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   12....       LCALL   ?Subroutine17 & 0xFFFF
   2036            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \                     ??CrossCallReturnLabel_8:
   \   000025   12....       LCALL   ?XSTACK_DISP0_8
   \   000028   AA82         MOV     R2,DPL
   \   00002A   AB83         MOV     R3,DPH
   \   00002C   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
   2037          
   2038            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00002F                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00002F   AA..         MOV     R2,?XSP + 0
   \   000031   AB..         MOV     R3,?XSP + 1
   \   000033   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   000036   E9           MOV     A,R1
   \   000037   6401         XRL     A,#0x1
   \   000039   7038         JNZ     ??ZDSecMgrSetupPartner_0
   2039            {
   2040              status = ZSuccess;
   \   00003B   75..00       MOV     ?V0,#0x0
   2041          
   2042              // check for address discovery
   2043              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   00003E   74FE         MOV     A,#-0x2
   \   000040   65..         XRL     A,?V2
   \   000042   7004         JNZ     ??ZDSecMgrSetupPartner_1
   \   000044   74FF         MOV     A,#-0x1
   \   000046   65..         XRL     A,?V3
   \                     ??ZDSecMgrSetupPartner_1:
   \   000048   700F         JNZ     ??ZDSecMgrSetupPartner_2
   2044              {
   2045                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00004A                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   00004A   7D00         MOV     R5,#0x0
   \   00004C   7C00         MOV     R4,#0x0
   \   00004E   7900         MOV     R1,#0x0
   \   000050   EE           MOV     A,R6
   \   000051   FA           MOV     R2,A
   \   000052   EF           MOV     A,R7
   \   000053   FB           MOV     R3,A
   \   000054   12....       LCALL   `??ZDP_NwkAddrReq::?relay`; Banked call to: ZDP_NwkAddrReq
   \   000057   8017         SJMP    ??ZDSecMgrSetupPartner_3
   2046              }
   2047              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   000059                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   000059   EE           MOV     A,R6
   \   00005A   FA           MOV     R2,A
   \   00005B   EF           MOV     A,R7
   \   00005C   FB           MOV     R3,A
   \   00005D   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000060   E9           MOV     A,R1
   \   000061   7010         JNZ     ??ZDSecMgrSetupPartner_0
   2048              {
   2049                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000063                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000063   7D00         MOV     R5,#0x0
   \   000065   7C00         MOV     R4,#0x0
   \   000067   7900         MOV     R1,#0x0
   \   000069   AA..         MOV     R2,?V2
   \   00006B   AB..         MOV     R3,?V3
   \   00006D   12....       LCALL   `??ZDP_IEEEAddrReq::?relay`; Banked call to: ZDP_IEEEAddrReq
   \                     ??ZDSecMgrSetupPartner_3:
   \   000070   E9           MOV     A,R1
   \   000071   F5..         MOV     ?V0,A
   2050              }
   2051            }
   2052          
   2053            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000073   A9..         MOV     R1,?V0
   \   000075   740D         MOV     A,#0xd
   \   000077   02....       LJMP    ?Subroutine5 & 0xFFFF
   2054          }
   2055          #endif // ( ZG_BUILD_JOINING_TYPE )
   2056          
   2057          #if ( ZG_BUILD_COORDINATOR_TYPE )
   2058          /******************************************************************************
   2059           * @fn          ZDSecMgrAppKeyTypeSet
   2060           *
   2061           * @brief       Set application key type.
   2062           *
   2063           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   2064           *                                                   KEY_TYPE_APP_LINK@3
   2065           *
   2066           * @return      ZStatus_t
   2067           */
   2068          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   2069          {
   2070            if ( keyType == KEY_TYPE_APP_LINK )
   2071            {
   2072              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   2073            }
   2074            else
   2075            {
   2076              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   2077            }
   2078          
   2079            return ZSuccess;
   2080          }
   2081          #endif
   2082          
   2083          /******************************************************************************
   2084           * ZigBee Device Security Manager - Stub Implementations
   2085           */
   2086          
   2087          
   2088          /******************************************************************************
   2089           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   2090           *
   2091           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   2092           *
   2093           * @param       extAddr - [in] EXT address
   2094           * @param       data    - [in] APSME_LinkKeyData_t
   2095           *
   2096           * @return      ZStatus_t
   2097           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2098          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   2099          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2100            ZStatus_t status;
   2101            ZDSecMgrEntry_t* entry;
   2102            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2103            uint16 Index;
   2104          
   2105            // lookup entry index for specified EXT address
   2106            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP100_8
   \   000013   88..         MOV     ?V0,R0
   \   000015   89..         MOV     ?V1,R1
   \   000017   78..         MOV     R0,#?V0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   7402         MOV     A,#0x2
   \   00001E   12....       LCALL   ?XSTACK_DISP102_8
   \   000021   12....       LCALL   `??ZDSecMgrEntryLookupExtGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupExtGetIndex
   \   000024   7402         MOV     A,#0x2
   \   000026   12....       LCALL   ?DEALLOC_XSTACK8
   \   000029   E9           MOV     A,R1
   \   00002A   F5..         MOV     ?V0,A
   2107          
   2108            if ( status == ZSuccess )
   \   00002C   6003         JZ      $+5
   \   00002E   02....       LJMP    ??CrossCallReturnLabel_137 & 0xFFFF
   2109            {
   2110              // point to NV item
   2111              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E0           MOVX    A,@DPTR
   \   000037   2401         ADD     A,#0x1
   \   000039   F8           MOV     R0,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   3402         ADDC    A,#0x2
   \   00003E   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_132:
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   2112          
   2113              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??CrossCallReturnLabel_100:
   \   000046                ; Setup parameters for call to function osal_mem_alloc
   \   000046   7A18         MOV     R2,#0x18
   \   000048   7B00         MOV     R3,#0x0
   \   00004A   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00004D   8A..         MOV     ?V2,R2
   \   00004F   8B..         MOV     ?V3,R3
   2114          
   2115              if (pApsLinkKey != NULL)
   \   000051   EA           MOV     A,R2
   \   000052   45..         ORL     A,?V3
   \   000054   7003         JNZ     $+5
   \   000056   02....       LJMP    ??CrossCallReturnLabel_137 & 0xFFFF
   2116              {
   2117                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2118                osal_nv_read( entry->keyNvId, 0,
   2119                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000059                ; Setup parameters for call to function osal_nv_read
   \   000059   78..         MOV     R0,#?V2
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   75..18       MOV     ?V4,#0x18
   \   000061   75..00       MOV     ?V5,#0x0
   \   000064   78..         MOV     R0,#?V4
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   7C00         MOV     R4,#0x0
   \   00006B   7D00         MOV     R5,#0x0
   \   00006D   7404         MOV     A,#0x4
   \   00006F   12....       LCALL   ?XSTACK_DISP0_8
   \   000072   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000075   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000078   7404         MOV     A,#0x4
   \   00007A   12....       LCALL   ?DEALLOC_XSTACK8
   2120          
   2121                // set new values of the key
   2122                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   00007D                ; Setup parameters for call to function osal_memcpy
   \   00007D   8E..         MOV     ?V4,R6
   \   00007F   8F..         MOV     ?V5,R7
   \   000081   75..00       MOV     ?V6,#0x0
   \   000084   78..         MOV     R0,#?V4
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000089   7C10         MOV     R4,#0x10
   \   00008B   7D00         MOV     R5,#0x0
   \   00008D   AA..         MOV     R2,?V2
   \   00008F   AB..         MOV     R3,?V3
   \   000091   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000094   7403         MOV     A,#0x3
   \   000096   12....       LCALL   ?DEALLOC_XSTACK8
   2123                pApsLinkKey->rxFrmCntr = 0;
   \   000099   E5..         MOV     A,?V2
   \   00009B   2414         ADD     A,#0x14
   \   00009D   12....       LCALL   ?Subroutine11 & 0xFFFF
   2124                pApsLinkKey->txFrmCntr = 0;
   \                     ??CrossCallReturnLabel_138:
   \   0000A0   E5..         MOV     A,?V2
   \   0000A2   2410         ADD     A,#0x10
   \   0000A4   12....       LCALL   ?Subroutine11 & 0xFFFF
   2125          
   2126                osal_nv_write( entry->keyNvId, 0,
   2127                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \                     ??CrossCallReturnLabel_139:
   \   0000A7                ; Setup parameters for call to function osal_nv_write
   \   0000A7   78..         MOV     R0,#?V2
   \   0000A9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AC   75..18       MOV     ?V4,#0x18
   \   0000AF   75..00       MOV     ?V5,#0x0
   \   0000B2   78..         MOV     R0,#?V4
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   7C00         MOV     R4,#0x0
   \   0000B9   7D00         MOV     R5,#0x0
   \   0000BB   7404         MOV     A,#0x4
   \   0000BD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C0   12....       LCALL   ?Subroutine22 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   0000C3   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000C6   7404         MOV     A,#0x4
   \   0000C8   12....       LCALL   ?DEALLOC_XSTACK8
   2128          
   2129                // clear copy of key in RAM
   2130                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   0000CB                ; Setup parameters for call to function osal_memset
   \   0000CB   7C18         MOV     R4,#0x18
   \   0000CD   7D00         MOV     R5,#0x0
   \   0000CF   7900         MOV     R1,#0x0
   \   0000D1   AA..         MOV     R2,?V2
   \   0000D3   AB..         MOV     R3,?V3
   \   0000D5   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2131          
   2132                osal_mem_free(pApsLinkKey);
   \   0000D8                ; Setup parameters for call to function osal_mem_free
   \   0000D8   AA..         MOV     R2,?V2
   \   0000DA   AB..         MOV     R3,?V3
   \   0000DC   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   \   0000DF   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_115:
   \   0000E2   12....       LCALL   ??Subroutine60_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   0000E5   E8           MOV     A,R0
   \   0000E6   75F009       MOV     B,#0x9
   \   0000E9   A4           MUL     AB
   \   0000EA   F8           MOV     R0,A
   \   0000EB   AAF0         MOV     R2,B
   \   0000ED   75F009       MOV     B,#0x9
   \   0000F0   E9           MOV     A,R1
   \   0000F1   A4           MUL     AB
   \   0000F2   2A           ADD     A,R2
   \   0000F3   F9           MOV     R1,A
   \   0000F4   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   0000F6   28           ADD     A,R0
   \   0000F7   FA           MOV     R2,A
   \   0000F8   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   0000FA   39           ADDC    A,R1
   \   0000FB   FB           MOV     R3,A
   \   0000FC   EA           MOV     A,R2
   \   0000FD   24F7         ADD     A,#-0x9
   \   0000FF   F582         MOV     DPL,A
   \   000101   EB           MOV     A,R3
   \   000102   34ED         ADDC    A,#-0x13
   \   000104   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   2133          
   2134                // set initial values for counters in RAM
   2135                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   2136                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_136:
   \   000107   EA           MOV     A,R2
   \   000108   24FB         ADD     A,#-0x5
   \   00010A   F582         MOV     DPL,A
   \   00010C   EB           MOV     A,R3
   \   00010D   34ED         ADDC    A,#-0x13
   \   00010F   12....       LCALL   ??Subroutine63_0 & 0xFFFF
   2137              }
   2138            }
   2139          
   2140            return status;
   \                     ??CrossCallReturnLabel_137:
   \   000112   A9..         MOV     R1,?V0
   \   000114   7404         MOV     A,#0x4
   \   000116   02....       LJMP    ?Subroutine4 & 0xFFFF
   2141          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine59_0
   \   000006                ; // Fall through to label ??Subroutine59_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   F9           MOV     R1,A
   \   000001   85..82       MOV     DPL,?XSP + 0
   \   000004   85..83       MOV     DPH,?XSP + 1
   \   000007                REQUIRE ??Subroutine62_0
   \   000007                ; // Fall through to label ??Subroutine62_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   F582         MOV     DPL,A
   \   000002   E4           CLR     A
   \   000003   35..         ADDC    A,?V3
   \   000005                REQUIRE ??Subroutine63_0
   \   000005                ; // Fall through to label ??Subroutine63_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine63_0:
   \   000000   F583         MOV     DPH,A
   \   000002                REQUIRE ??Subroutine64_0
   \   000002                ; // Fall through to label ??Subroutine64_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine64_0:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   F0           MOVX    @DPTR,A
   \   000008   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_117:
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FA           MOV     R2,A
   \   000007   A3           INC     DPTR
   \   000008   E0           MOVX    A,@DPTR
   \   000009   FB           MOV     R3,A
   \   00000A   22           RET
   2142          
   2143          /******************************************************************************
   2144           * @fn          ZDSecMgrAuthenticationSet
   2145           *
   2146           * @brief       Mark the specific device as authenticated or not
   2147           *
   2148           * @param       extAddr - [in] EXT address
   2149           * @param       option  - [in] authenticated or not
   2150           *
   2151           * @return      ZStatus_t
   2152           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2153          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   2154          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   2155            ZStatus_t        status;
   2156            ZDSecMgrEntry_t* entry;
   2157          
   2158          
   2159            // lookup entry index for specified EXT address
   2160            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   AC..         MOV     R4,?XSP + 0
   \   00000E   AD..         MOV     R5,?XSP + 1
   \   000010   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000013   E9           MOV     A,R1
   \   000014   F9           MOV     R1,A
   2161          
   2162            if ( status == ZSuccess )
   \   000015   7009         JNZ     ??ZDSecMgrAuthenticationSet_0
   2163            {
   2164              entry->authenticateOption = option;
   \   000017   12....       LCALL   ?Subroutine28 & 0xFFFF
   2165            }
   \                     ??CrossCallReturnLabel_116:
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   EE           MOV     A,R6
   \   00001F   F0           MOVX    @DPTR,A
   2166          
   2167            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000020   02....       LJMP    ?Subroutine6 & 0xFFFF
   2168          }
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrAuthenticationCheck
   2172           *
   2173           * @brief       Check if the specific device has been authenticated or not
   2174           *              For non-trust center device, always return TRUE
   2175           *
   2176           * @param       shortAddr - [in] short address
   2177           *
   2178           * @return      TRUE @ authenticated with CBKE
   2179           *              FALSE @ not authenticated
   2180           */
   2181          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2182          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   2183          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2184          #if defined (TC_LINKKEY_JOIN)
   2185          
   2186            ZDSecMgrEntry_t* entry;
   2187            uint8 extAddr[Z_EXTADDR_LEN];
   2188          
   2189            // If the local device is not the trust center, always return TRUE
   2190            APSME_GetRequest( apsTrustCenterAddress, 0, extAddr );
   2191            if ( ! osal_ExtAddrEqual( extAddr , NLME_GetExtAddr() ) )
   2192            {
   2193              return TRUE;
   2194            }
   2195            // Otherwise, check the authentication option
   2196            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   2197            {
   2198              // lookup entry index for specified EXT address
   2199              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   2200              {
   2201                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   2202                {
   2203                  return TRUE;
   2204                }
   2205                else
   2206                {
   2207                  return FALSE;
   2208                }
   2209              }
   2210              else
   2211              {
   2212                // it may have been secured with TCLK only
   2213                uint16    ami;
   2214          
   2215                // lookup address index in address manager
   2216                if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   2217                {
   2218                  return TRUE;
   2219                }
   2220              }
   2221            }
   2222            return FALSE;
   2223          
   2224          #else
   2225            (void)shortAddr;  // Intentionally unreferenced parameter
   2226          
   2227            // For non AMI/SE Profile, perform no check and always return TRUE.
   2228            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   2229          
   2230          #endif // TC_LINKKEY_JOIN
   2231          }
   2232          
   2233          /******************************************************************************
   2234           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   2235           *
   2236           * @brief       Get Key NV ID for specified NWK address.
   2237           *
   2238           * @param       extAddr - [in] EXT address
   2239           * @param       keyNvId - [out] NV ID
   2240           *
   2241           * @return      ZStatus_t
   2242           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2243          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   2244          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2245            ZStatus_t status;
   2246            ZDSecMgrEntry_t* entry;
   2247          
   2248            // lookup entry index for specified NWK address
   2249            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000015   E9           MOV     A,R1
   \   000016   F9           MOV     R1,A
   2250          
   2251            if ( status == ZSuccess )
   \   000017   7013         JNZ     ??APSME_LinkKeyNVIdGet_0
   2252            {
   2253              // return the index to the NV table
   2254              *pKeyNvId = entry->keyNvId;
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   12....       LCALL   ?Subroutine22 & 0xFFFF
   2255            }
   \                     ??CrossCallReturnLabel_17:
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   EA           MOV     A,R2
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   EB           MOV     A,R3
   \   00002A   8007         SJMP    ??APSME_LinkKeyNVIdGet_1
   2256            else
   2257            {
   2258              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   E4           CLR     A
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000033   F0           MOVX    @DPTR,A
   2259            }
   2260          
   2261            return status;
   \   000034   02....       LJMP    ?Subroutine6 & 0xFFFF
   2262          }
   2263          
   2264          /******************************************************************************
   2265           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   2266           *
   2267           * @brief       Verifies if Link Key in NV has been set.
   2268           *
   2269           * @param       extAddr - [in] EXT address
   2270           *
   2271           * @return      TRUE - Link Key has been established
   2272           *              FALSE - Link Key in NV has default value.
   2273           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2274          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   2275          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2276            APSME_LinkKeyData_t *pKeyData;
   2277            uint16 apsLinkKeyNvId;
   2278            uint8 nullKey[SEC_KEY_LEN];
   2279            uint8 status = FALSE;
   \   00000E   75..00       MOV     ?V0,#0x0
   2280          
   2281            // initialize default vealue to compare to
   2282            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000011                ; Setup parameters for call to function osal_memset
   \   000011   7C10         MOV     R4,#0x10
   \   000013   7D00         MOV     R5,#0x0
   \   000015   7900         MOV     R1,#0x0
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP101_8
   \   00001C   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2283          
   2284            // check for APS link NV ID
   2285            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   00001F                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   00001F   AC..         MOV     R4,?XSP + 0
   \   000021   AD..         MOV     R5,?XSP + 1
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   `??APSME_LinkKeyNVIdGet::?relay`; Banked call to: APSME_LinkKeyNVIdGet
   2286          
   2287            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   00002A   85..82       MOV     DPL,?XSP + 0
   \   00002D   85..83       MOV     DPH,?XSP + 1
   \   000030   12....       LCALL   ??Subroutine65_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_142:
   \   000033   607A         JZ      ??APSME_IsLinkKeyValid_0
   2288            {
   2289              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000035                ; Setup parameters for call to function osal_mem_alloc
   \   000035   7A18         MOV     R2,#0x18
   \   000037   7B00         MOV     R3,#0x0
   \   000039   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00003C   8A..         MOV     ?V2,R2
   \   00003E   8B..         MOV     ?V3,R3
   2290          
   2291              if (pKeyData != NULL)
   \   000040   EA           MOV     A,R2
   \   000041   45..         ORL     A,?V3
   \   000043   606A         JZ      ??APSME_IsLinkKeyValid_0
   2292              {
   2293                // retrieve key from NV
   2294                if ( osal_nv_read( apsLinkKeyNvId, 0,
   2295                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   000045                ; Setup parameters for call to function osal_nv_read
   \   000045   78..         MOV     R0,#?V2
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   75..18       MOV     ?V4,#0x18
   \   00004D   75..00       MOV     ?V5,#0x0
   \   000050   78..         MOV     R0,#?V4
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   7C00         MOV     R4,#0x0
   \   000057   7D00         MOV     R5,#0x0
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000061   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000064   7404         MOV     A,#0x4
   \   000066   12....       LCALL   ?DEALLOC_XSTACK8
   \   000069   E9           MOV     A,R1
   \   00006A   702F         JNZ     ??APSME_IsLinkKeyValid_1
   2296                {
   2297                  // if stored key is different than default value, then a key has been established
   2298                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   00006C                ; Setup parameters for call to function osal_memcmp
   \   00006C   7402         MOV     A,#0x2
   \   00006E   12....       LCALL   ?XSTACK_DISP100_8
   \   000071   88..         MOV     ?V4,R0
   \   000073   89..         MOV     ?V5,R1
   \   000075   75..00       MOV     ?V6,#0x0
   \   000078   78..         MOV     R0,#?V4
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00007D   7C10         MOV     R4,#0x10
   \   00007F   7D00         MOV     R5,#0x0
   \   000081   85..82       MOV     DPL,?V2
   \   000084   85..83       MOV     DPH,?V3
   \   000087   A982         MOV     R1,DPL
   \   000089   AA83         MOV     R2,DPH
   \   00008B   7B00         MOV     R3,#0x0
   \   00008D   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   000090   7403         MOV     A,#0x3
   \   000092   12....       LCALL   ?DEALLOC_XSTACK8
   \   000095   E9           MOV     A,R1
   \   000096   7003         JNZ     ??APSME_IsLinkKeyValid_1
   2299                  {
   2300                    status = TRUE;
   \   000098   75..01       MOV     ?V0,#0x1
   2301                  }
   2302                }
   2303          
   2304                // clear copy of key in RAM
   2305                osal_memset(pKeyData, 0x00, sizeof(APSME_LinkKeyData_t));
   \                     ??APSME_IsLinkKeyValid_1:
   \   00009B                ; Setup parameters for call to function osal_memset
   \   00009B   7C18         MOV     R4,#0x18
   \   00009D   7D00         MOV     R5,#0x0
   \   00009F   7900         MOV     R1,#0x0
   \   0000A1   AA..         MOV     R2,?V2
   \   0000A3   AB..         MOV     R3,?V3
   \   0000A5   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2306          
   2307                osal_mem_free(pKeyData);
   \   0000A8                ; Setup parameters for call to function osal_mem_free
   \   0000A8   AA..         MOV     R2,?V2
   \   0000AA   AB..         MOV     R3,?V3
   \   0000AC   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2308              }
   2309            }
   2310          
   2311            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   0000AF   A9..         MOV     R1,?V0
   \   0000B1   7412         MOV     A,#0x12
   \   0000B3   02....       LJMP    ?Subroutine4 & 0xFFFF
   2312          }
   2313          
   2314          /******************************************************************************
   2315           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   2316           *
   2317           * @brief       Verify and process key transportation to child.
   2318           *
   2319           * @param       ind - [in] APSME_TransportKeyInd_t
   2320           *
   2321           * @return      uint8 - success(TRUE:FALSE)
   2322           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2323          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   2324          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   2325            // verify from Trust Center
   2326            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   12....       LCALL   ??Subroutine65_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   00000C   702B         JNZ     ??APSME_KeyFwdToChild_0
   2327            {
   2328              // check for initial NWK key
   2329              if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   2330                   ( ind->keyType == 6            ) )
   \   00000E   8A82         MOV     DPL,R2
   \   000010   8B83         MOV     DPH,R3
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   6401         XRL     A,#0x1
   \   000017   600B         JZ      ??APSME_KeyFwdToChild_1
   \   000019   8A82         MOV     DPL,R2
   \   00001B   8B83         MOV     DPH,R3
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   6406         XRL     A,#0x6
   \   000022   7011         JNZ     ??APSME_KeyFwdToChild_2
   2331              {
   2332                // set association status to authenticated
   2333                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   000024                ; Setup parameters for call to function AssocGetWithExt
   \   000024   8A82         MOV     DPL,R2
   \   000026   8B83         MOV     DPH,R3
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   A3           INC     DPTR
   \   00002B   A3           INC     DPTR
   \   00002C   12....       LCALL   ??Subroutine49_0 & 0xFFFF
   2334              }
   \                     ??CrossCallReturnLabel_84:
   \   00002F   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000032                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000032   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2335          
   2336              return TRUE;
   \                     ??APSME_KeyFwdToChild_2:
   \   000035   7901         MOV     R1,#0x1
   \   000037   8002         SJMP    ??APSME_KeyFwdToChild_3
   2337            }
   2338          
   2339            return FALSE;
   \                     ??APSME_KeyFwdToChild_0:
   \   000039   7900         MOV     R1,#0x0
   \                     ??APSME_KeyFwdToChild_3:
   \   00003B   02....       LJMP    ??Subroutine54_0 & 0xFFFF
   2340          }
   2341          
   2342          /******************************************************************************
   2343           * @fn          ZDSecMgrAddLinkKey
   2344           *
   2345           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   2346           *              as authenticated in the authenticateOption. Note that this function
   2347           *              is hardwared to CBKE right now.
   2348           *
   2349           * @param       shortAddr - short address of the partner device
   2350           * @param       extAddr - extended address of the partner device
   2351           * @param       key - link key
   2352           *
   2353           * @return      ZStatus_t
   2354           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2355          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   2356          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   2357            uint16           ami;
   2358            ZDSecMgrEntry_t* entry;
   2359          
   2360            /* Store the device address in the addr manager */
   2361            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00000E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP100_8
   \   000013   88..         MOV     ?V0,R0
   \   000015   89..         MOV     ?V1,R1
   \   000017   78..         MOV     R0,#?V0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?DEALLOC_XSTACK8
   \   000024   E9           MOV     A,R1
   \   000025   6004         JZ      ??ZDSecMgrAddLinkKey_0
   2362            {
   2363              /* Adding to Addr Manager fails */
   2364              return ZFailure;
   \   000027   7901         MOV     R1,#0x1
   \   000029   8046         SJMP    ??ZDSecMgrAddLinkKey_1
   2365            }
   2366          
   2367            /* Lookup entry using specified address index */
   2368            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   00002B                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002B   AC..         MOV     R4,?XSP + 0
   \   00002D   AD..         MOV     R5,?XSP + 1
   \   00002F   7402         MOV     A,#0x2
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   12....       LCALL   ??Subroutine50_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000037   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   2369          
   2370            // If no existing entry, create one
   2371            if ( entry == NULL )
   \   00003A   85..82       MOV     DPL,?XSP + 0
   \   00003D   85..83       MOV     DPH,?XSP + 1
   \   000040   12....       LCALL   ??Subroutine65_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000043   7019         JNZ     ??CrossCallReturnLabel_101
   2372            {
   2373              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000045                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000045   AA..         MOV     R2,?XSP + 0
   \   000047   AB..         MOV     R3,?XSP + 1
   \   000049   12....       LCALL   `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00004C   E9           MOV     A,R1
   \   00004D   7027         JNZ     ??ZDSecMgrAddLinkKey_2
   2374              {
   2375                entry->ami = ami;
   \   00004F   7402         MOV     A,#0x2
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   12....       LCALL   ?Subroutine25 & 0xFFFF
   2376              }
   \                     ??CrossCallReturnLabel_133:
   \   00005B   12....       LCALL   ??Subroutine51_0 & 0xFFFF
   2377              else
   2378              {
   2379                /* Security Manager full */
   2380                return ZBufferFull;
   2381              }
   2382            }
   2383            // Write the link key
   2384            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_101:
   \   00005E                ; Setup parameters for call to function APSME_LinkKeySet
   \   00005E   740E         MOV     A,#0xe
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   E0           MOVX    A,@DPTR
   \   000064   FC           MOV     R4,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   FD           MOV     R5,A
   \   000068   EE           MOV     A,R6
   \   000069   FA           MOV     R2,A
   \   00006A   EF           MOV     A,R7
   \   00006B   FB           MOV     R3,A
   \   00006C   12....       LCALL   `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   2385          
   2386          #if defined (TC_LINKKEY_JOIN)
   2387            // Mark the device as authenticated.
   2388            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   2389          #endif
   2390          
   2391          #if defined NV_RESTORE
   2392            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   2393          #endif
   2394          
   2395            return ZSuccess;
   \   00006F   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   000071   7404         MOV     A,#0x4
   \   000073   02....       LJMP    ??Subroutine53_0 & 0xFFFF
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000076   7911         MOV     R1,#0x11
   \   000078   80F7         SJMP    ??ZDSecMgrAddLinkKey_1
   2396          }
   2397          
   2398          /******************************************************************************
   2399           * @fn          ZDSecMgrInitNV
   2400           *
   2401           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   2402           *
   2403           * @param       none
   2404           *
   2405           * @return      uint8 - <osal_nv_item_init> return codes
   2406           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2407          uint8 ZDSecMgrInitNV(void)
   \                     ZDSecMgrInitNV:
   2408          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2409          
   2410            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE,
   2411                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   \   00000A                ; Setup parameters for call to function osal_nv_item_init
   \   00000A   E4           CLR     A
   \   00000B   F5..         MOV     ?V0,A
   \   00000D   F5..         MOV     ?V1,A
   \   00000F   78..         MOV     R0,#?V0
   \   000011   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000014   7C11         MOV     R4,#0x11
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7A4C         MOV     R2,#0x4c
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?DEALLOC_XSTACK8
   \   000024   E9           MOV     A,R1
   \   000025   FE           MOV     R6,A
   2412          
   2413            // If the item does not already exist, set all values to 0
   2414            if (rtrn != SUCCESS)
   \   000026   6021         JZ      ??ZDSecMgrInitNV_0
   2415            {
   2416              nvDeviceListHdr_t hdr;
   2417              hdr.numRecs = 0;
   \   000028   12....       LCALL   ?Subroutine15 & 0xFFFF
   2418              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   2419            }
   \                     ??CrossCallReturnLabel_2:
   \   00002B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002E   75..02       MOV     ?V0,#0x2
   \   000031   75..00       MOV     ?V1,#0x0
   \   000034   78..         MOV     R0,#?V0
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   7C00         MOV     R4,#0x0
   \   00003B   7D00         MOV     R5,#0x0
   \   00003D   7A4C         MOV     R2,#0x4c
   \   00003F   7B00         MOV     R3,#0x0
   \   000041   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000044   7404         MOV     A,#0x4
   \   000046   12....       LCALL   ?DEALLOC_XSTACK8
   2420          
   2421            rtrn |= osal_nv_item_init( ZCD_NV_TRUSTCENTER_ADDR, Z_EXTADDR_LEN,
   2422                                       zgApsTrustCenterAddr );
   2423          
   2424            return rtrn;
   \                     ??ZDSecMgrInitNV_0:
   \   000049                ; Setup parameters for call to function osal_nv_item_init
   \   000049   75....       MOV     ?V0,#zgApsTrustCenterAddr & 0xff
   \   00004C   75....       MOV     ?V1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   00004F   78..         MOV     R0,#?V0
   \   000051   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000054   7C08         MOV     R4,#0x8
   \   000056   7D00         MOV     R5,#0x0
   \   000058   7A71         MOV     R2,#0x71
   \   00005A   7B00         MOV     R3,#0x0
   \   00005C   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00005F   7402         MOV     A,#0x2
   \   000061   12....       LCALL   ?DEALLOC_XSTACK8
   \   000064   E9           MOV     A,R1
   \   000065   4E           ORL     A,R6
   \   000066   F9           MOV     R1,A
   \   000067   7402         MOV     A,#0x2
   \   000069   02....       LJMP    ??Subroutine53_0 & 0xFFFF
   2425          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   E4           CLR     A
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   F0           MOVX    @DPTR,A
   \   00000A                ; Setup parameters for call to function osal_nv_write
   \   00000A                ; Setup parameters for call to function osal_nv_write
   \   00000A   A8..         MOV     R0,?XSP + 0
   \   00000C   A9..         MOV     R1,?XSP + 1
   \   00000E   88..         MOV     ?V0,R0
   \   000010   89..         MOV     ?V1,R1
   \   000012   78..         MOV     R0,#?V0
   \   000014   22           RET
   2426          
   2427          #if defined ( NV_RESTORE )
   2428          /*********************************************************************
   2429           * @fn      ZDSecMgrWriteNV()
   2430           *
   2431           * @brief   Save off the APS link key list to NV
   2432           *
   2433           * @param   none
   2434           *
   2435           * @return  none
   2436           */
   2437          static void ZDSecMgrWriteNV( void )
   2438          {
   2439            uint16 i;
   2440            nvDeviceListHdr_t hdr;
   2441          
   2442            hdr.numRecs = 0;
   2443          
   2444            if (ZDSecMgrEntries != NULL)
   2445            {
   2446              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   2447              {
   2448                // Save off the record
   2449                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2450                              (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2451                              sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   2452          
   2453                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   2454                {
   2455                  hdr.numRecs++;
   2456                }
   2457              }
   2458            }
   2459          
   2460            // Save off the header
   2461            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   2462          }
   2463          #endif // NV_RESTORE
   2464          
   2465          #if defined ( NV_RESTORE )
   2466          /******************************************************************************
   2467           * @fn          ZDSecMgrRestoreFromNV
   2468           *
   2469           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   2470           *              the key data itself as they remain in NV until they are used.
   2471           *              Only list data is restored.
   2472           *              Restore zgTrustCenterAdress from NV.
   2473           *
   2474           * @param       none
   2475           *
   2476           * @return      None.
   2477           */
   2478          static void ZDSecMgrRestoreFromNV( void )
   2479          {
   2480            nvDeviceListHdr_t hdr;
   2481            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2482          
   2483            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   2484                ((hdr.numRecs > 0) && (hdr.numRecs <= ZDSECMGR_ENTRY_MAX)))
   2485            {
   2486              uint8 x;
   2487          
   2488              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   2489          
   2490              for (x = 0; x < ZDSECMGR_ENTRY_MAX; x++)
   2491              {
   2492                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   2493                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   2494                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   2495                {
   2496                  // update data only for valid entries
   2497                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   2498                  {
   2499                    if (pApsLinkKey != NULL)
   2500                    {
   2501                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2502                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0,
   2503                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   2504          
   2505                      // set new values for the counter
   2506                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   2507          
   2508                      // restore values for counters in RAM
   2509                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr =
   2510                                                      pApsLinkKey->txFrmCntr;
   2511          
   2512                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr =
   2513                                                      pApsLinkKey->rxFrmCntr;
   2514          
   2515                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0,
   2516                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   2517          
   2518                      // clear copy of key in RAM
   2519                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   2520                    }
   2521                  }
   2522                }
   2523              }
   2524          
   2525              if (pApsLinkKey != NULL)
   2526              {
   2527                osal_mem_free(pApsLinkKey);
   2528              }
   2529            }
   2530          
   2531            osal_nv_read( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   2532          }
   2533          #endif // NV_RESTORE
   2534          
   2535          /*********************************************************************
   2536           * @fn          ZDSecMgrSetDefaultNV
   2537           *
   2538           * @brief       Write the defaults to NV for Entry table and for APS key data table
   2539           *
   2540           * @param       none
   2541           *
   2542           * @return      none
   2543           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2544          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   2545          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2546            uint16 i;
   2547            nvDeviceListHdr_t hdr;
   2548            ZDSecMgrEntry_t secMgrEntry;
   2549            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   2550          
   2551            // Initialize the header
   2552            hdr.numRecs = 0;
   \   00000A   12....       LCALL   ?Subroutine15 & 0xFFFF
   2553          
   2554            // clear the header
   2555            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \                     ??CrossCallReturnLabel_3:
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   75..02       MOV     ?V0,#0x2
   \   000013   75..00       MOV     ?V1,#0x0
   \   000016   78..         MOV     R0,#?V0
   \   000018   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001B   7C00         MOV     R4,#0x0
   \   00001D   7D00         MOV     R5,#0x0
   \   00001F   7A4C         MOV     R2,#0x4c
   \   000021   7B00         MOV     R3,#0x0
   \   000023   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?DEALLOC_XSTACK8
   2556          
   2557            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   00002B                ; Setup parameters for call to function osal_memset
   \   00002B   7C05         MOV     R4,#0x5
   \   00002D   7D00         MOV     R5,#0x0
   \   00002F   7900         MOV     R1,#0x0
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP101_8
   \   000036   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2558          
   2559            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000039   7E00         MOV     R6,#0x0
   \   00003B   7F00         MOV     R7,#0x0
   2560            {
   2561              // Clear the record
   2562              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2563                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2564                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   00003D                ; Setup parameters for call to function osal_nv_write
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP100_8
   \   000042   88..         MOV     ?V0,R0
   \   000044   89..         MOV     ?V1,R1
   \   000046   78..         MOV     R0,#?V0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   75..05       MOV     ?V0,#0x5
   \   00004E   75..00       MOV     ?V1,#0x0
   \   000051   78..         MOV     R0,#?V0
   \   000053   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000056   EE           MOV     A,R6
   \   000057   F8           MOV     R0,A
   \   000058   EF           MOV     A,R7
   \   000059   F9           MOV     R1,A
   \   00005A   E8           MOV     A,R0
   \   00005B   75F005       MOV     B,#0x5
   \   00005E   A4           MUL     AB
   \   00005F   F8           MOV     R0,A
   \   000060   AAF0         MOV     R2,B
   \   000062   75F005       MOV     B,#0x5
   \   000065   E9           MOV     A,R1
   \   000066   A4           MUL     AB
   \   000067   2A           ADD     A,R2
   \   000068   F9           MOV     R1,A
   \   000069   E8           MOV     A,R0
   \   00006A   2402         ADD     A,#0x2
   \   00006C   FC           MOV     R4,A
   \   00006D   E4           CLR     A
   \   00006E   39           ADDC    A,R1
   \   00006F   FD           MOV     R5,A
   \   000070   7A4C         MOV     R2,#0x4c
   \   000072   7B00         MOV     R3,#0x0
   \   000074   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000077   7404         MOV     A,#0x4
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
   2565            }
   \   00007C   0E           INC     R6
   \   00007D   EE           MOV     A,R6
   \   00007E   7001         JNZ     ??ZDSecMgrSetDefaultNV_1
   \   000080   0F           INC     R7
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   000081   C3           CLR     C
   \   000082   9403         SUBB    A,#0x3
   \   000084   EF           MOV     A,R7
   \   000085   9400         SUBB    A,#0x0
   \   000087   40B4         JC      ??ZDSecMgrSetDefaultNV_0
   2566          
   2567            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000089                ; Setup parameters for call to function osal_mem_alloc
   \   000089   7A18         MOV     R2,#0x18
   \   00008B   7B00         MOV     R3,#0x0
   \   00008D   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000090   8A..         MOV     ?V0,R2
   \   000092   8B..         MOV     ?V1,R3
   2568          
   2569            if (pApsLinkKey != NULL)
   \   000094   EA           MOV     A,R2
   \   000095   45..         ORL     A,?V1
   \   000097   603C         JZ      ??ZDSecMgrSetDefaultNV_2
   2570            {
   2571              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   000099                ; Setup parameters for call to function osal_memset
   \   000099   7C18         MOV     R4,#0x18
   \   00009B   7D00         MOV     R5,#0x0
   \   00009D   7900         MOV     R1,#0x0
   \   00009F   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2572          
   2573              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   0000A2   7E00         MOV     R6,#0x0
   \   0000A4   7F00         MOV     R7,#0x0
   2574              {
   2575                // Clear the record
   2576                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   2577                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_3:
   \   0000A6                ; Setup parameters for call to function osal_nv_write
   \   0000A6   78..         MOV     R0,#?V0
   \   0000A8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AB   75..18       MOV     ?V2,#0x18
   \   0000AE   75..00       MOV     ?V3,#0x0
   \   0000B1   78..         MOV     R0,#?V2
   \   0000B3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B6   12....       LCALL   ?Subroutine34 & 0xFFFF
   2578              }
   \                     ??CrossCallReturnLabel_33:
   \   0000B9   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000BC   7404         MOV     A,#0x4
   \   0000BE   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C1   0E           INC     R6
   \   0000C2   EE           MOV     A,R6
   \   0000C3   7001         JNZ     ??ZDSecMgrSetDefaultNV_4
   \   0000C5   0F           INC     R7
   \                     ??ZDSecMgrSetDefaultNV_4:
   \   0000C6   C3           CLR     C
   \   0000C7   9403         SUBB    A,#0x3
   \   0000C9   EF           MOV     A,R7
   \   0000CA   9400         SUBB    A,#0x0
   \   0000CC   40D8         JC      ??ZDSecMgrSetDefaultNV_3
   2579          
   2580              osal_mem_free(pApsLinkKey);
   \   0000CE                ; Setup parameters for call to function osal_mem_free
   \   0000CE   AA..         MOV     R2,?V0
   \   0000D0   AB..         MOV     R3,?V1
   \   0000D2   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2581            }
   2582          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   0000D5   7407         MOV     A,#0x7
   \   0000D7                REQUIRE ?Subroutine5
   \   0000D7                ; // Fall through to label ?Subroutine5

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   7C00         MOV     R4,#0x0
   \   000002   7D00         MOV     R5,#0x0
   \   000004   EE           MOV     A,R6
   \   000005   2401         ADD     A,#0x1
   \   000007   FA           MOV     R2,A
   \   000008   EF           MOV     A,R7
   \   000009   3402         ADDC    A,#0x2
   \   00000B   FB           MOV     R3,A
   \   00000C   22           RET
   2583          
   2584          #if defined ( NV_RESTORE )
   2585          /*********************************************************************
   2586           * @fn      ZDSecMgrUpdateNV()
   2587           *
   2588           * @brief   Updates one entry of the APS link key table to NV
   2589           *
   2590           * @param   index - to the entry in security manager table
   2591           *
   2592           * @return  none
   2593           */
   2594          static void ZDSecMgrUpdateNV( uint16 index )
   2595          {
   2596            nvDeviceListHdr_t hdr;
   2597          
   2598            if (ZDSecMgrEntries != NULL)
   2599            {
   2600              // Save off the record
   2601              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2602                             (uint16)((sizeof(nvDeviceListHdr_t)) + (index * sizeof(ZDSecMgrEntry_t))),
   2603                             sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[index] );
   2604            }
   2605          
   2606            if (osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS)
   2607            {
   2608              if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   2609              {
   2610                if (hdr.numRecs > 0)
   2611                {
   2612                  hdr.numRecs--;
   2613                }
   2614              }
   2615              else
   2616              {
   2617                hdr.numRecs++;
   2618              }
   2619          
   2620              // Save off the header
   2621              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   2622            }
   2623          }
   2624          #endif // NV_RESTORE
   2625          
   2626          /******************************************************************************
   2627           * @fn          ZDSecMgrAPSRemove
   2628           *
   2629           * @brief       Remove device from network.
   2630           *
   2631           * @param       nwkAddr - device's NWK address
   2632           * @param       extAddr - device's Extended address
   2633           * @param       parentAddr - parent's NWK address
   2634           *
   2635           * @return      ZStatus_t
   2636           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2637          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   2638          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2639            ZDSecMgrDevice_t device;
   2640          
   2641            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   2642                 ( extAddr == NULL )              ||
   2643                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   000009   74FE         MOV     A,#-0x2
   \   00000B   6A           XRL     A,R2
   \   00000C   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   00000E   74FF         MOV     A,#-0x1
   \   000010   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000011   6016         JZ      ??ZDSecMgrAPSRemove_1
   \   000013   EC           MOV     A,R4
   \   000014   4D           ORL     A,R5
   \   000015   6012         JZ      ??ZDSecMgrAPSRemove_1
   \   000017   7408         MOV     A,#0x8
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ??Subroutine61_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   00001F   74FE         MOV     A,#-0x2
   \   000021   68           XRL     A,R0
   \   000022   7003         JNZ     ??ZDSecMgrAPSRemove_2
   \   000024   74FF         MOV     A,#-0x1
   \   000026   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_2:
   \   000027   7004         JNZ     ??ZDSecMgrAPSRemove_3
   2644            {
   2645              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   000029   7901         MOV     R1,#0x1
   \   00002B   8024         SJMP    ??ZDSecMgrAPSRemove_4
   2646            }
   2647          
   2648            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00002D   85..82       MOV     DPL,?XSP + 0
   \   000030   85..83       MOV     DPH,?XSP + 1
   \   000033   12....       LCALL   ?Subroutine39 & 0xFFFF
   2649            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_49:
   \   000036   7402         MOV     A,#0x2
   \   000038   12....       LCALL   ?XSTACK_DISP0_8
   \   00003B   EC           MOV     A,R4
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   ED           MOV     A,R5
   \   00003F   F0           MOVX    @DPTR,A
   2650            device.parentAddr = parentAddr;
   \   000040   7404         MOV     A,#0x4
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E8           MOV     A,R0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E9           MOV     A,R1
   \   000049   12....       LCALL   ??Subroutine56_0 & 0xFFFF
   2651          
   2652            // remove device
   2653            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_111:
   \   00004C   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2654          
   2655            return ( ZSuccess );
   \   00004F   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   000051   02....       LJMP    ?Subroutine8 & 0xFFFF
   2656          }
   2657          
   2658          /******************************************************************************
   2659           * @fn          APSME_TCLinkKeyInit
   2660           *
   2661           * @brief       Initialize the NV table for preconfigured TC link key
   2662           *
   2663           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   2664           *              Trust Center Link Key is written to NV. A single tclk is used
   2665           *              by all devices joining the network.
   2666           *
   2667           * @param       setDefault - TRUE to set default values
   2668           *
   2669           * @return      none
   2670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2671          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   2672          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2673            uint8             i;
   2674            APSME_TCLinkKey_t tcLinkKey;
   2675            uint8             rtrn;
   2676          
   2677            // Initialize all NV items for preconfigured TCLK
   2678            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   2679            {
   2680              // Making sure data is cleared for every key all the time
   2681              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C20         MOV     R4,#0x20
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   AA..         MOV     R2,?XSP + 0
   \   000012   AB..         MOV     R3,?XSP + 1
   \   000014   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2682          
   2683              // Initialize first element of the table with the default TCLK
   2684              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   000017   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   6401         XRL     A,#0x1
   \   00001D   7030         JNZ     ??APSME_TCLinkKeyInit_0
   2685              {
   2686                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00001F                ; Setup parameters for call to function osal_memset
   \   00001F   7C08         MOV     R4,#0x8
   \   000021   7D00         MOV     R5,#0x0
   \   000023   79FF         MOV     R1,#-0x1
   \   000025   AA..         MOV     R2,?XSP + 0
   \   000027   AB..         MOV     R3,?XSP + 1
   \   000029   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2687                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   00002C                ; Setup parameters for call to function osal_memcpy
   \   00002C   75....       MOV     ?V0,#defaultTCLinkKey & 0xff
   \   00002F   75....       MOV     ?V1,#(defaultTCLinkKey >> 8) & 0xff
   \   000032   75..80       MOV     ?V2,#-0x80
   \   000035   78..         MOV     R0,#?V0
   \   000037   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00003A   7C10         MOV     R4,#0x10
   \   00003C   7D00         MOV     R5,#0x0
   \   00003E   740B         MOV     A,#0xb
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   AA82         MOV     R2,DPL
   \   000045   AB83         MOV     R3,DPH
   \   000047   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   00004A   7403         MOV     A,#0x3
   \   00004C   12....       LCALL   ?DEALLOC_XSTACK8
   2688              }
   2689          
   2690              // If the item doesn't exist in NV memory, create and initialize
   2691              // it with the default value passed in, either defaultTCLK or 0
   2692              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i),
   2693                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   2694          
   2695              if (rtrn == SUCCESS)
   \                     ??APSME_TCLinkKeyInit_0:
   \   00004F                ; Setup parameters for call to function osal_nv_item_init
   \   00004F   A8..         MOV     R0,?XSP + 0
   \   000051   A9..         MOV     R1,?XSP + 1
   \   000053   88..         MOV     ?V0,R0
   \   000055   89..         MOV     ?V1,R1
   \   000057   78..         MOV     R0,#?V0
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005C   7C20         MOV     R4,#0x20
   \   00005E   7D00         MOV     R5,#0x0
   \   000060   7A01         MOV     R2,#0x1
   \   000062   7B01         MOV     R3,#0x1
   \   000064   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000067   7402         MOV     A,#0x2
   \   000069   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006C   E9           MOV     A,R1
   \   00006D   7074         JNZ     ??APSME_TCLinkKeyInit_1
   2696              {
   2697                // set the Frame counters to 0 to existing keys in NV
   2698                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   2699                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00006F                ; Setup parameters for call to function osal_nv_read
   \   00006F   78..         MOV     R0,#?V0
   \   000071   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000074   75..20       MOV     ?V0,#0x20
   \   000077   75..00       MOV     ?V1,#0x0
   \   00007A   78..         MOV     R0,#?V0
   \   00007C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007F   7C00         MOV     R4,#0x0
   \   000081   7D00         MOV     R5,#0x0
   \   000083   7A01         MOV     R2,#0x1
   \   000085   7B01         MOV     R3,#0x1
   \   000087   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00008A   7404         MOV     A,#0x4
   \   00008C   12....       LCALL   ?DEALLOC_XSTACK8
   2700          
   2701          #if defined ( NV_RESTORE )
   2702                if (setDefault == TRUE)
   2703                {
   2704                  // clear the value stored in NV
   2705                  tcLinkKey.txFrmCntr = 0;
   2706                }
   2707                else
   2708                {
   2709                  // increase the value stored in NV
   2710                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   2711                }
   2712          #else
   2713                // Clear the counters if NV_RESTORE is not enabled and this NV item
   2714                // already existed in the NV memory
   2715                tcLinkKey.txFrmCntr = 0;
   \   00008F   7418         MOV     A,#0x18
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   2716                tcLinkKey.rxFrmCntr = 0;
   \                     ??CrossCallReturnLabel_134:
   \   000097   741C         MOV     A,#0x1c
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   12....       LCALL   ??Subroutine64_0 & 0xFFFF
   2717          #endif  // NV_RESTORE
   2718          
   2719                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   2720                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??CrossCallReturnLabel_135:
   \   00009F                ; Setup parameters for call to function osal_nv_write
   \   00009F   A8..         MOV     R0,?XSP + 0
   \   0000A1   A9..         MOV     R1,?XSP + 1
   \   0000A3   88..         MOV     ?V0,R0
   \   0000A5   89..         MOV     ?V1,R1
   \   0000A7   78..         MOV     R0,#?V0
   \   0000A9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AC   75..20       MOV     ?V0,#0x20
   \   0000AF   75..00       MOV     ?V1,#0x0
   \   0000B2   78..         MOV     R0,#?V0
   \   0000B4   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B7   7C00         MOV     R4,#0x0
   \   0000B9   7D00         MOV     R5,#0x0
   \   0000BB   7A01         MOV     R2,#0x1
   \   0000BD   7B01         MOV     R3,#0x1
   \   0000BF   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000C2   7404         MOV     A,#0x4
   \   0000C4   12....       LCALL   ?DEALLOC_XSTACK8
   2721          
   2722                // set initial values for counters in RAM
   2723                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   0000C7   7418         MOV     A,#0x18
   \   0000C9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CC   12....       LCALL   ?XLOAD_R0123
   \   0000CF   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   0000D2   12....       LCALL   ?XSTORE_R0123
   2724                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;
   \   0000D5   741C         MOV     A,#0x1c
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   12....       LCALL   ?XLOAD_R0123
   \   0000DD   90....       MOV     DPTR,#TCLinkKeyFrmCntr + 4
   \   0000E0   12....       LCALL   ?XSTORE_R0123
   2725              }
   2726            }
   2727          
   2728            // clear copy of key in RAM
   2729            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   0000E3                ; Setup parameters for call to function osal_memset
   \   0000E3   7C20         MOV     R4,#0x20
   \   0000E5   7D00         MOV     R5,#0x0
   \   0000E7   7900         MOV     R1,#0x0
   \   0000E9   AA..         MOV     R2,?XSP + 0
   \   0000EB   AB..         MOV     R3,?XSP + 1
   \   0000ED   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2730          
   2731          }
   \   0000F0   7420         MOV     A,#0x20
   \   0000F2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F5   7F03         MOV     R7,#0x3
   \   0000F7   02....       LJMP    ?BANKED_LEAVE_XDATA
   2732          
   2733          /******************************************************************************
   2734           * @fn          APSME_TCLinkKeySync
   2735           *
   2736           * @brief       Sync Trust Center LINK key data.
   2737           *
   2738           * @param       srcAddr - [in] srcAddr
   2739           * @param       si      - [in, out] SSP_Info_t
   2740           *
   2741           * @return      ZStatus_t
   2742           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2743          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   2744          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   2745            uint8 i, selectedId = ZDSECMGR_TC_DEVICE_MAX;
   2746            ZStatus_t status = ZSecNoKey;
   \   000012   75..A1       MOV     ?V2,#-0x5f
   2747            APSME_TCLinkKey_t tcLinkKey;
   2748            uint32 *tclkRxFrmCntr;
   2749            uint16 originatorAddr = APSME_TRUSTCENTER_NWKADDR;
   \   000015   75..00       MOV     ?V0,#0x0
   \   000018   75..00       MOV     ?V1,#0x0
   2750          
   2751            // Look up the IEEE address of the trust center if it's available
   2752            if ( AddrMgrExtAddrValid( si->extAddr ) == FALSE )
   \   00001B                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001B   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   00001E   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000021   E9           MOV     A,R1
   \   000022   7010         JNZ     ??APSME_TCLinkKeySync_0
   2753            {
   2754              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   000024                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000024   EE           MOV     A,R6
   \   000025   2406         ADD     A,#0x6
   \   000027   FC           MOV     R4,A
   \   000028   E4           CLR     A
   \   000029   3F           ADDC    A,R7
   \   00002A   FD           MOV     R5,A
   \   00002B   AA..         MOV     R2,?V4
   \   00002D   AB..         MOV     R3,?V5
   \   00002F   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000032   8017         SJMP    ??APSME_TCLinkKeySync_1
   2755            }
   2756            else if ( osal_ExtAddrEqual( si->extAddr, _NIB.nwkCoordExtAddress ) )
   \                     ??APSME_TCLinkKeySync_0:
   \   000034                ; Setup parameters for call to function sAddrExtCmp
   \   000034   7C..         MOV     R4,#(_NIB + 25) & 0xff
   \   000036   7D..         MOV     R5,#((_NIB + 25) >> 8) & 0xff
   \   000038   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   00003B   12....       LCALL   `??sAddrExtCmp::?relay`; Banked call to: sAddrExtCmp
   \   00003E   E9           MOV     A,R1
   \   00003F   600A         JZ      ??APSME_TCLinkKeySync_1
   2757            {
   2758              originatorAddr = _NIB.nwkCoordAddress;
   \   000041   90....       MOV     DPTR,#_NIB + 23
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F5..         MOV     ?V0,A
   \   000047   A3           INC     DPTR
   \   000048   E0           MOVX    A,@DPTR
   \   000049   F5..         MOV     ?V1,A
   2759              // in case originated not from our parent, use the default TC address
   2760            }
   2761          
   2762            // Look up the TC link key associated with the device
   2763            // or the default TC link key (extAddr is all FFs), whichever is found
   2764            for ( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   2765            {
   2766              // Read entry i of the TC link key table from NV
   2767              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   2768                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeySync_1:
   \   00004B                ; Setup parameters for call to function osal_nv_read
   \   00004B   A8..         MOV     R0,?XSP + 0
   \   00004D   A9..         MOV     R1,?XSP + 1
   \   00004F   88..         MOV     ?V4,R0
   \   000051   89..         MOV     ?V5,R1
   \   000053   78..         MOV     R0,#?V4
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   75..20       MOV     ?V4,#0x20
   \   00005B   75..00       MOV     ?V5,#0x0
   \   00005E   78..         MOV     R0,#?V4
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   7C00         MOV     R4,#0x0
   \   000065   7D00         MOV     R5,#0x0
   \   000067   7A01         MOV     R2,#0x1
   \   000069   7B01         MOV     R3,#0x1
   \   00006B   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00006E   7404         MOV     A,#0x4
   \   000070   12....       LCALL   ?DEALLOC_XSTACK8
   2769          
   2770              // prefer exact match over default
   2771              if ( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   000073                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000073   AC..         MOV     R4,?XSP + 0
   \   000075   AD..         MOV     R5,?XSP + 1
   \   000077   12....       LCALL   ?Subroutine33 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00007A   12....       LCALL   `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   00007D   E9           MOV     A,R1
   \   00007E   7026         JNZ     ??APSME_TCLinkKeySync_2
   2772              {
   2773                selectedId = i;
   2774                // break from the loop
   2775                break;
   2776              }
   2777              else if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \   000080                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   000080   AA..         MOV     R2,?XSP + 0
   \   000082   AB..         MOV     R3,?XSP + 1
   \   000084   12....       LCALL   `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   000087   E9           MOV     A,R1
   \   000088   6058         JZ      ??APSME_TCLinkKeySync_3
   2778              {
   2779                if ( ( originatorAddr != APSME_TRUSTCENTER_NWKADDR ) && ( si->keyID == SEC_KEYID_TRANSPORT )
   2780                     && (i == 0) && ( zgUseDefaultTCLK == TRUE ) )
   \   00008A   E5..         MOV     A,?V0
   \   00008C   45..         ORL     A,?V1
   \   00008E   6016         JZ      ??APSME_TCLinkKeySync_2
   \   000090   EE           MOV     A,R6
   \   000091   240E         ADD     A,#0xe
   \   000093   F582         MOV     DPL,A
   \   000095   E4           CLR     A
   \   000096   3F           ADDC    A,R7
   \   000097   F583         MOV     DPH,A
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   6402         XRL     A,#0x2
   \   00009C   7008         JNZ     ??APSME_TCLinkKeySync_2
   \   00009E   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   6401         XRL     A,#0x1
   \   0000A4   603C         JZ      ??APSME_TCLinkKeySync_3
   2781                {
   2782                  //if a Key is received directly from an unusual TC,
   2783                  // don't use the first element of the table initialized with the default TCLK
   2784                  continue;
   2785                }
   2786                if ( selectedId == ZDSECMGR_TC_DEVICE_MAX )
   2787                {
   2788                  selectedId = i;
   2789                }
   2790              }
   2791            }
   2792          
   2793            if ( selectedId < ZDSECMGR_TC_DEVICE_MAX )
   2794            {
   2795               // Only for UNIQUE keys, verify that the incoming frame counter is valid
   2796              if ( zgApsLinkKeyType == ZG_UNIQUE_LINK_KEY )
   \                     ??APSME_TCLinkKeySync_2:
   \   0000A6   90....       MOV     DPTR,#zgApsLinkKeyType
   \   0000A9   E0           MOVX    A,@DPTR
   \   0000AA   7030         JNZ     ??APSME_TCLinkKeySync_4
   2797              {
   2798                tclkRxFrmCntr = &TCLinkKeyFrmCntr[selectedId].rxFrmCntr;
   2799          
   2800                if ( si->frmCntr >= *tclkRxFrmCntr )
   \   0000AC   90....       MOV     DPTR,#TCLinkKeyFrmCntr + 4
   \   0000AF   78..         MOV     R0,#?V0
   \   0000B1   12....       LCALL   ?L_MOV_X
   \   0000B4   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   0000B7   12....       LCALL   ?UL_GT_X
   \   0000BA   401B         JC      ??APSME_TCLinkKeySync_5
   2801                {
   2802                  // set the keyNvId to use
   2803                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + selectedId);
   \   0000BC   12....       LCALL   ?Subroutine35 & 0xFFFF
   2804          
   2805                  // update the rx frame counter
   2806                  *tclkRxFrmCntr = si->frmCntr + 1;
   \                     ??CrossCallReturnLabel_36:
   \   0000BF   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_39:
   \   0000C2   12....       LCALL   ?L_MOV_X
   \   0000C5   90....       MOV     DPTR,#__Constant_1
   \   0000C8   78..         MOV     R0,#?V0
   \   0000CA   12....       LCALL   ?L_ADD_X
   \   0000CD   90....       MOV     DPTR,#TCLinkKeyFrmCntr + 4
   \   0000D0   78..         MOV     R0,#?V0
   \   0000D2   12....       LCALL   ?L_MOV_TO_X
   2807          
   2808                  status = ZSuccess;
   \   0000D5   8008         SJMP    ??CrossCallReturnLabel_37
   2809                }
   2810                else
   2811                {
   2812                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_5:
   \   0000D7   75..A2       MOV     ?V2,#-0x5e
   \   0000DA   8006         SJMP    ??APSME_TCLinkKeySync_3
   2813                }
   2814              }
   2815              else
   2816              {
   2817                // set the keyNvId to use
   2818                si->keyNvId = (ZCD_NV_TCLK_TABLE_START + selectedId);
   \                     ??APSME_TCLinkKeySync_4:
   \   0000DC   12....       LCALL   ?Subroutine35 & 0xFFFF
   2819          
   2820                status = ZSuccess;
   \                     ??CrossCallReturnLabel_37:
   \   0000DF   75..00       MOV     ?V2,#0x0
   2821              }
   2822            }
   2823          
   2824            // clear copy of key in RAM
   2825            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_3:
   \   0000E2                ; Setup parameters for call to function osal_memset
   \   0000E2   7C20         MOV     R4,#0x20
   \   0000E4   7D00         MOV     R5,#0x0
   \   0000E6   7900         MOV     R1,#0x0
   \   0000E8   AA..         MOV     R2,?XSP + 0
   \   0000EA   AB..         MOV     R3,?XSP + 1
   \   0000EC   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2826          
   2827            return status;
   \   0000EF   A9..         MOV     R1,?V2
   \   0000F1   7420         MOV     A,#0x20
   \   0000F3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F6   02....       LJMP    ?Subroutine2 & 0xFFFF
   2828          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   EE           MOV     A,R6
   \   000001   2412         ADD     A,#0x12
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   F583         MOV     DPH,A
   \   000009   78..         MOV     R0,#?V0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   EE           MOV     A,R6
   \   000001   240F         ADD     A,#0xf
   \   000003   F582         MOV     DPL,A
   \   000005   E4           CLR     A
   \   000006   3F           ADDC    A,R7
   \   000007   F583         MOV     DPH,A
   \   000009   7401         MOV     A,#0x1
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   22           RET
   2829          
   2830          /******************************************************************************
   2831           * @fn          APSME_TCLinkKeyLoad
   2832           *
   2833           * @brief       Load Trust Center LINK key data.
   2834           *
   2835           * @param       dstAddr - [in] dstAddr
   2836           * @param       si      - [in, out] SSP_Info_t
   2837           *
   2838           * @return      ZStatus_t
   2839           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2840          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   2841          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8C..         MOV     ?V0,R4
   \   00000C   8D..         MOV     ?V1,R5
   2842            uint8 i;
   2843            ZStatus_t status = ZSecNoKey;
   \   00000E   7EA1         MOV     R6,#-0x5f
   2844            APSME_TCLinkKey_t tcLinkKey;
   2845            AddrMgrEntry_t addrEntry;
   2846            uint32 *tclkTxFrmCntr;
   2847            uint8 extAddrFound;
   2848            uint8 defaultTCLKIdx = ZDSECMGR_TC_DEVICE_MAX;
   2849          
   2850            // Look up the ami of the srcAddr if available
   2851            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   E4           CLR     A
   \   000017   F0           MOVX    @DPTR,A
   2852            addrEntry.nwkAddr = dstAddr;
   \   000018   04           INC     A
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine39 & 0xFFFF
   2853          
   2854            extAddrFound = AddrMgrExtAddrValid( si->extAddr );
   \                     ??CrossCallReturnLabel_50:
   \   00001F                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001F   EC           MOV     A,R4
   \   000020   2406         ADD     A,#0x6
   \   000022   FA           MOV     R2,A
   \   000023   E4           CLR     A
   \   000024   35..         ADDC    A,?V1
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   00002A   E9           MOV     A,R1
   \   00002B   FF           MOV     R7,A
   2855          
   2856            // Look up the TC link key associated with the device
   2857            // or the master TC link key (ami = 0xFFFF), whichever is found
   2858            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   2859            {
   2860              // Read entry i of the TC link key table from NV
   2861              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   2862                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   00002C                ; Setup parameters for call to function osal_nv_read
   \   00002C   740D         MOV     A,#0xd
   \   00002E   12....       LCALL   ?XSTACK_DISP100_8
   \   000031   88..         MOV     ?V2,R0
   \   000033   89..         MOV     ?V3,R1
   \   000035   78..         MOV     R0,#?V2
   \   000037   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003A   75..20       MOV     ?V2,#0x20
   \   00003D   75..00       MOV     ?V3,#0x0
   \   000040   78..         MOV     R0,#?V2
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   7C00         MOV     R4,#0x0
   \   000047   7D00         MOV     R5,#0x0
   \   000049   7A01         MOV     R2,#0x1
   \   00004B   7B01         MOV     R3,#0x1
   \   00004D   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000050   7404         MOV     A,#0x4
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   2863          
   2864              if( extAddrFound && AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   000055   EF           MOV     A,R7
   \   000056   6014         JZ      ??APSME_TCLinkKeyLoad_0
   \   000058                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000058   740D         MOV     A,#0xd
   \   00005A   12....       LCALL   ?XSTACK_DISP102_8
   \   00005D   E5..         MOV     A,?V0
   \   00005F   2406         ADD     A,#0x6
   \   000061   FA           MOV     R2,A
   \   000062   E4           CLR     A
   \   000063   35..         ADDC    A,?V1
   \   000065   FB           MOV     R3,A
   \   000066   12....       LCALL   `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   000069   E9           MOV     A,R1
   \   00006A   7012         JNZ     ??APSME_TCLinkKeyLoad_1
   2865              {
   2866                status = ZSuccess;
   2867          
   2868                break; // break from the loop
   2869              }
   2870          
   2871              if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeyLoad_0:
   \   00006C                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00006C   740D         MOV     A,#0xd
   \   00006E   12....       LCALL   ?XSTACK_DISP101_8
   \   000071   12....       LCALL   `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   000074   E9           MOV     A,R1
   \   000075   604C         JZ      ??APSME_TCLinkKeyLoad_2
   2872              {
   2873                if ( !extAddrFound && ( !APSME_IsDistributedSecurity() ) )
   \   000077   EF           MOV     A,R7
   \   000078   7004         JNZ     ??APSME_TCLinkKeyLoad_1
   \   00007A                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   00007A   12....       LCALL   `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   00007D   E9           MOV     A,R1
   2874                {
   2875                  status = ZSuccess;
   2876          
   2877                  break; // break from the loop
   2878                }
   2879          
   2880                // Remember the last default TCLK index
   2881                defaultTCLKIdx = i;
   2882              }
   2883            }
   2884          
   2885            if ( (status != ZSuccess) && (defaultTCLKIdx < ZDSECMGR_TC_DEVICE_MAX) )
   2886            {
   2887              // Exact match was not found; use the last default TC Link Key
   2888              i = defaultTCLKIdx;
   2889              status = ZSuccess;
   2890            }
   2891          
   2892            if ( status == ZSuccess )
   \                     ??APSME_TCLinkKeyLoad_1:
   \   00007E   7E00         MOV     R6,#0x0
   2893            {
   2894              tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   2895          
   2896              // set the keyNvId to use
   2897              si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   000080   E5..         MOV     A,?V0
   \   000082   240F         ADD     A,#0xf
   \   000084   F582         MOV     DPL,A
   \   000086   E4           CLR     A
   \   000087   35..         ADDC    A,?V1
   \   000089   F583         MOV     DPH,A
   \   00008B   7401         MOV     A,#0x1
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   A3           INC     DPTR
   \   00008F   F0           MOVX    @DPTR,A
   2898          
   2899              // update link key related fields
   2900              si->keyID   = SEC_KEYID_LINK;
   \   000090   E5..         MOV     A,?V0
   \   000092   240E         ADD     A,#0xe
   \   000094   F582         MOV     DPL,A
   \   000096   E4           CLR     A
   \   000097   35..         ADDC    A,?V1
   \   000099   F583         MOV     DPH,A
   \   00009B   E4           CLR     A
   \   00009C   F0           MOVX    @DPTR,A
   2901              si->frmCntr = *tclkTxFrmCntr;
   \   00009D   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   0000A0   12....       LCALL   ?XLOAD_R0123
   \   0000A3   E5..         MOV     A,?V0
   \   0000A5   2412         ADD     A,#0x12
   \   0000A7   F582         MOV     DPL,A
   \   0000A9   E4           CLR     A
   \   0000AA   35..         ADDC    A,?V1
   \   0000AC   F583         MOV     DPH,A
   \   0000AE   12....       LCALL   ?XSTORE_R0123
   2902          
   2903              // update outgoing frame counter
   2904              (*tclkTxFrmCntr)++;
   \   0000B1   90....       MOV     DPTR,#__Constant_1
   \   0000B4   78..         MOV     R0,#?V0
   \   0000B6   12....       LCALL   ?L_MOV_X
   \   0000B9   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   0000BC   78..         MOV     R0,#?V0
   \   0000BE   12....       LCALL   ?L_ADD_TO_X
   \   0000C1   8013         SJMP    ??APSME_TCLinkKeyLoad_3
   \                     ??APSME_TCLinkKeyLoad_2:
   \   0000C3                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   2905          
   2906          #if defined ( NV_RESTORE )
   2907              // write periodically to NV
   2908              if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   2909              {
   2910                // set the flag to write key to NV
   2911                TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   2912          
   2913                // Notify the ZDApp that the frame counter has changed.
   2914                osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   2915              }
   2916          #endif
   2917            }
   \   0000C3   AA..         MOV     R2,?XSP + 0
   \   0000C5   AB..         MOV     R3,?XSP + 1
   \   0000C7   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   0000CA   E9           MOV     A,R1
   \   0000CB   6401         XRL     A,#0x1
   \   0000CD   7007         JNZ     ??APSME_TCLinkKeyLoad_3
   2918          
   2919            // If no TC link key found, remove the device from the address manager
   2920            if ( (status != ZSuccess) && (AddrMgrEntryLookupNwk(&addrEntry) == TRUE) )
   2921            {
   2922              AddrMgrEntryRelease( &addrEntry );
   \   0000CF                ; Setup parameters for call to function AddrMgrEntryRelease
   \   0000CF   AA..         MOV     R2,?XSP + 0
   \   0000D1   AB..         MOV     R3,?XSP + 1
   \   0000D3   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   2923            }
   2924          
   2925              // clear copy of key in RAM
   2926            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000D6                ; Setup parameters for call to function osal_memset
   \   0000D6   7C20         MOV     R4,#0x20
   \   0000D8   7D00         MOV     R5,#0x0
   \   0000DA   7900         MOV     R1,#0x0
   \   0000DC   740D         MOV     A,#0xd
   \   0000DE   12....       LCALL   ?XSTACK_DISP101_8
   \   0000E1   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2927          
   2928            return status;
   \   0000E4   EE           MOV     A,R6
   \   0000E5   F9           MOV     R1,A
   \   0000E6   742D         MOV     A,#0x2d
   \   0000E8   02....       LJMP    ?Subroutine5 & 0xFFFF
   2929          }
   2930          
   2931          /******************************************************************************
   2932           * @fn          APSME_IsDefaultTCLK
   2933           *
   2934           * @brief       Return TRUE or FALSE based on the extended address.  If the
   2935           *              input ext address is all FFs, it means the trust center link
   2936           *              assoiciated with the address is the default trust center link key
   2937           *
   2938           * @param       extAddr - [in] extended address
   2939           *
   2940           * @return      uint8 TRUE/FALSE
   2941           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2942          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   2943          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2944            return osal_isbufset( extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000004                ; Setup parameters for call to function osal_isbufset
   \   000004   7C08         MOV     R4,#0x8
   \   000006   79FF         MOV     R1,#-0x1
   \   000008   12....       LCALL   `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   00000B   02....       LJMP    ??Subroutine52_0 & 0xFFFF
   2945          }
   2946          
   2947          /******************************************************************************
   2948           * @fn          ZDSecMgrNwkKeyInit
   2949           *
   2950           * @brief       Initialize the NV items for
   2951           *                  ZCD_NV_NWKKEY,
   2952           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and
   2953           *                  ZCD_NV_NWK_ALTERN_KEY_INFO
   2954           *
   2955           * @param       setDefault
   2956           *
   2957           * @return      none
   2958           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   2960          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2961            uint8 status;
   2962            nwkKeyDesc nwkKey;
   2963          
   2964            // Initialize NV items for NWK key, this structure contains the frame counter
   2965            // and is only used when NV_RESTORE is enabled
   2966            nwkActiveKeyItems keyItems;
   2967          
   2968            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV     R4,#0x15
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   7411         MOV     A,#0x11
   \   000012   12....       LCALL   ?XSTACK_DISP101_8
   \   000015   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2969          
   2970            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   2971          
   2972          #if defined ( NV_RESTORE )
   2973            // reset the values of NV items if NV_RESTORE is not enabled
   2974            if ((status == SUCCESS) && (setDefault == TRUE))
   2975            {
   2976              // clear NV data to default values
   2977              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   2978            }
   2979          #else
   2980            (void)setDefault;   // to eliminate compiler warning
   2981          
   2982            // reset the values of NV items if NV_RESTORE is not enabled
   2983            if (status == SUCCESS)
   \   000018                ; Setup parameters for call to function osal_nv_item_init
   \   000018   7411         MOV     A,#0x11
   \   00001A   12....       LCALL   ?XSTACK_DISP100_8
   \   00001D   88..         MOV     ?V0,R0
   \   00001F   89..         MOV     ?V1,R1
   \   000021   78..         MOV     R0,#?V0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   7C15         MOV     R4,#0x15
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   7A82         MOV     R2,#-0x7e
   \   00002C   7B00         MOV     R3,#0x0
   \   00002E   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?DEALLOC_XSTACK8
   \   000036   E9           MOV     A,R1
   \   000037   7020         JNZ     ??ZDSecMgrNwkKeyInit_0
   2984            {
   2985              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000039                ; Setup parameters for call to function osal_nv_write
   \   000039   78..         MOV     R0,#?V0
   \   00003B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003E   75..15       MOV     ?V0,#0x15
   \   000041   75..00       MOV     ?V1,#0x0
   \   000044   78..         MOV     R0,#?V0
   \   000046   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000049   7C00         MOV     R4,#0x0
   \   00004B   7D00         MOV     R5,#0x0
   \   00004D   7A82         MOV     R2,#-0x7e
   \   00004F   7B00         MOV     R3,#0x0
   \   000051   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000054   7404         MOV     A,#0x4
   \   000056   12....       LCALL   ?DEALLOC_XSTACK8
   2986            }
   2987          #endif // defined (NV_RESTORE)
   2988          
   2989            // Initialize NV items for NWK Active and Alternate keys. These items are used
   2990            // all the time, independently of NV_RESTORE being set or not
   2991            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   000059                ; Setup parameters for call to function osal_memset
   \   000059   7C11         MOV     R4,#0x11
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   7900         MOV     R1,#0x0
   \   00005F   AA..         MOV     R2,?XSP + 0
   \   000061   AB..         MOV     R3,?XSP + 1
   \   000063   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2992          
   2993            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   2994          
   2995          #if defined ( NV_RESTORE )
   2996            // reset the values of NV items if NV_RESTORE is not enabled
   2997            if ((status == SUCCESS) && (setDefault == TRUE))
   2998            {
   2999              // clear NV data to default values
   3000              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   3001            }
   3002          #else
   3003            // reset the values of NV items if NV_RESTORE is not enabled
   3004            if (status == SUCCESS)
   \   000066                ; Setup parameters for call to function osal_nv_item_init
   \   000066   A8..         MOV     R0,?XSP + 0
   \   000068   A9..         MOV     R1,?XSP + 1
   \   00006A   88..         MOV     ?V0,R0
   \   00006C   89..         MOV     ?V1,R1
   \   00006E   78..         MOV     R0,#?V0
   \   000070   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000073   7C11         MOV     R4,#0x11
   \   000075   7D00         MOV     R5,#0x0
   \   000077   7A3A         MOV     R2,#0x3a
   \   000079   7B00         MOV     R3,#0x0
   \   00007B   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00007E   7402         MOV     A,#0x2
   \   000080   12....       LCALL   ?DEALLOC_XSTACK8
   \   000083   E9           MOV     A,R1
   \   000084   7020         JNZ     ??ZDSecMgrNwkKeyInit_1
   3005            {
   3006              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   000086                ; Setup parameters for call to function osal_nv_write
   \   000086   78..         MOV     R0,#?V0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008B   75..11       MOV     ?V0,#0x11
   \   00008E   75..00       MOV     ?V1,#0x0
   \   000091   78..         MOV     R0,#?V0
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   7C00         MOV     R4,#0x0
   \   000098   7D00         MOV     R5,#0x0
   \   00009A   7A3A         MOV     R2,#0x3a
   \   00009C   7B00         MOV     R3,#0x0
   \   00009E   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   3007            }
   3008          #endif // defined (NV_RESTORE)
   3009          
   3010            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   3011          
   3012          #if defined ( NV_RESTORE )
   3013            // reset the values of NV items if NV_RESTORE is not enabled
   3014            if ((status == SUCCESS) && (setDefault == TRUE))
   3015            {
   3016              // clear NV data to default values
   3017              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   3018            }
   3019          #else
   3020            // reset the values of NV items if NV_RESTORE is not enabled
   3021            if (status == SUCCESS)
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   0000A6                ; Setup parameters for call to function osal_nv_item_init
   \   0000A6   A8..         MOV     R0,?XSP + 0
   \   0000A8   A9..         MOV     R1,?XSP + 1
   \   0000AA   88..         MOV     ?V0,R0
   \   0000AC   89..         MOV     ?V1,R1
   \   0000AE   78..         MOV     R0,#?V0
   \   0000B0   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B3   7C11         MOV     R4,#0x11
   \   0000B5   7D00         MOV     R5,#0x0
   \   0000B7   7A3B         MOV     R2,#0x3b
   \   0000B9   7B00         MOV     R3,#0x0
   \   0000BB   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   0000BE   7402         MOV     A,#0x2
   \   0000C0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C3   E9           MOV     A,R1
   \   0000C4   7020         JNZ     ??ZDSecMgrNwkKeyInit_2
   3022            {
   3023              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000C6                ; Setup parameters for call to function osal_nv_write
   \   0000C6   78..         MOV     R0,#?V0
   \   0000C8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000CB   75..11       MOV     ?V0,#0x11
   \   0000CE   75..00       MOV     ?V1,#0x0
   \   0000D1   78..         MOV     R0,#?V0
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D6   7C00         MOV     R4,#0x0
   \   0000D8   7D00         MOV     R5,#0x0
   \   0000DA   7A3B         MOV     R2,#0x3b
   \   0000DC   7B00         MOV     R3,#0x0
   \   0000DE   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000E1   7404         MOV     A,#0x4
   \   0000E3   12....       LCALL   ?DEALLOC_XSTACK8
   3024            }
   3025          #endif // defined (NV_RESTORE)
   3026          
   3027          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   0000E6   7426         MOV     A,#0x26
   \   0000E8   02....       LJMP    ??Subroutine53_0 & 0xFFFF
   3028          
   3029          /*********************************************************************
   3030           * @fn          ZDSecMgrReadKeyFromNv
   3031           *
   3032           * @brief       Looks for a specific key in NV based on Index value
   3033           *
   3034           * @param   keyNvId - Index of key to look in NV
   3035           *                    valid values are:
   3036           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO
   3037           *                    ZCD_NV_NWK_ALTERN_KEY_INFO
   3038           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3039           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3040           *                    ZCD_NV_PRECFGKEY
   3041           *
   3042           * @param  *keyinfo - Data is read into this buffer.
   3043           *
   3044           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   3045           *          Otherwise, NV_OPER_FAILED for failure.
   3046           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3047          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   3048          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3049            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   3050                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   000005   743A         MOV     A,#0x3a
   \   000007   6A           XRL     A,R2
   \   000008   7001         JNZ     ??ZDSecMgrReadKeyFromNv_0
   \   00000A   EB           MOV     A,R3
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   00000B   6006         JZ      ??ZDSecMgrReadKeyFromNv_1
   \   00000D   743B         MOV     A,#0x3b
   \   00000F   6A           XRL     A,R2
   \   000010   4B           ORL     A,R3
   \   000011   7018         JNZ     ??ZDSecMgrReadKeyFromNv_2
   3051            {
   3052              // get NWK active or alternate key from NV
   3053              return (osal_nv_read(keyNvId,
   3054                                   osal_offsetof(nwkKeyDesc, key),
   3055                                   SEC_KEY_LEN,
   3056                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000013                ; Setup parameters for call to function osal_nv_read
   \   000013   8C..         MOV     ?V0,R4
   \   000015   8D..         MOV     ?V1,R5
   \   000017   78..         MOV     R0,#?V0
   \   000019   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001C   75..10       MOV     ?V0,#0x10
   \   00001F   75..00       MOV     ?V1,#0x0
   \   000022   78..         MOV     R0,#?V0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000027   7C01         MOV     R4,#0x1
   \   000029   8042         SJMP    ??ZDSecMgrReadKeyFromNv_3
   3057            }
   3058            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   3059                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00002B   EA           MOV     A,R2
   \   00002C   24FF         ADD     A,#-0x1
   \   00002E   F8           MOV     R0,A
   \   00002F   EB           MOV     A,R3
   \   000030   34FE         ADDC    A,#-0x2
   \   000032   F9           MOV     R1,A
   \   000033   E8           MOV     A,R0
   \   000034   49           ORL     A,R1
   \   000035   7018         JNZ     ??ZDSecMgrReadKeyFromNv_4
   3060            {
   3061              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   3062              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3063              return (osal_nv_read(keyNvId,
   3064                                   osal_offsetof(APSME_TCLinkKey_t, key),
   3065                                   SEC_KEY_LEN,
   3066                                   keyinfo));
   \   000037                ; Setup parameters for call to function osal_nv_read
   \   000037   8C..         MOV     ?V0,R4
   \   000039   8D..         MOV     ?V1,R5
   \   00003B   78..         MOV     R0,#?V0
   \   00003D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000040   75..10       MOV     ?V0,#0x10
   \   000043   75..00       MOV     ?V1,#0x0
   \   000046   78..         MOV     R0,#?V0
   \   000048   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004B   7C08         MOV     R4,#0x8
   \   00004D   801E         SJMP    ??ZDSecMgrReadKeyFromNv_3
   3067            }
   3068            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   3069                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   00004F   19           DEC     R1
   \   000050   C3           CLR     C
   \   000051   E8           MOV     A,R0
   \   000052   12....       LCALL   ??Subroutine45_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000055   501A         JNC     ??ZDSecMgrReadKeyFromNv_5
   3070            {
   3071              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   3072              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3073              return (osal_nv_read(keyNvId,
   3074                                   osal_offsetof(APSME_LinkKeyData_t, key),
   3075                                   SEC_KEY_LEN,
   3076                                   keyinfo));
   \   000057                ; Setup parameters for call to function osal_nv_read
   \   000057   8C..         MOV     ?V0,R4
   \   000059   8D..         MOV     ?V1,R5
   \   00005B   78..         MOV     R0,#?V0
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   75..10       MOV     ?V0,#0x10
   \   000063   75..00       MOV     ?V1,#0x0
   \   000066   78..         MOV     R0,#?V0
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006B   7C00         MOV     R4,#0x0
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   8022         SJMP    ??ZDSecMgrReadKeyFromNv_6
   3077            }
   3078            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   000071   7462         MOV     A,#0x62
   \   000073   6A           XRL     A,R2
   \   000074   4B           ORL     A,R3
   \   000075   7026         JNZ     ??ZDSecMgrReadKeyFromNv_7
   3079            {
   3080              // Read entry keyNvId of the Preconfig key from NV.
   3081              return (osal_nv_read(keyNvId,
   3082                                   0,
   3083                                   SEC_KEY_LEN,
   3084                                   keyinfo));
   \   000077                ; Setup parameters for call to function osal_nv_read
   \   000077   8C..         MOV     ?V0,R4
   \   000079   8D..         MOV     ?V1,R5
   \   00007B   78..         MOV     R0,#?V0
   \   00007D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000080   75..10       MOV     ?V0,#0x10
   \   000083   75..00       MOV     ?V1,#0x0
   \   000086   78..         MOV     R0,#?V0
   \   000088   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008B   7C00         MOV     R4,#0x0
   \   00008D   7D00         MOV     R5,#0x0
   \   00008F   7A62         MOV     R2,#0x62
   \   000091   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   000093   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000096   7404         MOV     A,#0x4
   \   000098   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009B   8002         SJMP    ??ZDSecMgrReadKeyFromNv_8
   3085            }
   3086          
   3087            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   00009D   790A         MOV     R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   00009F   02....       LJMP    ??Subroutine54_0 & 0xFFFF
   3088          }
   3089          
   3090          /******************************************************************************
   3091           * @fn          ZDSecMgrApsLinkKeyInit
   3092           *
   3093           * @brief       Initialize the NV table for Application link keys
   3094           *
   3095           * @param       none
   3096           *
   3097           * @return      none
   3098           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3099          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   3100          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3101            APSME_LinkKeyData_t pApsLinkKey;
   3102            uint8 i;
   3103            uint8 status;
   3104          
   3105            // Initialize all NV items for APS link key, if not exist already.
   3106            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV     R4,#0x18
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   AA..         MOV     R2,?XSP + 0
   \   000012   AB..         MOV     R3,?XSP + 1
   \   000014   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3107          
   3108            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000017   7E00         MOV     R6,#0x0
   3109            {
   3110              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i),
   3111                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   3112          
   3113          #if defined ( NV_RESTORE )
   3114              (void)status;   // to eliminate compiler warning
   3115          #else
   3116              // reset the values of NV items if NV_RESTORE is not enabled
   3117              if (status == SUCCESS)
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   000019                ; Setup parameters for call to function osal_nv_item_init
   \   000019   A8..         MOV     R0,?XSP + 0
   \   00001B   A9..         MOV     R1,?XSP + 1
   \   00001D   88..         MOV     ?V0,R0
   \   00001F   89..         MOV     ?V1,R1
   \   000021   78..         MOV     R0,#?V0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   7C18         MOV     R4,#0x18
   \   000028   7D00         MOV     R5,#0x0
   \   00002A   EE           MOV     A,R6
   \   00002B   2401         ADD     A,#0x1
   \   00002D   FA           MOV     R2,A
   \   00002E   E4           CLR     A
   \   00002F   3402         ADDC    A,#0x2
   \   000031   FB           MOV     R3,A
   \   000032   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000035   7402         MOV     A,#0x2
   \   000037   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003A   E9           MOV     A,R1
   \   00003B   7024         JNZ     ??ZDSecMgrApsLinkKeyInit_1
   3118              {
   3119                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3120                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   00003D                ; Setup parameters for call to function osal_nv_write
   \   00003D   78..         MOV     R0,#?V0
   \   00003F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000042   75..18       MOV     ?V0,#0x18
   \   000045   75..00       MOV     ?V1,#0x0
   \   000048   78..         MOV     R0,#?V0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   7C00         MOV     R4,#0x0
   \   00004F   7D00         MOV     R5,#0x0
   \   000051   EE           MOV     A,R6
   \   000052   2401         ADD     A,#0x1
   \   000054   FA           MOV     R2,A
   \   000055   E4           CLR     A
   \   000056   3402         ADDC    A,#0x2
   \   000058   FB           MOV     R3,A
   \   000059   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00005C   7404         MOV     A,#0x4
   \   00005E   12....       LCALL   ?DEALLOC_XSTACK8
   3121          
   3122              }
   3123          #endif // defined (NV_RESTORE)
   3124            }
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   000061   0E           INC     R6
   \   000062   EE           MOV     A,R6
   \   000063   C3           CLR     C
   \   000064   9403         SUBB    A,#0x3
   \   000066   40B1         JC      ??ZDSecMgrApsLinkKeyInit_0
   3125          }
   \   000068   7418         MOV     A,#0x18
   \   00006A   02....       LJMP    ??Subroutine53_0 & 0xFFFF
   3126          
   3127          /******************************************************************************
   3128           * @fn          ZDSecMgrInitNVKeyTables
   3129           *
   3130           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   3131           *
   3132           * @param       setDefault - TRUE to set default values
   3133           *
   3134           * @return      none
   3135           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3136          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   3137          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   3138            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   12....       LCALL   `??ZDSecMgrNwkKeyInit::?relay`; Banked call to: ZDSecMgrNwkKeyInit
   3139            ZDSecMgrApsLinkKeyInit();
   \   00000A                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000A   12....       LCALL   `??ZDSecMgrApsLinkKeyInit::?relay`; Banked call to: ZDSecMgrApsLinkKeyInit
   3140            APSME_TCLinkKeyInit(setDefault);
   \   00000D                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   00000D   EE           MOV     A,R6
   \   00000E   F9           MOV     R1,A
   \   00000F   12....       LCALL   `??APSME_TCLinkKeyInit::?relay`; Banked call to: APSME_TCLinkKeyInit
   3141          }
   \   000012   02....       LJMP    ??Subroutine58_0 & 0xFFFF
   3142          
   3143          /******************************************************************************
   3144           * @fn          ZDSecMgrSaveApsLinkKey
   3145           *
   3146           * @brief       Save APS Link Key to NV. It will loop through all the keys
   3147           *              to see which one to save.
   3148           *
   3149           * @param       none
   3150           *
   3151           * @return      none
   3152           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3153          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   3154          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   3155            APSME_LinkKeyData_t *pKeyData = NULL;
   3156            int i;
   3157          
   3158            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A18         MOV     R2,#0x18
   \   000007   7B00         MOV     R3,#0x0
   \   000009   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000C   8A..         MOV     ?V2,R2
   \   00000E   8B..         MOV     ?V3,R3
   3159          
   3160            if (pKeyData != NULL)
   \   000010   EA           MOV     A,R2
   \   000011   45..         ORL     A,?V3
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   3161            {
   3162              // checks all pending flags to know which one to save
   3163              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000018   7E00         MOV     R6,#0x0
   \   00001A   7F00         MOV     R7,#0x0
   3164              {
   3165                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   00001C   EE           MOV     A,R6
   \   00001D   F8           MOV     R0,A
   \   00001E   EF           MOV     A,R7
   \   00001F   F9           MOV     R1,A
   \   000020   E8           MOV     A,R0
   \   000021   75F009       MOV     B,#0x9
   \   000024   A4           MUL     AB
   \   000025   F8           MOV     R0,A
   \   000026   AAF0         MOV     R2,B
   \   000028   75F009       MOV     B,#0x9
   \   00002B   E9           MOV     A,R1
   \   00002C   A4           MUL     AB
   \   00002D   2A           ADD     A,R2
   \   00002E   F9           MOV     R1,A
   \   00002F   74..         MOV     A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000031   28           ADD     A,R0
   \   000032   F582         MOV     DPL,A
   \   000034   74..         MOV     A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   000036   39           ADDC    A,R1
   \   000037   F583         MOV     DPH,A
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6401         XRL     A,#0x1
   \   00003C   6003         JZ      $+5
   \   00003E   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_2 & 0xFFFF
   3166                {
   3167                  // retrieve key from NV
   3168                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3169                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000041                ; Setup parameters for call to function osal_nv_read
   \   000041   78..         MOV     R0,#?V2
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000046   75..18       MOV     ?V0,#0x18
   \   000049   75..00       MOV     ?V1,#0x0
   \   00004C   78..         MOV     R0,#?V0
   \   00004E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000051   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000054   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000057   7404         MOV     A,#0x4
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   E9           MOV     A,R1
   \   00005D   7079         JNZ     ??ZDSecMgrSaveApsLinkKey_2
   3170                  {
   3171                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00005F   EE           MOV     A,R6
   \   000060   F8           MOV     R0,A
   \   000061   EF           MOV     A,R7
   \   000062   F9           MOV     R1,A
   \   000063   E8           MOV     A,R0
   \   000064   75F009       MOV     B,#0x9
   \   000067   A4           MUL     AB
   \   000068   F8           MOV     R0,A
   \   000069   AAF0         MOV     R2,B
   \   00006B   75F009       MOV     B,#0x9
   \   00006E   E9           MOV     A,R1
   \   00006F   A4           MUL     AB
   \   000070   2A           ADD     A,R2
   \   000071   F9           MOV     R1,A
   \   000072   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   000074   28           ADD     A,R0
   \   000075   F5..         MOV     ?V0,A
   \   000077   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   000079   39           ADDC    A,R1
   \   00007A   F5..         MOV     ?V1,A
   \   00007C   85..82       MOV     DPL,?V0
   \   00007F   F583         MOV     DPH,A
   \   000081   12....       LCALL   ?XLOAD_R0123
   \   000084   E5..         MOV     A,?V2
   \   000086   2410         ADD     A,#0x10
   \   000088   F582         MOV     DPL,A
   \   00008A   E4           CLR     A
   \   00008B   35..         ADDC    A,?V3
   \   00008D   F583         MOV     DPH,A
   \   00008F   12....       LCALL   ?XSTORE_R0123
   3172                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   000092   85..82       MOV     DPL,?V0
   \   000095   85..83       MOV     DPH,?V1
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   12....       LCALL   ?XLOAD_R0123
   \   00009F   E5..         MOV     A,?V2
   \   0000A1   2414         ADD     A,#0x14
   \   0000A3   F582         MOV     DPL,A
   \   0000A5   E4           CLR     A
   \   0000A6   35..         ADDC    A,?V3
   \   0000A8   F583         MOV     DPH,A
   \   0000AA   12....       LCALL   ?XSTORE_R0123
   3173          
   3174                    // Write the APS link key back to the NV
   3175                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3176                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   0000AD                ; Setup parameters for call to function osal_nv_write
   \   0000AD   78..         MOV     R0,#?V2
   \   0000AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B2   75..18       MOV     ?V4,#0x18
   \   0000B5   75..00       MOV     ?V5,#0x0
   \   0000B8   78..         MOV     R0,#?V4
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BD   12....       LCALL   ?Subroutine34 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000C0   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000C3   7404         MOV     A,#0x4
   \   0000C5   12....       LCALL   ?DEALLOC_XSTACK8
   3177          
   3178                    // clear the pending write flag
   3179                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   0000C8   85..82       MOV     DPL,?V0
   \   0000CB   85..83       MOV     DPH,?V1
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   A3           INC     DPTR
   \   0000D3   A3           INC     DPTR
   \   0000D4   A3           INC     DPTR
   \   0000D5   A3           INC     DPTR
   \   0000D6   E4           CLR     A
   \   0000D7   F0           MOVX    @DPTR,A
   3180                  }
   3181                }
   3182              }
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   0000D8   0E           INC     R6
   \   0000D9   EE           MOV     A,R6
   \   0000DA   7001         JNZ     ??ZDSecMgrSaveApsLinkKey_3
   \   0000DC   0F           INC     R7
   \                     ??ZDSecMgrSaveApsLinkKey_3:
   \   0000DD   C3           CLR     C
   \   0000DE   9403         SUBB    A,#0x3
   \   0000E0   EF           MOV     A,R7
   \   0000E1   9400         SUBB    A,#0x0
   \   0000E3   A2D2         MOV     C,0xD0 /* PSW */.2
   \   0000E5   65D0         XRL     A,PSW
   \   0000E7   33           RLC     A
   \   0000E8   5003         JNC     $+5
   \   0000EA   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   3183          
   3184              // clear copy of key in RAM
   3185              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000ED                ; Setup parameters for call to function osal_memset
   \   0000ED   7C18         MOV     R4,#0x18
   \   0000EF   7D00         MOV     R5,#0x0
   \   0000F1   7900         MOV     R1,#0x0
   \   0000F3   AA..         MOV     R2,?V2
   \   0000F5   AB..         MOV     R3,?V3
   \   0000F7   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3186          
   3187              osal_mem_free(pKeyData);
   \   0000FA                ; Setup parameters for call to function osal_mem_free
   \   0000FA   AA..         MOV     R2,?V2
   \   0000FC   AB..         MOV     R3,?V3
   \   0000FE   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3188            }
   3189          }
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   000101   02....       LJMP    ?Subroutine2 & 0xFFFF
   3190          
   3191          /******************************************************************************
   3192           * @fn          ZDSecMgrSaveTCLinkKey
   3193           *
   3194           * @brief       Save TC Link Key to NV. It will loop through all the keys
   3195           *              to see which one to save.
   3196           *
   3197           * @param       none
   3198           *
   3199           * @return      none
   3200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3201          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   3202          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3203            APSME_TCLinkKey_t *pKeyData = NULL;
   3204            uint16 i;
   3205          
   3206            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   000005                ; Setup parameters for call to function osal_mem_alloc
   \   000005   7A20         MOV     R2,#0x20
   \   000007   7B00         MOV     R3,#0x0
   \   000009   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   3207          
   3208            if (pKeyData != NULL)
   \   000010   EA           MOV     A,R2
   \   000011   45..         ORL     A,?V1
   \   000013   7003         JNZ     $+5
   \   000015   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   3209            {
   3210              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   3211              {
   3212                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   000018   90....       MOV     DPTR,#TCLinkKeyFrmCntr + 8
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6401         XRL     A,#0x1
   \   00001E   706A         JNZ     ??ZDSecMgrSaveTCLinkKey_1
   3213                {
   3214                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0,
   3215                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   000020                ; Setup parameters for call to function osal_nv_read
   \   000020   78..         MOV     R0,#?V0
   \   000022   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000025   75..20       MOV     ?V2,#0x20
   \   000028   75..00       MOV     ?V3,#0x0
   \   00002B   78..         MOV     R0,#?V2
   \   00002D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000030   7C00         MOV     R4,#0x0
   \   000032   7D00         MOV     R5,#0x0
   \   000034   7A01         MOV     R2,#0x1
   \   000036   7B01         MOV     R3,#0x1
   \   000038   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00003B   7404         MOV     A,#0x4
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000040   E9           MOV     A,R1
   \   000041   7047         JNZ     ??ZDSecMgrSaveTCLinkKey_1
   3216                  {
   3217                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000043   90....       MOV     DPTR,#TCLinkKeyFrmCntr
   \   000046   12....       LCALL   ?XLOAD_R0123
   \   000049   E5..         MOV     A,?V0
   \   00004B   2418         ADD     A,#0x18
   \   00004D   F582         MOV     DPL,A
   \   00004F   E4           CLR     A
   \   000050   35..         ADDC    A,?V1
   \   000052   F583         MOV     DPH,A
   \   000054   12....       LCALL   ?XSTORE_R0123
   3218                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   000057   90....       MOV     DPTR,#TCLinkKeyFrmCntr + 4
   \   00005A   12....       LCALL   ?XLOAD_R0123
   \   00005D   E5..         MOV     A,?V0
   \   00005F   241C         ADD     A,#0x1c
   \   000061   F582         MOV     DPL,A
   \   000063   E4           CLR     A
   \   000064   35..         ADDC    A,?V1
   \   000066   F583         MOV     DPH,A
   \   000068   12....       LCALL   ?XSTORE_R0123
   3219          
   3220                    // Write the TC link key back to the NV
   3221                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0,
   3222                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   00006B                ; Setup parameters for call to function osal_nv_write
   \   00006B   78..         MOV     R0,#?V0
   \   00006D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000070   78..         MOV     R0,#?V2
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   7C00         MOV     R4,#0x0
   \   000077   7D00         MOV     R5,#0x0
   \   000079   7A01         MOV     R2,#0x1
   \   00007B   7B01         MOV     R3,#0x1
   \   00007D   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000080   7404         MOV     A,#0x4
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   3223          
   3224                    // clear the pending write flag
   3225                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   000085   90....       MOV     DPTR,#TCLinkKeyFrmCntr + 8
   \   000088   E4           CLR     A
   \   000089   F0           MOVX    @DPTR,A
   3226                  }
   3227                }
   3228              }
   3229                // clear copy of key in RAM
   3230              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   00008A                ; Setup parameters for call to function osal_memset
   \   00008A   7C20         MOV     R4,#0x20
   \   00008C   7D00         MOV     R5,#0x0
   \   00008E   7900         MOV     R1,#0x0
   \   000090   AA..         MOV     R2,?V0
   \   000092   AB..         MOV     R3,?V1
   \   000094   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3231          
   3232              osal_mem_free(pKeyData);
   \   000097                ; Setup parameters for call to function osal_mem_free
   \   000097   AA..         MOV     R2,?V0
   \   000099   AB..         MOV     R3,?V1
   \   00009B   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3233            }
   3234          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   00009E   02....       LJMP    ??Subroutine66_0 & 0xFFFF
   3235          
   3236          /******************************************************************************
   3237           * @fn          ZDSecMgrUpdateTCAddress
   3238           *
   3239           * @brief       Update Trust Center address and save to NV.
   3240           *
   3241           * @param       extAddr - [in] extended address or NULL if no TC protected
   3242           *
   3243           * @return      none
   3244           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3245          void ZDSecMgrUpdateTCAddress( uint8 *extAddr )
   \                     ZDSecMgrUpdateTCAddress:
   3246          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3247            uint8 noTCAddress[Z_EXTADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
   \   00000A   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   00000D   AC..         MOV     R4,?XSP + 0
   \   00000F   AD..         MOV     R5,?XSP + 1
   \   000011   7408         MOV     A,#0x8
   \   000013   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3248            APSME_SetRequest( apsTrustCenterAddress, 0, ( extAddr != NULL) ? extAddr : noTCAddress );
   \   000016   EA           MOV     A,R2
   \   000017   4B           ORL     A,R3
   \   000018   700C         JNZ     ??ZDSecMgrUpdateTCAddress_0
   \   00001A   A8..         MOV     R0,?XSP + 0
   \   00001C   A9..         MOV     R1,?XSP + 1
   \   00001E   88..         MOV     ?V0,R0
   \   000020   89..         MOV     ?V1,R1
   \   000022   AA..         MOV     R2,?V0
   \   000024   AB..         MOV     R3,?V1
   \                     ??ZDSecMgrUpdateTCAddress_0:
   \   000026                ; Setup parameters for call to function APSME_SetRequest
   \   000026   EA           MOV     A,R2
   \   000027   FC           MOV     R4,A
   \   000028   EB           MOV     A,R3
   \   000029   FD           MOV     R5,A
   \   00002A   7A00         MOV     R2,#0x0
   \   00002C   7B00         MOV     R3,#0x0
   \   00002E   79AB         MOV     R1,#-0x55
   \   000030   12....       LCALL   `??APSME_SetRequest::?relay`; Banked call to: APSME_SetRequest
   3249          #if defined ( NV_RESTORE )
   3250            osal_nv_write( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   3251          #endif
   3252          }
   \   000033   02....       LJMP    ?Subroutine3 & 0xFFFF

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrClear::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrClear

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMI::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExtGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMIGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMIGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemoveByExtAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateRM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinDirect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinFwd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAssocDeviceAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoining::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoiningTimeout::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNewDeviceEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCExtAddrCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCDataLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTransportKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRemoveDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestAppKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetupPartner::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeySet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeyNVIdGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsLinkKeyValid::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_KeyFwdToChild::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAPSRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeySync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsDefaultTCLK::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNwkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrReadKeyFromNv::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrApsLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNVKeyTables::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveApsLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveTCLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateTCAddress::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateTCAddress

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1
   3253          
   3254          #if defined ( ZBA_FALLBACK_NWKKEY )
   3255          /******************************************************************************
   3256           * @fn          ZDSecMgrFallbackNwkKey
   3257           *
   3258           * @brief       Use the ZBA fallback network key.
   3259           *
   3260           * @param       none
   3261           *
   3262           * @return      none
   3263           */
   3264          void ZDSecMgrFallbackNwkKey( void )
   3265          {
   3266            if ( !_NIB.nwkKeyLoaded )
   3267            {
   3268              uint8 fallbackKey[SEC_KEY_LEN];
   3269          
   3270              ZDSecMgrReadKeyFromNv( ZCD_NV_PRECFGKEY, fallbackKey );
   3271              SSP_UpdateNwkKey( fallbackKey, 0);
   3272              SSP_SwitchNwkKey( 0 );
   3273          
   3274              // clear local copy of key
   3275              osal_memset( fallbackKey, 0x00, SEC_KEY_LEN );
   3276          
   3277              // handle next step in authentication process
   3278              ZDSecMgrAuthNwkKey();
   3279            }
   3280          }
   3281          #endif // defined ( ZBA_FALLBACK_NWKKEY )
   3282          
   3283          #if defined ( NV_RESTORE )
   3284          /******************************************************************************
   3285           * @fn          ZDSecMgrClearNVKeyValues
   3286           *
   3287           * @brief       If NV_RESTORE is enabled and the status of the network needs
   3288           *              default values this fuction clears ZCD_NV_NWKKEY,
   3289           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link
   3290           *
   3291           * @param       none
   3292           *
   3293           * @return      none
   3294           */
   3295          void ZDSecMgrClearNVKeyValues(void)
   3296          {
   3297            nwkActiveKeyItems keyItems;
   3298            nwkKeyDesc nwkKey;
   3299          
   3300            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   3301          
   3302            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   3303          
   3304            // Initialize NV items for NWK Active and Alternate keys.
   3305            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   3306          
   3307            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   3308          
   3309            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   3310          }
   3311          #endif // defined ( NV_RESTORE )
   3312          
   3313          /******************************************************************************
   3314          ******************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2     57   APSME_IsDefaultTCLK
        2      0   -> osal_isbufset
      0     37   APSME_IsLinkKeyValid
        0     33   -> APSME_LinkKeyNVIdGet
        0     33   -> osal_mem_alloc
        0     33   -> osal_mem_free
        0     36   -> osal_memcmp
        0     33   -> osal_memset
        0     37   -> osal_nv_read
      0     10   APSME_KeyFwdToChild
        0     10   -> AssocGetWithExt
        0     10   -> ZDSecMgrAssocDeviceAuth
      0     44   APSME_LinkKeyNVIdGet
        0     11   -> ZDSecMgrEntryLookupExt
      0     37   APSME_LinkKeySet
        0     21   -> ZDSecMgrEntryLookupExtGetIndex
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     22   -> osal_memcpy
        0     19   -> osal_memset
        0     23   -> osal_nv_read
        0     23   -> osal_nv_write
      0     56   APSME_TCLinkKeyInit
        0     46   -> osal_memcpy
        0     43   -> osal_memset
        0     45   -> osal_nv_item_init
        0     47   -> osal_nv_read
        0     47   -> osal_nv_write
      0     61   APSME_TCLinkKeyLoad
        0     57   -> APSME_IsDefaultTCLK
        0     57   -> APSME_IsDistributedSecurity
        0     57   -> AddrMgrEntryLookupNwk
        0     57   -> AddrMgrEntryRelease
        0     57   -> AddrMgrExtAddrEqual
        0     57   -> AddrMgrExtAddrValid
        0     57   -> osal_memset
        0     61   -> osal_nv_read
      0     50   APSME_TCLinkKeySync
        0     46   -> APSME_IsDefaultTCLK
        0     46   -> APSME_LookupExtAddr
        0     46   -> AddrMgrExtAddrEqual
        0     46   -> AddrMgrExtAddrValid
        0     46   -> osal_memset
        0     50   -> osal_nv_read
        0     46   -> sAddrExtCmp
      2     10   ZDSecMgrAPSRemove
        2      8   -> ZDSecMgrDeviceRemove
      0     18   ZDSecMgrAddLinkKey
        0     14   -> APSME_LinkKeySet
        0     16   -> ZDSecMgrAddrStore
        0     14   -> ZDSecMgrEntryLookupAMI
        0     14   -> ZDSecMgrEntryNew
      0     57   ZDSecMgrAddrClear
        0     24   -> AddrMgrEntryRelease
        0     24   -> ZDSecMgrExtAddrLookup
      0     53   ZDSecMgrAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      3     57   ZDSecMgrAppKeyGet
        2      0   -> SSP_GetTrueRand
      0     57   ZDSecMgrAppKeyReq
        0     49   -> APSME_LookupExtAddr
        0     49   -> APSME_LookupNwkAddr
        0     49   -> APSME_TransportKeyReq
        0     57   -> ZDSecMgrAppKeyGet
        0     49   -> osal_memset
      0     47   ZDSecMgrApsLinkKeyInit
        0     34   -> osal_memset
        0     36   -> osal_nv_item_init
        0     38   -> osal_nv_write
      2     33   ZDSecMgrAssocDeviceAuth
      2     26   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      0      0   ZDSecMgrAuthenticationCheck
      1     11   ZDSecMgrAuthenticationSet
        0     11   -> ZDSecMgrEntryLookupExt
      2      0   ZDSecMgrConfig
        2      0   -> APSME_SecurityRM_RD
        2      0   -> SSP_Init
      0     41   ZDSecMgrDeviceJoin
        0     29   -> ZDSecMgrAddrClear
        0     31   -> ZDSecMgrAddrStore
        0     29   -> ZDSecMgrDeviceRemove
        0     29   -> ZDSecMgrDeviceValidate
        0     29   -> ZDSecMgrSendNwkKey
        0     32   -> osal_memcpy
      0     18   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      0     27   ZDSecMgrDeviceJoinFwd
        0     18   -> APSME_UpdateDeviceReq
        0     18   -> AssocGetWithShort
        0     18   -> ZDSecMgrAssocDeviceAuth
      0     42   ZDSecMgrDeviceNew
        0      9   -> APSME_IsDistributedSecurity
        0      9   -> ZDSecMgrDeviceJoinDirect
        0      9   -> ZDSecMgrDeviceJoinFwd
      0     49   ZDSecMgrDeviceRemove
        0     20   -> APSME_RemoveDeviceReq
        0     20   -> AssocGetWithExt
        0     20   -> NLME_GetShortAddr
        0     20   -> NLME_LeaveReq
      0     11   ZDSecMgrDeviceRemoveByExtAddr
        0     11   -> ZDSecMgrEntryFree
        0     11   -> ZDSecMgrEntryLookupExt
      2     29   ZDSecMgrDeviceValidate
        2      0   -> ZDSecMgrDeviceValidateRM
      2      0   ZDSecMgrDeviceValidateRM
      0     29   ZDSecMgrEntryFree
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_write
      2      0   ZDSecMgrEntryInit
        2      0   -> osal_mem_alloc
      0     22   ZDSecMgrEntryLookup
        0     22   -> AddrMgrEntryLookupNwk
      0     23   ZDSecMgrEntryLookupAMI
      0      9   ZDSecMgrEntryLookupAMIGetIndex
      0     22   ZDSecMgrEntryLookupExt
        0     11   -> ZDSecMgrEntryLookupAMI
        0     11   -> ZDSecMgrExtAddrLookup
      0     32   ZDSecMgrEntryLookupExtGetIndex
        0     11   -> ZDSecMgrExtAddrLookup
      0     23   ZDSecMgrEntryNew
      0     46   ZDSecMgrExtAddrLookup
        0     22   -> AddrMgrEntryLookupExt
        0     22   -> AddrMgrExtAddrSet
      0     24   ZDSecMgrExtAddrStore
        0     22   -> AddrMgrEntryUpdate
        0     22   -> AddrMgrExtAddrSet
      2      0   ZDSecMgrInit
        2      0   -> APSME_IsDistributedSecurity
        2      0   -> APSME_SecurityRM_RD
        2      0   -> SSP_Init
      0     16   ZDSecMgrInitNV
        0     14   -> osal_nv_item_init
        0     16   -> osal_nv_write
      0      9   ZDSecMgrInitNVKeyTables
        0      9   -> APSME_TCLinkKeyInit
        0      9   -> ZDSecMgrApsLinkKeyInit
        0      9   -> ZDSecMgrNwkKeyInit
      1     33   ZDSecMgrNewDeviceEvent
        0     33   -> AddrMgrEntryGet
        0     33   -> AssocGetWithShort
        0     33   -> AssocRemove
        0     33   -> NLME_GetShortAddr
        0     33   -> ZDSecMgrAddrClear
        0     33   -> ZDSecMgrAssocDeviceAuth
        0     33   -> ZDSecMgrDeviceNew
      0     61   ZDSecMgrNwkKeyInit
        0     48   -> osal_memset
        0     50   -> osal_nv_item_init
        0     52   -> osal_nv_write
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     40   ZDSecMgrReadKeyFromNv
        0     14   -> osal_nv_read
      0     17   ZDSecMgrRemoveDeviceInd
        0     17   -> APSME_LookupNwkAddr
        0     17   -> NLME_GetShortAddr
        0     17   -> ZDSecMgrDeviceRemove
      2      4   ZDSecMgrRequestAppKey
        2      4   -> APSME_RequestKeyReq
      2      0   ZDSecMgrRequestKeyInd
        2      0   -> ZDSecMgrAppKeyReq
      0     18   ZDSecMgrSaveApsLinkKey
        0     14   -> osal_mem_alloc
        0     14   -> osal_mem_free
        0     14   -> osal_memset
        0     18   -> osal_nv_read
        0     18   -> osal_nv_write
      0     16   ZDSecMgrSaveTCLinkKey
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free
        0     12   -> osal_memset
        0     16   -> osal_nv_read
        0     16   -> osal_nv_write
      1     73   ZDSecMgrSendNwkKey
        0     40   -> APSME_TransportKeyReq
        0     40   -> NLME_GetShortAddr
        0     44   -> NLME_ReadNwkKeyInfo
        0     40   -> osal_memset
      0     23   ZDSecMgrSetDefaultNV
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     19   -> osal_memset
        0     23   -> osal_nv_write
      0     25   ZDSecMgrSetupPartner
        0     25   -> AddrMgrEntryUpdate
        0     25   -> AddrMgrExtAddrSet
        0     25   -> AddrMgrExtAddrValid
        0     25   -> ZDP_IEEEAddrReq
        0     25   -> ZDP_NwkAddrReq
      2      0   ZDSecMgrSwitchKeyInd
        2      0   -> SSP_SwitchNwkKey
        2      0   -> ZDApp_NVUpdate
      0     53   ZDSecMgrTCDataLoad
        0     25   -> APSME_IsDistributedSecurity
        0     25   -> AddrMgrEntryLookupExt
        0     27   -> ZDSecMgrAddrStore
        0     25   -> sAddrExtCpy
      0     17   ZDSecMgrTCExtAddrCheck
        0     17   -> APSME_GetRequest
        0     17   -> sAddrExtCmp
      0     26   ZDSecMgrTransportKeyInd
        0     26   -> SSP_SwitchNwkKey
        0     26   -> SSP_UpdateNwkKey
        0     26   -> ZDSecMgrAuthNwkKey
        0     26   -> ZDSecMgrReadKeyFromNv
        0     26   -> ZDSecMgrTCDataLoad
        0     26   -> ZDSecMgrUpdateTCAddress
        0     26   -> osal_isbufset
        0     26   -> osal_memset
      2      8   ZDSecMgrUpdateDeviceInd
        2      8   -> ZDSecMgrDeviceJoin
      0     44   ZDSecMgrUpdateTCAddress
        0     18   -> APSME_SetRequest


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       1  ?<Initializer for ZDSecMgrAppKeyType>
       5  ??Subroutine43_0
       8  ??Subroutine44_0
       6  ??Subroutine45_0
       9  ??Subroutine46_0
       9  ??Subroutine47_0
       6  ??Subroutine48_0
       2  ??Subroutine49_0
       6  ??Subroutine50_0
       6  ??Subroutine51_0
       7  ??Subroutine52_0
       3  ??Subroutine53_0
       5  ??Subroutine54_0
       6  ??Subroutine55_0
       6  ??Subroutine56_0
       3  ??Subroutine57_0
       5  ??Subroutine58_0
       4  ??Subroutine59_0
       2  ??Subroutine60_0
       4  ??Subroutine61_0
       9  ??Subroutine62_0
       2  ??Subroutine63_0
       9  ??Subroutine64_0
       5  ??Subroutine65_0
       5  ??Subroutine66_0
       2  ?Subroutine0
       6  ?Subroutine1
       3  ?Subroutine10
       5  ?Subroutine11
       4  ?Subroutine12
      13  ?Subroutine13
       4  ?Subroutine14
      21  ?Subroutine15
       6  ?Subroutine16
       6  ?Subroutine17
      15  ?Subroutine18
       8  ?Subroutine19
       5  ?Subroutine2
       9  ?Subroutine20
       3  ?Subroutine21
      11  ?Subroutine22
      39  ?Subroutine23
      11  ?Subroutine24
       7  ?Subroutine25
       6  ?Subroutine26
       6  ?Subroutine27
       6  ?Subroutine28
      12  ?Subroutine29
       2  ?Subroutine3
       4  ?Subroutine30
       1  ?Subroutine31
      30  ?Subroutine32
       8  ?Subroutine33
      13  ?Subroutine34
      15  ?Subroutine35
      12  ?Subroutine36
       6  ?Subroutine37
      10  ?Subroutine38
       6  ?Subroutine39
       8  ?Subroutine4
       7  ?Subroutine40
       2  ?Subroutine41
       9  ?Subroutine42
       3  ?Subroutine5
       5  ?Subroutine6
       5  ?Subroutine7
       2  ?Subroutine8
       4  ?Subroutine9
      14  APSME_IsDefaultTCLK
       6  APSME_IsDefaultTCLK::?relay
     182  APSME_IsLinkKeyValid
       6  APSME_IsLinkKeyValid::?relay
      62  APSME_KeyFwdToChild
       6  APSME_KeyFwdToChild::?relay
      55  APSME_LinkKeyNVIdGet
       6  APSME_LinkKeyNVIdGet::?relay
     281  APSME_LinkKeySet
       6  APSME_LinkKeySet::?relay
     250  APSME_TCLinkKeyInit
       6  APSME_TCLinkKeyInit::?relay
     235  APSME_TCLinkKeyLoad
       6  APSME_TCLinkKeyLoad::?relay
     249  APSME_TCLinkKeySync
       6  APSME_TCLinkKeySync::?relay
      27  ApsLinkKeyFrmCntr
       9  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
      84  ZDSecMgrAPSRemove
       6  ZDSecMgrAPSRemove::?relay
     122  ZDSecMgrAddLinkKey
       6  ZDSecMgrAddLinkKey::?relay
      66  ZDSecMgrAddrClear
       6  ZDSecMgrAddrClear::?relay
      73  ZDSecMgrAddrStore
       6  ZDSecMgrAddrStore::?relay
      42  ZDSecMgrAppKeyGet
       6  ZDSecMgrAppKeyGet::?relay
     268  ZDSecMgrAppKeyReq
       6  ZDSecMgrAppKeyReq::?relay
       1  ZDSecMgrAppKeyType
     109  ZDSecMgrApsLinkKeyInit
       6  ZDSecMgrApsLinkKeyInit::?relay
      23  ZDSecMgrAssocDeviceAuth
       6  ZDSecMgrAssocDeviceAuth::?relay
      26  ZDSecMgrAuthNwkKey
       6  ZDSecMgrAuthNwkKey::?relay
       5  ZDSecMgrAuthenticationCheck
       6  ZDSecMgrAuthenticationCheck::?relay
      35  ZDSecMgrAuthenticationSet
       6  ZDSecMgrAuthenticationSet::?relay
       6  ZDSecMgrConfig
       6  ZDSecMgrConfig::?relay
     229  ZDSecMgrDeviceJoin
       6  ZDSecMgrDeviceJoin::?relay
      35  ZDSecMgrDeviceJoinDirect
       6  ZDSecMgrDeviceJoinDirect::?relay
     169  ZDSecMgrDeviceJoinFwd
       6  ZDSecMgrDeviceJoinFwd::?relay
      36  ZDSecMgrDeviceNew
       6  ZDSecMgrDeviceNew::?relay
     224  ZDSecMgrDeviceRemove
       6  ZDSecMgrDeviceRemove::?relay
      35  ZDSecMgrDeviceRemoveByExtAddr
       6  ZDSecMgrDeviceRemoveByExtAddr::?relay
      24  ZDSecMgrDeviceValidate
       6  ZDSecMgrDeviceValidate::?relay
      17  ZDSecMgrDeviceValidateRM
       6  ZDSecMgrDeviceValidateRM::?relay
       2  ZDSecMgrEntries
     112  ZDSecMgrEntryFree
       6  ZDSecMgrEntryFree::?relay
      66  ZDSecMgrEntryInit
       6  ZDSecMgrEntryInit::?relay
     150  ZDSecMgrEntryLookup
       6  ZDSecMgrEntryLookup::?relay
      76  ZDSecMgrEntryLookupAMI
       6  ZDSecMgrEntryLookupAMI::?relay
      48  ZDSecMgrEntryLookupAMIGetIndex
       6  ZDSecMgrEntryLookupAMIGetIndex::?relay
      59  ZDSecMgrEntryLookupExt
       6  ZDSecMgrEntryLookupExt::?relay
     115  ZDSecMgrEntryLookupExtGetIndex
       6  ZDSecMgrEntryLookupExtGetIndex::?relay
     131  ZDSecMgrEntryNew
       6  ZDSecMgrEntryNew::?relay
      72  ZDSecMgrExtAddrLookup
       6  ZDSecMgrExtAddrLookup::?relay
      73  ZDSecMgrExtAddrStore
       6  ZDSecMgrExtAddrStore::?relay
      23  ZDSecMgrInit
       6  ZDSecMgrInit::?relay
     108  ZDSecMgrInitNV
       6  ZDSecMgrInitNV::?relay
      21  ZDSecMgrInitNVKeyTables
       6  ZDSecMgrInitNVKeyTables::?relay
     197  ZDSecMgrNewDeviceEvent
       6  ZDSecMgrNewDeviceEvent::?relay
     235  ZDSecMgrNwkKeyInit
       6  ZDSecMgrNwkKeyInit::?relay
      38  ZDSecMgrPermitJoining
       6  ZDSecMgrPermitJoining::?relay
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      23  ZDSecMgrPermitJoiningTimeout
       6  ZDSecMgrPermitJoiningTimeout::?relay
     162  ZDSecMgrReadKeyFromNv
       6  ZDSecMgrReadKeyFromNv::?relay
      80  ZDSecMgrRemoveDeviceInd
       6  ZDSecMgrRemoveDeviceInd::?relay
      38  ZDSecMgrRequestAppKey
       6  ZDSecMgrRequestAppKey::?relay
      36  ZDSecMgrRequestKeyInd
       6  ZDSecMgrRequestKeyInd::?relay
     260  ZDSecMgrSaveApsLinkKey
       6  ZDSecMgrSaveApsLinkKey::?relay
     161  ZDSecMgrSaveTCLinkKey
       6  ZDSecMgrSaveTCLinkKey::?relay
     282  ZDSecMgrSendNwkKey
       6  ZDSecMgrSendNwkKey::?relay
     215  ZDSecMgrSetDefaultNV
       6  ZDSecMgrSetDefaultNV::?relay
     122  ZDSecMgrSetupPartner
       6  ZDSecMgrSetupPartner::?relay
      23  ZDSecMgrSwitchKeyInd
       6  ZDSecMgrSwitchKeyInd::?relay
       1  ZDSecMgrTCAuthenticated
      90  ZDSecMgrTCDataLoad
       6  ZDSecMgrTCDataLoad::?relay
       8  ZDSecMgrTCExtAddr
      38  ZDSecMgrTCExtAddrCheck
       6  ZDSecMgrTCExtAddrCheck::?relay
     208  ZDSecMgrTransportKeyInd
       6  ZDSecMgrTransportKeyInd::?relay
      97  ZDSecMgrUpdateDeviceInd
       6  ZDSecMgrUpdateDeviceInd::?relay
      54  ZDSecMgrUpdateTCAddress
       6  ZDSecMgrUpdateTCAddress::?relay
       4  __Constant_1

 
 6 861 bytes in segment BANKED_CODE
   360 bytes in segment BANK_RELAYS
     1 byte  in segment XDATA_I
     1 byte  in segment XDATA_ID
    12 bytes in segment XDATA_ROM_C
    81 bytes in segment XDATA_Z
 
 7 222 bytes of CODE  memory
     8 bytes of CONST memory (+ 4 bytes shared)
    82 bytes of XDATA memory

Errors: none
Warnings: none
