###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                21/Apr/2017  17:49:25
# Copyright 2004-2015 IAR Systems AB.
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Components\stack\zdo\ZDSecMgr.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x04000000 -DZDAPP_CONFIG_PAN_ID=0x0085
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=5
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -DCHANNEL_CNT=0x01 "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Components\stack\zdo\ZDSecMgr.c" -D ZTOOL_P1 -D MT_TASK -D
#        MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -D NV_RESTORE -D
#        NV_INIT -D NODE_AUTH -D xWIFI_FREQUENCY_SELECT -D OPEN_FCS -lC
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\CoordinatorEB\Obj"
#        -e --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -I "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\Source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Application\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On --require_prototypes
#    List file          =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\CoordinatorEB\List\ZDSecMgr.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\CoordinatorEB\Obj\ZDSecMgr.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh 1.0.0\Components\stack\zdo\ZDSecMgr.c
      1          /******************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2014-06-05 11:25:00 -0700 (Thu, 05 Jun 2014) $
      4            Revision:       $Revision: 38833 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License"). You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product. Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          ******************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComDef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Nv.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "ZDConfig.h"
     60          #include "ZDSecMgr.h"
     61          #if NODE_AUTH
     62          #include "NodeAuth.h"
     63          #endif
     64          
     65          
     66          /******************************************************************************
     67           * CONSTANTS
     68           */
     69          // maximum number of devices managed by this Security Manager
     70          #if !defined ( ZDSECMGR_DEVICE_MAX )
     71            #define ZDSECMGR_DEVICE_MAX 3
     72          #endif
     73          
     74          // maximum number of LINK keys this device may store
     75          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     76          
     77          // total number of stored devices
     78          #if !defined ( ZDSECMGR_STORED_DEVICES )
     79            #define ZDSECMGR_STORED_DEVICES 3
     80          #endif
     81          
     82          // Total number of preconfigured trust center link key
     83          #if !defined ( ZDSECMGR_TC_DEVICE_MAX )
     84            #define ZDSECMGR_TC_DEVICE_MAX 1
     85          #endif
     86          
     87          #if ( ZDSECMGR_TC_DEVICE_MAX < 1 ) || ( ZDSECMGR_TC_DEVICE_MAX > 255 )
     88            #error "ZDSECMGR_TC_DEVICE_MAX shall be between 1 and 255 !"
     89          #endif
     90          
     91          // APSME Stub Implementations
     92          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
     93          #define ZDSecMgrLinkKeyNVIdGet APSME_LinkKeyNVIdGet
     94          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
     95          #define ZDSecMgrIsLinkKeyValid APSME_IsLinkKeyValid
     96          
     97          /******************************************************************************
     98           * TYPEDEFS
     99           */
    100          typedef struct
    101          {
    102            uint16            ami;
    103            uint16            keyNvId;   // index to the Link Key table in NV
    104            ZDSecMgr_Authentication_Option authenticateOption;
    105          } ZDSecMgrEntry_t;
    106          
    107          typedef struct
    108          {
    109            uint16          nwkAddr;
    110            uint8*          extAddr;
    111            uint16          parentAddr;
    112            uint8           secure;
    113            uint8           devStatus;
    114          } ZDSecMgrDevice_t;
    115          
    116          /******************************************************************************
    117           * EXTERNAL VARIABLES
    118           */
    119          extern pfnZdoCb zdoCBFunc[MAX_ZDO_CB_FUNC];
    120          
    121          /******************************************************************************
    122           * LOCAL VARIABLES
    123           */
    124          #if 0 // Taken out because the following functionality is only used for test
    125                // purpose. A more efficient (above) way is used. It can be put
    126                // back in if customers request for a white/black list feature.
    127          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    128          {
    129            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    130            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    131            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    132          };
    133          #endif
    134          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    135          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    136            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    137          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    138          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    139          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    140          ZDSecMgrEntry_t* ZDSecMgrEntries  = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    141          
    142          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    143          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    144          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    145          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    146          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    147          APSME_TCLinkKey_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z
    148          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    149          APSME_ApsLinkKeyFrmCntr_t ApsLinkKeyFrmCntr[ZDSECMGR_ENTRY_MAX];
   \                     ApsLinkKeyFrmCntr:
   \   000000                DS 27
   \   00001B                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    150          APSME_TCLinkKeyFrmCntr_t TCLinkKeyFrmCntr[ZDSECMGR_TC_DEVICE_MAX];
   \                     TCLinkKeyFrmCntr:
   \   000000                DS 9
   \   000009                REQUIRE __INIT_XDATA_Z
    151          
    152          /******************************************************************************
    153           * PRIVATE FUNCTIONS
    154           *
    155           *   ZDSecMgrAddrStore
    156           *   ZDSecMgrExtAddrStore
    157           *   ZDSecMgrExtAddrLookup
    158           *   ZDSecMgrEntryInit
    159           *   ZDSecMgrEntryLookup
    160           *   ZDSecMgrEntryLookupAMI
    161           *   ZDSecMgrEntryLookupExt
    162           *   ZDSecMgrEntryLookupExtGetIndex
    163           *   ZDSecMgrEntryFree
    164           *   ZDSecMgrEntryNew
    165           *   ZDSecMgrAppKeyGet
    166           *   ZDSecMgrAppKeyReq
    167           *   ZDSecMgrSendNwkKey
    168           *   ZDSecMgrDeviceRemove
    169           *   ZDSecMgrDeviceValidateRM
    170           *   ZDSecMgrDeviceValidate
    171           *   ZDSecMgrDeviceJoin
    172           *   ZDSecMgrDeviceJoinDirect
    173           *   ZDSecMgrDeviceJoinFwd
    174           *   ZDSecMgrDeviceNew
    175           *   ZDSecMgrAssocDeviceAuth
    176           *   ZDSecMgrAuthNwkKey
    177           *   APSME_TCLinkKeyInit
    178           *   APSME_IsDefaultTCLK
    179           */
    180          
    181          //-----------------------------------------------------------------------------
    182          // address management
    183          //-----------------------------------------------------------------------------
    184          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    185          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    186          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    187          
    188          //-----------------------------------------------------------------------------
    189          // Trust Center management
    190          //-----------------------------------------------------------------------------
    191          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );
    192          void ZDSecMgrTCDataLoad( uint8* extAddr );
    193          
    194          //-----------------------------------------------------------------------------
    195          // entry data
    196          //-----------------------------------------------------------------------------
    197          void ZDSecMgrEntryInit(uint8 state);
    198          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    199          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    200          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    201          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex );
    202          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex );
    203          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    204          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    205          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    206          void ZDSecMgrApsLinkKeyInit(void);
    207          #if defined ( NV_RESTORE )
    208          static void ZDSecMgrWriteNV(void);
    209          static void ZDSecMgrRestoreFromNV(void);
    210          static void ZDSecMgrUpdateNV( uint16 index );
    211          #endif
    212          
    213          //-----------------------------------------------------------------------------
    214          // key support
    215          //-----------------------------------------------------------------------------
    216          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    217                                       uint8*  initExtAddr,
    218                                       uint16  partNwkAddr,
    219                                       uint8*  partExtAddr,
    220                                       uint8** key,
    221                                       uint8*  keyType );
    222          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    223          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    224          void ZDSecMgrNwkKeyInit(uint8 setDefault);
    225          
    226          //-----------------------------------------------------------------------------
    227          // device management
    228          //-----------------------------------------------------------------------------
    229          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    230          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    231          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    232          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    233          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    234          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    235          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    236          
    237          //-----------------------------------------------------------------------------
    238          // association management
    239          //-----------------------------------------------------------------------------
    240          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    241          
    242          //-----------------------------------------------------------------------------
    243          // authentication management
    244          //-----------------------------------------------------------------------------
    245          void ZDSecMgrAuthNwkKey( void );
    246          
    247          //-----------------------------------------------------------------------------
    248          // APSME function
    249          //-----------------------------------------------------------------------------
    250          void APSME_TCLinkKeyInit( uint8 setDefault );
    251          uint8 APSME_IsDefaultTCLK( uint8 *extAddr );
    252          
    253          /******************************************************************************
    254           * @fn          ZDSecMgrAddrStore
    255           *
    256           * @brief       Store device addresses.
    257           *
    258           * @param       nwkAddr - [in] NWK address
    259           * @param       extAddr - [in] EXT address
    260           * @param       ami     - [out] Address Manager index
    261           *
    262           * @return      ZStatus_t
    263           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    264          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    265          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   741A         MOV     A,#0x1a
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V1,A
    266            ZStatus_t      status;
    267            AddrMgrEntry_t entry;
    268          
    269          
    270            // add entry
    271            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
    272            entry.nwkAddr = nwkAddr;
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E5..         MOV     A,?V2
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   E5..         MOV     A,?V3
   \   000032   F0           MOVX    @DPTR,A
    273            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   EE           MOV     A,R6
   \   000034   FC           MOV     R4,A
   \   000035   EF           MOV     A,R7
   \   000036   FD           MOV     R5,A
   \   000037   7403         MOV     A,#0x3
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    274          
    275            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000043   AA..         MOV     R2,?XSP + 0
   \   000045   AB..         MOV     R3,?XSP + 1
   \   000047   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00004A   E9           MOV     A,R1
   \   00004B   6401         XRL     A,#0x1
   \   00004D   701A         JNZ     ??ZDSecMgrAddrStore_0
    276            {
    277              // return successful results
    278              *ami   = entry.index;
   \   00004F   740B         MOV     A,#0xb
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F9           MOV     R1,A
   \   000059   85..82       MOV     DPL,?V0
   \   00005C   85..83       MOV     DPH,?V1
   \   00005F   E8           MOV     A,R0
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   E9           MOV     A,R1
   \   000063   F0           MOVX    @DPTR,A
    279              status = ZSuccess;
   \   000064   75..00       MOV     ?V4,#0x0
   \   000067   8018         SJMP    ??ZDSecMgrAddrStore_1
    280            }
    281            else
    282            {
    283              // return failed results
    284              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   000069   740B         MOV     A,#0xb
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F8           MOV     R0,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F9           MOV     R1,A
   \   000073   85..82       MOV     DPL,?V0
   \   000076   85..83       MOV     DPH,?V1
   \   000079   E8           MOV     A,R0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E9           MOV     A,R1
   \   00007D   F0           MOVX    @DPTR,A
    285              status = ZNwkUnknownDevice;
   \   00007E   75..C8       MOV     ?V4,#-0x38
    286            }
    287          
    288            return status;
   \                     ??ZDSecMgrAddrStore_1:
   \   000081   A9..         MOV     R1,?V4
   \   000083   740D         MOV     A,#0xd
   \   000085   12....       LCALL   ?DEALLOC_XSTACK8
   \   000088   7F05         MOV     R7,#0x5
   \   00008A   02....       LJMP    ?BANKED_LEAVE_XDATA
    289          }
    290          
    291          /******************************************************************************
    292           * @fn          ZDSecMgrExtAddrStore
    293           *
    294           * @brief       Store EXT address.
    295           *
    296           * @param       extAddr - [in] EXT address
    297           * @param       ami     - [out] Address Manager index
    298           *
    299           * @return      ZStatus_t
    300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    301          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    302          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   741A         MOV     A,#0x1a
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V1,A
    303            ZStatus_t      status;
    304            AddrMgrEntry_t entry;
    305          
    306          
    307            // add entry
    308            entry.user    = ADDRMGR_USER_SECURITY;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   7402         MOV     A,#0x2
   \   000026   F0           MOVX    @DPTR,A
    309            entry.nwkAddr = nwkAddr;
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E5..         MOV     A,?V2
   \   00002E   F0           MOVX    @DPTR,A
   \   00002F   A3           INC     DPTR
   \   000030   E5..         MOV     A,?V3
   \   000032   F0           MOVX    @DPTR,A
    310            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000033                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000033   EE           MOV     A,R6
   \   000034   FC           MOV     R4,A
   \   000035   EF           MOV     A,R7
   \   000036   FD           MOV     R5,A
   \   000037   7403         MOV     A,#0x3
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   AA82         MOV     R2,DPL
   \   00003E   AB83         MOV     R3,DPH
   \   000040   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    311          
    312            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000043   AA..         MOV     R2,?XSP + 0
   \   000045   AB..         MOV     R3,?XSP + 1
   \   000047   12....       LCALL   `??AddrMgrEntryUpdate::?relay`; Banked call to: AddrMgrEntryUpdate
   \   00004A   E9           MOV     A,R1
   \   00004B   6401         XRL     A,#0x1
   \   00004D   701A         JNZ     ??ZDSecMgrExtAddrStore_0
    313            {
    314              // return successful results
    315              *ami   = entry.index;
   \   00004F   740B         MOV     A,#0xb
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F8           MOV     R0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   F9           MOV     R1,A
   \   000059   85..82       MOV     DPL,?V0
   \   00005C   85..83       MOV     DPH,?V1
   \   00005F   E8           MOV     A,R0
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   E9           MOV     A,R1
   \   000063   F0           MOVX    @DPTR,A
    316              status = ZSuccess;
   \   000064   75..00       MOV     ?V4,#0x0
   \   000067   8018         SJMP    ??ZDSecMgrExtAddrStore_1
    317            }
    318            else
    319            {
    320              // return failed results
    321              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   000069   740B         MOV     A,#0xb
   \   00006B   12....       LCALL   ?XSTACK_DISP0_8
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   F8           MOV     R0,A
   \   000070   A3           INC     DPTR
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F9           MOV     R1,A
   \   000073   85..82       MOV     DPL,?V0
   \   000076   85..83       MOV     DPH,?V1
   \   000079   E8           MOV     A,R0
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   A3           INC     DPTR
   \   00007C   E9           MOV     A,R1
   \   00007D   F0           MOVX    @DPTR,A
    322              status = ZNwkUnknownDevice;
   \   00007E   75..C8       MOV     ?V4,#-0x38
    323            }
    324          
    325            return status;
   \                     ??ZDSecMgrExtAddrStore_1:
   \   000081   A9..         MOV     R1,?V4
   \   000083   740D         MOV     A,#0xd
   \   000085   12....       LCALL   ?DEALLOC_XSTACK8
   \   000088   7F05         MOV     R7,#0x5
   \   00008A   02....       LJMP    ?BANKED_LEAVE_XDATA
    326          }
    327          
    328          /******************************************************************************
    329           * @fn          ZDSecMgrExtAddrLookup
    330           *
    331           * @brief       Lookup index for specified EXT address.
    332           *
    333           * @param       extAddr - [in] EXT address
    334           * @param       ami     - [out] Address Manager index
    335           *
    336           * @return      ZStatus_t
    337           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    338          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    339          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
    340            ZStatus_t      status;
    341            AddrMgrEntry_t entry;
    342          
    343          
    344            // lookup entry
    345            entry.user = ADDRMGR_USER_SECURITY;
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   7402         MOV     A,#0x2
   \   00001A   F0           MOVX    @DPTR,A
    346            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   00001B                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00001B   EE           MOV     A,R6
   \   00001C   FC           MOV     R4,A
   \   00001D   EF           MOV     A,R7
   \   00001E   FD           MOV     R5,A
   \   00001F   7403         MOV     A,#0x3
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   AA82         MOV     R2,DPL
   \   000026   AB83         MOV     R3,DPH
   \   000028   12....       LCALL   `??AddrMgrExtAddrSet::?relay`; Banked call to: AddrMgrExtAddrSet
    347          
    348            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \   00002B                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002B   AA..         MOV     R2,?XSP + 0
   \   00002D   AB..         MOV     R3,?XSP + 1
   \   00002F   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   000032   E9           MOV     A,R1
   \   000033   6401         XRL     A,#0x1
   \   000035   701A         JNZ     ??ZDSecMgrExtAddrLookup_0
    349            {
    350              // return successful results
    351              *ami   = entry.index;
   \   000037   740B         MOV     A,#0xb
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F8           MOV     R0,A
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   F9           MOV     R1,A
   \   000041   85..82       MOV     DPL,?V0
   \   000044   85..83       MOV     DPH,?V1
   \   000047   E8           MOV     A,R0
   \   000048   F0           MOVX    @DPTR,A
   \   000049   A3           INC     DPTR
   \   00004A   E9           MOV     A,R1
   \   00004B   F0           MOVX    @DPTR,A
    352              status = ZSuccess;
   \   00004C   75..00       MOV     ?V2,#0x0
   \   00004F   8018         SJMP    ??ZDSecMgrExtAddrLookup_1
    353            }
    354            else
    355            {
    356              // return failed results
    357              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000051   740B         MOV     A,#0xb
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   F9           MOV     R1,A
   \   00005B   85..82       MOV     DPL,?V0
   \   00005E   85..83       MOV     DPH,?V1
   \   000061   E8           MOV     A,R0
   \   000062   F0           MOVX    @DPTR,A
   \   000063   A3           INC     DPTR
   \   000064   E9           MOV     A,R1
   \   000065   F0           MOVX    @DPTR,A
    358              status = ZNwkUnknownDevice;
   \   000066   75..C8       MOV     ?V2,#-0x38
    359            }
    360          
    361            return status;
   \                     ??ZDSecMgrExtAddrLookup_1:
   \   000069   A9..         MOV     R1,?V2
   \   00006B   740D         MOV     A,#0xd
   \   00006D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000070   7F03         MOV     R7,#0x3
   \   000072   02....       LJMP    ?BANKED_LEAVE_XDATA
    362          }
    363          
    364          /******************************************************************************
    365           * @fn          ZDSecMgrAddrClear
    366           *
    367           * @brief       Clear security bit from Address Manager for specific device.
    368           *
    369           * @param       extAddr - [in] EXT address
    370           *
    371           * @return      ZStatus_t
    372           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    373          ZStatus_t ZDSecMgrAddrClear( uint8* extAddr )
   \                     ZDSecMgrAddrClear:
    374          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    375            ZStatus_t status;
    376            uint16 entryAmi;
    377          
    378            // get Address Manager Index
    379            status = ZDSecMgrExtAddrLookup( extAddr, &entryAmi );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   FA           MOV     R2,A
   \   000014   EF           MOV     A,R7
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000019   E9           MOV     A,R1
   \   00001A   F5..         MOV     ?V0,A
    380          
    381            if ( status == ZSuccess )
   \   00001C   E5..         MOV     A,?V0
   \   00001E   702D         JNZ     ??ZDSecMgrAddrClear_0
    382            {
    383              AddrMgrEntry_t addrEntry;
    384          
    385              // Clear SECURITY User bit from the address manager
    386              addrEntry.user = ADDRMGR_USER_SECURITY;
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7402         MOV     A,#0x2
   \   000027   F0           MOVX    @DPTR,A
    387              addrEntry.index = entryAmi;
   \   000028   85..82       MOV     DPL,?XSP + 0
   \   00002B   85..83       MOV     DPH,?XSP + 1
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F8           MOV     R0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F9           MOV     R1,A
   \   000033   740D         MOV     A,#0xd
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E8           MOV     A,R0
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   E9           MOV     A,R1
   \   00003C   F0           MOVX    @DPTR,A
    388          
    389              if ( AddrMgrEntryRelease( &addrEntry ) != TRUE )
   \   00003D                ; Setup parameters for call to function AddrMgrEntryRelease
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?XSTACK_DISP101_8
   \   000042   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   \   000045   E9           MOV     A,R1
   \   000046   6401         XRL     A,#0x1
   \   000048   6003         JZ      ??ZDSecMgrAddrClear_0
    390              {
    391                // return failure results
    392                status = ZFailure;
   \   00004A   75..01       MOV     ?V0,#0x1
    393              }
    394            }
    395          
    396            return status;
   \                     ??ZDSecMgrAddrClear_0:
   \   00004D   A9..         MOV     R1,?V0
   \   00004F   740F         MOV     A,#0xf
   \   000051   12....       LCALL   ?DEALLOC_XSTACK8
   \   000054   7F01         MOV     R7,#0x1
   \   000056   02....       LJMP    ?BANKED_LEAVE_XDATA
    397          }
    398          
    399          /******************************************************************************
    400           * @fn          ZDSecMgrEntryInit
    401           *
    402           * @brief       Initialize entry sub module
    403           *
    404           * @param       state - device initialization state
    405           *
    406           * @return      none
    407           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    408          void ZDSecMgrEntryInit(uint8 state)
   \                     ZDSecMgrEntryInit:
    409          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   89..         MOV     ?V0,R1
    410            if (ZDSecMgrEntries == NULL)
   \   000007   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
   \   00000F   E8           MOV     A,R0
   \   000010   49           ORL     A,R1
   \   000011   6003         JZ      $+5
   \   000013   02....       LJMP    ??ZDSecMgrEntryInit_0 & 0xFFFF
    411            {
    412              uint16 index;
    413          
    414              if ((ZDSecMgrEntries = osal_mem_alloc(sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)) == NULL)
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   7A0F         MOV     R2,#0xf
   \   000018   7B00         MOV     R3,#0x0
   \   00001A   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00001D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000020   EA           MOV     A,R2
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   EB           MOV     A,R3
   \   000024   F0           MOVX    @DPTR,A
   \   000025   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   E8           MOV     A,R0
   \   00002E   49           ORL     A,R1
   \   00002F   6077         JZ      ??ZDSecMgrEntryInit_1
    415              {
    416                return;
    417              }
    418          
    419              for (index = 0; index < ZDSECMGR_ENTRY_MAX; index++)
   \   000031   7E00         MOV     R6,#0x0
   \   000033   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryInit_2:
   \   000035   C3           CLR     C
   \   000036   EE           MOV     A,R6
   \   000037   9403         SUBB    A,#0x3
   \   000039   EF           MOV     A,R7
   \   00003A   9400         SUBB    A,#0x0
   \   00003C   5063         JNC     ??ZDSecMgrEntryInit_0
    420              {
    421                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \   00003E   EE           MOV     A,R6
   \   00003F   F8           MOV     R0,A
   \   000040   EF           MOV     A,R7
   \   000041   F9           MOV     R1,A
   \   000042   E8           MOV     A,R0
   \   000043   75F005       MOV     B,#0x5
   \   000046   A4           MUL     AB
   \   000047   C8           XCH     A,R0
   \   000048   AAF0         MOV     R2,B
   \   00004A   75F000       MOV     B,#0x0
   \   00004D   A4           MUL     AB
   \   00004E   2A           ADD     A,R2
   \   00004F   FA           MOV     R2,A
   \   000050   75F005       MOV     B,#0x5
   \   000053   E9           MOV     A,R1
   \   000054   A4           MUL     AB
   \   000055   2A           ADD     A,R2
   \   000056   F9           MOV     R1,A
   \   000057   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   28           ADD     A,R0
   \   00005C   FA           MOV     R2,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   39           ADDC    A,R1
   \   000060   8A82         MOV     DPL,R2
   \   000062   F583         MOV     DPH,A
   \   000064   74FE         MOV     A,#-0x2
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   74FF         MOV     A,#-0x1
   \   00006A   F0           MOVX    @DPTR,A
    422          
    423                ZDSecMgrEntries[index].keyNvId = SEC_NO_KEY_NV_ID;
   \   00006B   EE           MOV     A,R6
   \   00006C   F8           MOV     R0,A
   \   00006D   EF           MOV     A,R7
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   75F005       MOV     B,#0x5
   \   000073   A4           MUL     AB
   \   000074   C8           XCH     A,R0
   \   000075   AAF0         MOV     R2,B
   \   000077   75F000       MOV     B,#0x0
   \   00007A   A4           MUL     AB
   \   00007B   2A           ADD     A,R2
   \   00007C   FA           MOV     R2,A
   \   00007D   75F005       MOV     B,#0x5
   \   000080   E9           MOV     A,R1
   \   000081   A4           MUL     AB
   \   000082   2A           ADD     A,R2
   \   000083   F9           MOV     R1,A
   \   000084   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000087   E0           MOVX    A,@DPTR
   \   000088   28           ADD     A,R0
   \   000089   FA           MOV     R2,A
   \   00008A   A3           INC     DPTR
   \   00008B   E0           MOVX    A,@DPTR
   \   00008C   39           ADDC    A,R1
   \   00008D   8A82         MOV     DPL,R2
   \   00008F   F583         MOV     DPH,A
   \   000091   A3           INC     DPTR
   \   000092   A3           INC     DPTR
   \   000093   7400         MOV     A,#0x0
   \   000095   F0           MOVX    @DPTR,A
   \   000096   A3           INC     DPTR
   \   000097   7400         MOV     A,#0x0
   \   000099   F0           MOVX    @DPTR,A
    424              }
   \   00009A   0E           INC     R6
   \   00009B   EE           MOV     A,R6
   \   00009C   7097         JNZ     ??ZDSecMgrEntryInit_2
   \   00009E   0F           INC     R7
   \   00009F   8094         SJMP    ??ZDSecMgrEntryInit_2
    425            }
    426          
    427          #if defined NV_RESTORE
    428            if (state == ZDO_INITDEV_RESTORED_NETWORK_STATE)
   \                     ??ZDSecMgrEntryInit_0:
   \   0000A1   E5..         MOV     A,?V0
   \   0000A3   7003         JNZ     ??ZDSecMgrEntryInit_1
    429            {
    430              ZDSecMgrRestoreFromNV();
   \   0000A5                ; Setup parameters for call to function ZDSecMgrRestoreFromNV
   \   0000A5   12....       LCALL   `??ZDSecMgrRestoreFromNV::?relay`; Banked call to: ZDSecMgrRestoreFromNV
    431            }
    432          #else
    433            (void)state;
    434          #endif
    435          }
   \                     ??ZDSecMgrEntryInit_1:
   \   0000A8   7F01         MOV     R7,#0x1
   \   0000AA   02....       LJMP    ?BANKED_LEAVE_XDATA
    436          
    437          /******************************************************************************
    438           * @fn          ZDSecMgrEntryLookup
    439           *
    440           * @brief       Lookup entry index using specified NWK address.
    441           *
    442           * @param       nwkAddr - [in] NWK address
    443           * @param       entry   - [out] valid entry
    444           *
    445           * @return      ZStatus_t
    446           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    447          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    448          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
    449            uint16         index;
    450            AddrMgrEntry_t addrMgrEntry;
    451          
    452            // initialize results
    453            *entry = NULL;
   \   000012   85..82       MOV     DPL,?V0
   \   000015   85..83       MOV     DPH,?V1
   \   000018   7400         MOV     A,#0x0
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   A3           INC     DPTR
   \   00001C   7400         MOV     A,#0x0
   \   00001E   F0           MOVX    @DPTR,A
    454          
    455            // verify data is available
    456            if ( ZDSecMgrEntries != NULL )
   \   00001F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   E8           MOV     A,R0
   \   000028   49           ORL     A,R1
   \   000029   7003         JNZ     $+5
   \   00002B   02....       LJMP    ??ZDSecMgrEntryLookup_0 & 0xFFFF
    457            {
    458              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   00002E   85..82       MOV     DPL,?XSP + 0
   \   000031   85..83       MOV     DPH,?XSP + 1
   \   000034   7402         MOV     A,#0x2
   \   000036   F0           MOVX    @DPTR,A
    459              addrMgrEntry.nwkAddr = nwkAddr;
   \   000037   7401         MOV     A,#0x1
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E5..         MOV     A,?V2
   \   00003E   F0           MOVX    @DPTR,A
   \   00003F   A3           INC     DPTR
   \   000040   E5..         MOV     A,?V3
   \   000042   F0           MOVX    @DPTR,A
    460          
    461              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \   000043                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000043   AA..         MOV     R2,?XSP + 0
   \   000045   AB..         MOV     R3,?XSP + 1
   \   000047   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   00004A   E9           MOV     A,R1
   \   00004B   6401         XRL     A,#0x1
   \   00004D   707F         JNZ     ??ZDSecMgrEntryLookup_0
    462              {
    463                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00004F   7E00         MOV     R6,#0x0
   \   000051   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryLookup_1:
   \   000053   C3           CLR     C
   \   000054   EE           MOV     A,R6
   \   000055   9403         SUBB    A,#0x3
   \   000057   EF           MOV     A,R7
   \   000058   9400         SUBB    A,#0x0
   \   00005A   5072         JNC     ??ZDSecMgrEntryLookup_0
    464                {
    465                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \   00005C   740B         MOV     A,#0xb
   \   00005E   12....       LCALL   ?XSTACK_DISP0_8
   \   000061   E0           MOVX    A,@DPTR
   \   000062   FA           MOV     R2,A
   \   000063   A3           INC     DPTR
   \   000064   E0           MOVX    A,@DPTR
   \   000065   FB           MOV     R3,A
   \   000066   EE           MOV     A,R6
   \   000067   F8           MOV     R0,A
   \   000068   EF           MOV     A,R7
   \   000069   F9           MOV     R1,A
   \   00006A   E8           MOV     A,R0
   \   00006B   75F005       MOV     B,#0x5
   \   00006E   A4           MUL     AB
   \   00006F   C8           XCH     A,R0
   \   000070   ACF0         MOV     R4,B
   \   000072   75F000       MOV     B,#0x0
   \   000075   A4           MUL     AB
   \   000076   2C           ADD     A,R4
   \   000077   FC           MOV     R4,A
   \   000078   75F005       MOV     B,#0x5
   \   00007B   E9           MOV     A,R1
   \   00007C   A4           MUL     AB
   \   00007D   2C           ADD     A,R4
   \   00007E   F9           MOV     R1,A
   \   00007F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000082   E0           MOVX    A,@DPTR
   \   000083   28           ADD     A,R0
   \   000084   FC           MOV     R4,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   39           ADDC    A,R1
   \   000088   8C82         MOV     DPL,R4
   \   00008A   F583         MOV     DPH,A
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   6A           XRL     A,R2
   \   00008E   7003         JNZ     ??ZDSecMgrEntryLookup_2
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookup_2:
   \   000093   7032         JNZ     ??ZDSecMgrEntryLookup_3
    466                  {
    467                    // return successful results
    468                    *entry = &ZDSecMgrEntries[index];
   \   000095   EE           MOV     A,R6
   \   000096   F8           MOV     R0,A
   \   000097   EF           MOV     A,R7
   \   000098   F9           MOV     R1,A
   \   000099   E8           MOV     A,R0
   \   00009A   75F005       MOV     B,#0x5
   \   00009D   A4           MUL     AB
   \   00009E   C8           XCH     A,R0
   \   00009F   AAF0         MOV     R2,B
   \   0000A1   75F000       MOV     B,#0x0
   \   0000A4   A4           MUL     AB
   \   0000A5   2A           ADD     A,R2
   \   0000A6   FA           MOV     R2,A
   \   0000A7   75F005       MOV     B,#0x5
   \   0000AA   E9           MOV     A,R1
   \   0000AB   A4           MUL     AB
   \   0000AC   2A           ADD     A,R2
   \   0000AD   F9           MOV     R1,A
   \   0000AE   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   28           ADD     A,R0
   \   0000B3   F8           MOV     R0,A
   \   0000B4   A3           INC     DPTR
   \   0000B5   E0           MOVX    A,@DPTR
   \   0000B6   39           ADDC    A,R1
   \   0000B7   F9           MOV     R1,A
   \   0000B8   85..82       MOV     DPL,?V0
   \   0000BB   85..83       MOV     DPH,?V1
   \   0000BE   E8           MOV     A,R0
   \   0000BF   F0           MOVX    @DPTR,A
   \   0000C0   A3           INC     DPTR
   \   0000C1   E9           MOV     A,R1
   \   0000C2   F0           MOVX    @DPTR,A
    469          
    470                    // break from loop
    471                    return ZSuccess;
   \   0000C3   7900         MOV     R1,#0x0
   \   0000C5   8009         SJMP    ??ZDSecMgrEntryLookup_4
    472                  }
    473                }
   \                     ??ZDSecMgrEntryLookup_3:
   \   0000C7   0E           INC     R6
   \   0000C8   EE           MOV     A,R6
   \   0000C9   7088         JNZ     ??ZDSecMgrEntryLookup_1
   \   0000CB   0F           INC     R7
   \   0000CC   8085         SJMP    ??ZDSecMgrEntryLookup_1
    474              }
    475            }
    476          
    477            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookup_0:
   \   0000CE   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookup_4:
   \   0000D0   740D         MOV     A,#0xd
   \   0000D2   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D5   7F04         MOV     R7,#0x4
   \   0000D7   02....       LJMP    ?BANKED_LEAVE_XDATA
    478          }
    479          
    480          /******************************************************************************
    481           * @fn          ZDSecMgrEntryLookupAMI
    482           *
    483           * @brief       Lookup entry using specified address index
    484           *
    485           * @param       ami   - [in] Address Manager index
    486           * @param       entry - [out] valid entry
    487           *
    488           * @return      ZStatus_t
    489           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    490          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    491          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    492            uint16 index;
    493          
    494            // initialize results
    495            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    496          
    497            // verify data is available
    498            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   607D         JZ      ??ZDSecMgrEntryLookupAMI_0
    499            {
    500              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000020   7A00         MOV     R2,#0x0
   \   000022   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   000024   C3           CLR     C
   \   000025   EA           MOV     A,R2
   \   000026   9403         SUBB    A,#0x3
   \   000028   EB           MOV     A,R3
   \   000029   9400         SUBB    A,#0x0
   \   00002B   5070         JNC     ??ZDSecMgrEntryLookupAMI_0
    501              {
    502                if ( ZDSecMgrEntries[index].ami == ami )
   \   00002D   EA           MOV     A,R2
   \   00002E   F8           MOV     R0,A
   \   00002F   EB           MOV     A,R3
   \   000030   F9           MOV     R1,A
   \   000031   E8           MOV     A,R0
   \   000032   75F005       MOV     B,#0x5
   \   000035   A4           MUL     AB
   \   000036   C8           XCH     A,R0
   \   000037   85F0..       MOV     ?V0,B
   \   00003A   75F000       MOV     B,#0x0
   \   00003D   A4           MUL     AB
   \   00003E   25..         ADD     A,?V0
   \   000040   F5..         MOV     ?V0,A
   \   000042   75F005       MOV     B,#0x5
   \   000045   E9           MOV     A,R1
   \   000046   A4           MUL     AB
   \   000047   25..         ADD     A,?V0
   \   000049   F9           MOV     R1,A
   \   00004A   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   28           ADD     A,R0
   \   00004F   F5..         MOV     ?V0,A
   \   000051   A3           INC     DPTR
   \   000052   E0           MOVX    A,@DPTR
   \   000053   39           ADDC    A,R1
   \   000054   85..82       MOV     DPL,?V0
   \   000057   F583         MOV     DPH,A
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   6E           XRL     A,R6
   \   00005B   7003         JNZ     ??ZDSecMgrEntryLookupAMI_2
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   000060   7034         JNZ     ??ZDSecMgrEntryLookupAMI_3
    503                {
    504                  // return successful results
    505                  *entry = &ZDSecMgrEntries[index];
   \   000062   EA           MOV     A,R2
   \   000063   F8           MOV     R0,A
   \   000064   EB           MOV     A,R3
   \   000065   F9           MOV     R1,A
   \   000066   E8           MOV     A,R0
   \   000067   75F005       MOV     B,#0x5
   \   00006A   A4           MUL     AB
   \   00006B   C8           XCH     A,R0
   \   00006C   85F0..       MOV     ?V0,B
   \   00006F   75F000       MOV     B,#0x0
   \   000072   A4           MUL     AB
   \   000073   25..         ADD     A,?V0
   \   000075   F5..         MOV     ?V0,A
   \   000077   75F005       MOV     B,#0x5
   \   00007A   E9           MOV     A,R1
   \   00007B   A4           MUL     AB
   \   00007C   25..         ADD     A,?V0
   \   00007E   F9           MOV     R1,A
   \   00007F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000082   E0           MOVX    A,@DPTR
   \   000083   28           ADD     A,R0
   \   000084   F8           MOV     R0,A
   \   000085   A3           INC     DPTR
   \   000086   E0           MOVX    A,@DPTR
   \   000087   39           ADDC    A,R1
   \   000088   F9           MOV     R1,A
   \   000089   8C82         MOV     DPL,R4
   \   00008B   8D83         MOV     DPH,R5
   \   00008D   E8           MOV     A,R0
   \   00008E   F0           MOVX    @DPTR,A
   \   00008F   A3           INC     DPTR
   \   000090   E9           MOV     A,R1
   \   000091   F0           MOVX    @DPTR,A
    506          
    507                  // break from loop
    508                  return ZSuccess;
   \   000092   7900         MOV     R1,#0x0
   \   000094   8009         SJMP    ??ZDSecMgrEntryLookupAMI_4
    509                }
    510              }
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   000096   0A           INC     R2
   \   000097   EA           MOV     A,R2
   \   000098   708A         JNZ     ??ZDSecMgrEntryLookupAMI_1
   \   00009A   0B           INC     R3
   \   00009B   8087         SJMP    ??ZDSecMgrEntryLookupAMI_1
    511            }
    512          
    513            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   00009D   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMI_4:
   \   00009F   7F01         MOV     R7,#0x1
   \   0000A1   02....       LJMP    ?BANKED_LEAVE_XDATA
    514          }
    515          
    516          /******************************************************************************
    517           * @fn          ZDSecMgrEntryLookupExt
    518           *
    519           * @brief       Lookup entry index using specified EXT address.
    520           *
    521           * @param       extAddr - [in] EXT address
    522           * @param       entry   - [out] valid entry
    523           *
    524           * @return      ZStatus_t
    525           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    526          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    527          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
    528            ZStatus_t status;
    529            uint16    ami;
    530          
    531            // initialize results
    532            *entry = NULL;
   \   000012   8E82         MOV     DPL,R6
   \   000014   8F83         MOV     DPH,R7
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
    533            status = ZNwkUnknownDevice;
   \   00001D   75..C8       MOV     ?V2,#-0x38
    534          
    535            // lookup address index
    536            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   000020   AC..         MOV     R4,?XSP + 0
   \   000022   AD..         MOV     R5,?XSP + 1
   \   000024   AA..         MOV     R2,?V0
   \   000026   AB..         MOV     R3,?V1
   \   000028   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   00002B   E9           MOV     A,R1
   \   00002C   7015         JNZ     ??ZDSecMgrEntryLookupExt_0
    537            {
    538              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   00002E                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00002E   EE           MOV     A,R6
   \   00002F   FC           MOV     R4,A
   \   000030   EF           MOV     A,R7
   \   000031   FD           MOV     R5,A
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   FB           MOV     R3,A
   \   00003D   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000040   E9           MOV     A,R1
   \   000041   F5..         MOV     ?V2,A
    539            }
    540          
    541            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   000043   A9..         MOV     R1,?V2
   \   000045   7402         MOV     A,#0x2
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   7F03         MOV     R7,#0x3
   \   00004C   02....       LJMP    ?BANKED_LEAVE_XDATA
    542          }
    543          
    544          /******************************************************************************
    545           * @fn          ZDSecMgrEntryLookupExtGetIndex
    546           *
    547           * @brief       Lookup entry index using specified EXT address.
    548           *
    549           * @param       extAddr - [in] EXT address
    550           * @param       entryIndex - [out] valid index to the entry table
    551           *
    552           * @return      ZStatus_t
    553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          ZStatus_t ZDSecMgrEntryLookupExtGetIndex( uint8* extAddr, ZDSecMgrEntry_t** entry, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupExtGetIndex:
    555          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7410         MOV     A,#0x10
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V1,A
    556            uint16 ami;
    557            uint16 index;
    558          
    559            // lookup address index
    560            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \   00001E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00001E   AC..         MOV     R4,?XSP + 0
   \   000020   AD..         MOV     R5,?XSP + 1
   \   000022   AA..         MOV     R2,?V4
   \   000024   AB..         MOV     R3,?V5
   \   000026   12....       LCALL   `??ZDSecMgrExtAddrLookup::?relay`; Banked call to: ZDSecMgrExtAddrLookup
   \   000029   E9           MOV     A,R1
   \   00002A   6003         JZ      $+5
   \   00002C   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    561            {
    562              // verify data is available
    563              if ( ZDSecMgrEntries != NULL )
   \   00002F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F8           MOV     R0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F9           MOV     R1,A
   \   000037   E8           MOV     A,R0
   \   000038   49           ORL     A,R1
   \   000039   7003         JNZ     $+5
   \   00003B   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    564              {
    565                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00003E   75..00       MOV     ?V2,#0x0
   \   000041   75..00       MOV     ?V3,#0x0
   \                     ??ZDSecMgrEntryLookupExtGetIndex_1:
   \   000044   C3           CLR     C
   \   000045   E5..         MOV     A,?V2
   \   000047   9403         SUBB    A,#0x3
   \   000049   E5..         MOV     A,?V3
   \   00004B   9400         SUBB    A,#0x0
   \   00004D   4003         JC      $+5
   \   00004F   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_0 & 0xFFFF
    566                {
    567                  if ( ZDSecMgrEntries[index].ami == ami )
   \   000052   A8..         MOV     R0,?V2
   \   000054   A9..         MOV     R1,?V3
   \   000056   E8           MOV     A,R0
   \   000057   75F005       MOV     B,#0x5
   \   00005A   A4           MUL     AB
   \   00005B   C8           XCH     A,R0
   \   00005C   AAF0         MOV     R2,B
   \   00005E   75F000       MOV     B,#0x0
   \   000061   A4           MUL     AB
   \   000062   2A           ADD     A,R2
   \   000063   FA           MOV     R2,A
   \   000064   75F005       MOV     B,#0x5
   \   000067   E9           MOV     A,R1
   \   000068   A4           MUL     AB
   \   000069   2A           ADD     A,R2
   \   00006A   F9           MOV     R1,A
   \   00006B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00006E   E0           MOVX    A,@DPTR
   \   00006F   28           ADD     A,R0
   \   000070   FA           MOV     R2,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   39           ADDC    A,R1
   \   000074   8A82         MOV     DPL,R2
   \   000076   F583         MOV     DPH,A
   \   000078   E0           MOVX    A,@DPTR
   \   000079   F8           MOV     R0,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   F9           MOV     R1,A
   \   00007D   85..82       MOV     DPL,?XSP + 0
   \   000080   85..83       MOV     DPH,?XSP + 1
   \   000083   E0           MOVX    A,@DPTR
   \   000084   68           XRL     A,R0
   \   000085   7003         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_2
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   69           XRL     A,R1
   \                     ??ZDSecMgrEntryLookupExtGetIndex_2:
   \   00008A   703D         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_3
    568                  {
    569                    // return successful results
    570                    *entry = &ZDSecMgrEntries[index];
   \   00008C   A8..         MOV     R0,?V2
   \   00008E   A9..         MOV     R1,?V3
   \   000090   E8           MOV     A,R0
   \   000091   75F005       MOV     B,#0x5
   \   000094   A4           MUL     AB
   \   000095   C8           XCH     A,R0
   \   000096   AAF0         MOV     R2,B
   \   000098   75F000       MOV     B,#0x0
   \   00009B   A4           MUL     AB
   \   00009C   2A           ADD     A,R2
   \   00009D   FA           MOV     R2,A
   \   00009E   75F005       MOV     B,#0x5
   \   0000A1   E9           MOV     A,R1
   \   0000A2   A4           MUL     AB
   \   0000A3   2A           ADD     A,R2
   \   0000A4   F9           MOV     R1,A
   \   0000A5   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   28           ADD     A,R0
   \   0000AA   F8           MOV     R0,A
   \   0000AB   A3           INC     DPTR
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   39           ADDC    A,R1
   \   0000AE   F9           MOV     R1,A
   \   0000AF   8E82         MOV     DPL,R6
   \   0000B1   8F83         MOV     DPH,R7
   \   0000B3   E8           MOV     A,R0
   \   0000B4   F0           MOVX    @DPTR,A
   \   0000B5   A3           INC     DPTR
   \   0000B6   E9           MOV     A,R1
   \   0000B7   F0           MOVX    @DPTR,A
    571                    *entryIndex = index;
   \   0000B8   85..82       MOV     DPL,?V0
   \   0000BB   85..83       MOV     DPH,?V1
   \   0000BE   E5..         MOV     A,?V2
   \   0000C0   F0           MOVX    @DPTR,A
   \   0000C1   A3           INC     DPTR
   \   0000C2   E5..         MOV     A,?V3
   \   0000C4   F0           MOVX    @DPTR,A
    572          
    573                    // break from loop
    574                    return ZSuccess;
   \   0000C5   7900         MOV     R1,#0x0
   \   0000C7   800D         SJMP    ??ZDSecMgrEntryLookupExtGetIndex_4
    575                  }
    576                }
   \                     ??ZDSecMgrEntryLookupExtGetIndex_3:
   \   0000C9   05..         INC     ?V2
   \   0000CB   E5..         MOV     A,?V2
   \   0000CD   7002         JNZ     ??ZDSecMgrEntryLookupExtGetIndex_5
   \   0000CF   05..         INC     ?V3
   \                     ??ZDSecMgrEntryLookupExtGetIndex_5:
   \   0000D1   02....       LJMP    ??ZDSecMgrEntryLookupExtGetIndex_1 & 0xFFFF
    577              }
    578            }
    579          
    580            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupExtGetIndex_0:
   \   0000D4   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupExtGetIndex_4:
   \   0000D6   7402         MOV     A,#0x2
   \   0000D8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000DB   7F06         MOV     R7,#0x6
   \   0000DD   02....       LJMP    ?BANKED_LEAVE_XDATA
    581          }
    582          
    583          /******************************************************************************
    584           * @fn          ZDSecMgrEntryLookupAMIGetIndex
    585           *
    586           * @brief       Lookup entry using specified address index
    587           *
    588           * @param       ami   - [in] Address Manager index
    589           * @param       entryIndex - [out] valid index to the entry table
    590           *
    591           * @return      ZStatus_t
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          ZStatus_t ZDSecMgrEntryLookupAMIGetIndex( uint16 ami, uint16* entryIndex )
   \                     ZDSecMgrEntryLookupAMIGetIndex:
    594          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    595            uint16 index;
    596          
    597            // verify data is available
    598            if ( ZDSecMgrEntries != NULL )
   \   000005   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000008   E0           MOVX    A,@DPTR
   \   000009   F8           MOV     R0,A
   \   00000A   A3           INC     DPTR
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   F9           MOV     R1,A
   \   00000D   E8           MOV     A,R0
   \   00000E   49           ORL     A,R1
   \   00000F   6056         JZ      ??ZDSecMgrEntryLookupAMIGetIndex_0
    599            {
    600              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000011   7E00         MOV     R6,#0x0
   \   000013   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_1:
   \   000015   C3           CLR     C
   \   000016   EE           MOV     A,R6
   \   000017   9403         SUBB    A,#0x3
   \   000019   EF           MOV     A,R7
   \   00001A   9400         SUBB    A,#0x0
   \   00001C   5049         JNC     ??ZDSecMgrEntryLookupAMIGetIndex_0
    601              {
    602                if ( ZDSecMgrEntries[index].ami == ami )
   \   00001E   EE           MOV     A,R6
   \   00001F   F8           MOV     R0,A
   \   000020   EF           MOV     A,R7
   \   000021   F9           MOV     R1,A
   \   000022   E8           MOV     A,R0
   \   000023   75F005       MOV     B,#0x5
   \   000026   A4           MUL     AB
   \   000027   C8           XCH     A,R0
   \   000028   85F0..       MOV     ?V0,B
   \   00002B   75F000       MOV     B,#0x0
   \   00002E   A4           MUL     AB
   \   00002F   25..         ADD     A,?V0
   \   000031   F5..         MOV     ?V0,A
   \   000033   75F005       MOV     B,#0x5
   \   000036   E9           MOV     A,R1
   \   000037   A4           MUL     AB
   \   000038   25..         ADD     A,?V0
   \   00003A   F9           MOV     R1,A
   \   00003B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   28           ADD     A,R0
   \   000040   F5..         MOV     ?V0,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   39           ADDC    A,R1
   \   000045   85..82       MOV     DPL,?V0
   \   000048   F583         MOV     DPH,A
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   6A           XRL     A,R2
   \   00004C   7003         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_2
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   6B           XRL     A,R3
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_2:
   \   000051   700D         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_3
    603                {
    604                  // return successful results
    605                  *entryIndex = index;
   \   000053   8C82         MOV     DPL,R4
   \   000055   8D83         MOV     DPH,R5
   \   000057   EE           MOV     A,R6
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   EF           MOV     A,R7
   \   00005B   F0           MOVX    @DPTR,A
    606          
    607                  // break from loop
    608                  return ZSuccess;
   \   00005C   7900         MOV     R1,#0x0
   \   00005E   8009         SJMP    ??ZDSecMgrEntryLookupAMIGetIndex_4
    609                }
    610              }
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_3:
   \   000060   0E           INC     R6
   \   000061   EE           MOV     A,R6
   \   000062   70B1         JNZ     ??ZDSecMgrEntryLookupAMIGetIndex_1
   \   000064   0F           INC     R7
   \   000065   80AE         SJMP    ??ZDSecMgrEntryLookupAMIGetIndex_1
    611            }
    612          
    613            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_0:
   \   000067   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryLookupAMIGetIndex_4:
   \   000069   7F01         MOV     R7,#0x1
   \   00006B   02....       LJMP    ?BANKED_LEAVE_XDATA
    614          }
    615          
    616          /******************************************************************************
    617           * @fn          ZDSecMgrEntryFree
    618           *
    619           * @brief       Free entry.
    620           *
    621           * @param       entry - [in] valid entry
    622           *
    623           * @return      ZStatus_t
    624           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    625          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
    626          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    627            APSME_LinkKeyData_t   *pApsLinkKey = NULL;
   \   00000E   75..00       MOV     ?V2,#0x0
   \   000011   75..00       MOV     ?V3,#0x0
    628          
    629          #if defined ( NV_RESTORE )
    630            ZStatus_t status;
    631            uint16 entryIndex;
    632          
    633            status = ZDSecMgrEntryLookupAMIGetIndex( entry->ami, &entryIndex );
   \   000014                ; Setup parameters for call to function ZDSecMgrEntryLookupAMIGetIndex
   \   000014   AC..         MOV     R4,?XSP + 0
   \   000016   AD..         MOV     R5,?XSP + 1
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FA           MOV     R2,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   `??ZDSecMgrEntryLookupAMIGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupAMIGetIndex
   \   000024   E9           MOV     A,R1
   \   000025   F5..         MOV     ?V0,A
    634          #endif
    635          
    636            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000027                ; Setup parameters for call to function osal_mem_alloc
   \   000027   7A18         MOV     R2,#0x18
   \   000029   7B00         MOV     R3,#0x0
   \   00002B   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00002E   8A..         MOV     ?V4,R2
   \   000030   8B..         MOV     ?V5,R3
   \   000032   85....       MOV     ?V2,?V4
   \   000035   85....       MOV     ?V3,?V5
    637          
    638            if (pApsLinkKey != NULL)
   \   000038   E5..         MOV     A,?V2
   \   00003A   45..         ORL     A,?V3
   \   00003C   6049         JZ      ??ZDSecMgrEntryFree_0
    639            {
    640              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00003E                ; Setup parameters for call to function osal_memset
   \   00003E   7C18         MOV     R4,#0x18
   \   000040   7D00         MOV     R5,#0x0
   \   000042   7900         MOV     R1,#0x0
   \   000044   AA..         MOV     R2,?V2
   \   000046   AB..         MOV     R3,?V3
   \   000048   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    641          
    642              // Clear the APS Link key in NV
    643              osal_nv_write( entry->keyNvId, 0,
    644                                  sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   00004B                ; Setup parameters for call to function osal_nv_write
   \   00004B   78..         MOV     R0,#?V2
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   75..18       MOV     ?V4,#0x18
   \   000053   75..00       MOV     ?V5,#0x0
   \   000056   78..         MOV     R0,#?V4
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7C00         MOV     R4,#0x0
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   8E82         MOV     DPL,R6
   \   000061   8F83         MOV     DPH,R7
   \   000063   A3           INC     DPTR
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   FA           MOV     R2,A
   \   000067   A3           INC     DPTR
   \   000068   E0           MOVX    A,@DPTR
   \   000069   FB           MOV     R3,A
   \   00006A   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00006D   7404         MOV     A,#0x4
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000072   E9           MOV     A,R1
    645          
    646              // set entry to invalid Key
    647              entry->keyNvId = SEC_NO_KEY_NV_ID;
   \   000073   8E82         MOV     DPL,R6
   \   000075   8F83         MOV     DPH,R7
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   7400         MOV     A,#0x0
   \   00007B   F0           MOVX    @DPTR,A
   \   00007C   A3           INC     DPTR
   \   00007D   7400         MOV     A,#0x0
   \   00007F   F0           MOVX    @DPTR,A
    648          
    649              osal_mem_free(pApsLinkKey);
   \   000080                ; Setup parameters for call to function osal_mem_free
   \   000080   AA..         MOV     R2,?V2
   \   000082   AB..         MOV     R3,?V3
   \   000084   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
    650            }
    651          
    652            // marking the entry as INVALID_NODE_ADDR
    653            entry->ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryFree_0:
   \   000087   8E82         MOV     DPL,R6
   \   000089   8F83         MOV     DPH,R7
   \   00008B   74FE         MOV     A,#-0x2
   \   00008D   F0           MOVX    @DPTR,A
   \   00008E   A3           INC     DPTR
   \   00008F   74FF         MOV     A,#-0x1
   \   000091   F0           MOVX    @DPTR,A
    654          
    655            // set to default value
    656            entry->authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000092   8E82         MOV     DPL,R6
   \   000094   8F83         MOV     DPH,R7
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   7400         MOV     A,#0x0
   \   00009C   F0           MOVX    @DPTR,A
    657          
    658          #if defined ( NV_RESTORE )
    659            if ( status == ZSuccess )
   \   00009D   E5..         MOV     A,?V0
   \   00009F   700E         JNZ     ??ZDSecMgrEntryFree_1
    660            {
    661              ZDSecMgrUpdateNV(entryIndex);
   \   0000A1                ; Setup parameters for call to function ZDSecMgrUpdateNV
   \   0000A1   85..82       MOV     DPL,?XSP + 0
   \   0000A4   85..83       MOV     DPH,?XSP + 1
   \   0000A7   E0           MOVX    A,@DPTR
   \   0000A8   FA           MOV     R2,A
   \   0000A9   A3           INC     DPTR
   \   0000AA   E0           MOVX    A,@DPTR
   \   0000AB   FB           MOV     R3,A
   \   0000AC   12....       LCALL   `??ZDSecMgrUpdateNV::?relay`; Banked call to: ZDSecMgrUpdateNV
    662            }
    663          #endif
    664          }
   \                     ??ZDSecMgrEntryFree_1:
   \   0000AF   7402         MOV     A,#0x2
   \   0000B1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B4   7F06         MOV     R7,#0x6
   \   0000B6   02....       LJMP    ?BANKED_LEAVE_XDATA
    665          
    666          /******************************************************************************
    667           * @fn          ZDSecMgrEntryNew
    668           *
    669           * @brief       Get a new entry.
    670           *
    671           * @param       entry - [out] valid entry
    672           *
    673           * @return      ZStatus_t
    674           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    675          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    676          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FC           MOV     R4,A
   \   000007   EB           MOV     A,R3
   \   000008   FD           MOV     R5,A
    677            uint16 index;
    678          
    679            // initialize results
    680            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   7400         MOV     A,#0x0
   \   00000F   F0           MOVX    @DPTR,A
   \   000010   A3           INC     DPTR
   \   000011   7400         MOV     A,#0x0
   \   000013   F0           MOVX    @DPTR,A
    681          
    682            // verify data is available
    683            if ( ZDSecMgrEntries != NULL )
   \   000014   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   E8           MOV     A,R0
   \   00001D   49           ORL     A,R1
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    684            {
    685              // find available entry
    686              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000023   7A00         MOV     R2,#0x0
   \   000025   7B00         MOV     R3,#0x0
   \                     ??ZDSecMgrEntryNew_1:
   \   000027   C3           CLR     C
   \   000028   EA           MOV     A,R2
   \   000029   9403         SUBB    A,#0x3
   \   00002B   EB           MOV     A,R3
   \   00002C   9400         SUBB    A,#0x0
   \   00002E   4003         JC      $+5
   \   000030   02....       LJMP    ??ZDSecMgrEntryNew_0 & 0xFFFF
    687              {
    688                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \   000033   EA           MOV     A,R2
   \   000034   F8           MOV     R0,A
   \   000035   EB           MOV     A,R3
   \   000036   F9           MOV     R1,A
   \   000037   E8           MOV     A,R0
   \   000038   75F005       MOV     B,#0x5
   \   00003B   A4           MUL     AB
   \   00003C   C8           XCH     A,R0
   \   00003D   AEF0         MOV     R6,B
   \   00003F   75F000       MOV     B,#0x0
   \   000042   A4           MUL     AB
   \   000043   2E           ADD     A,R6
   \   000044   FE           MOV     R6,A
   \   000045   75F005       MOV     B,#0x5
   \   000048   E9           MOV     A,R1
   \   000049   A4           MUL     AB
   \   00004A   2E           ADD     A,R6
   \   00004B   F9           MOV     R1,A
   \   00004C   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   28           ADD     A,R0
   \   000051   FE           MOV     R6,A
   \   000052   A3           INC     DPTR
   \   000053   E0           MOVX    A,@DPTR
   \   000054   39           ADDC    A,R1
   \   000055   8E82         MOV     DPL,R6
   \   000057   F583         MOV     DPH,A
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   64FE         XRL     A,#0xfe
   \   00005C   7004         JNZ     ??ZDSecMgrEntryNew_2
   \   00005E   A3           INC     DPTR
   \   00005F   E0           MOVX    A,@DPTR
   \   000060   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrEntryNew_2:
   \   000062   705D         JNZ     ??ZDSecMgrEntryNew_3
    689                {
    690                  // return successful result
    691                  *entry = &ZDSecMgrEntries[index];
   \   000064   EA           MOV     A,R2
   \   000065   F8           MOV     R0,A
   \   000066   EB           MOV     A,R3
   \   000067   F9           MOV     R1,A
   \   000068   E8           MOV     A,R0
   \   000069   75F005       MOV     B,#0x5
   \   00006C   A4           MUL     AB
   \   00006D   C8           XCH     A,R0
   \   00006E   AEF0         MOV     R6,B
   \   000070   75F000       MOV     B,#0x0
   \   000073   A4           MUL     AB
   \   000074   2E           ADD     A,R6
   \   000075   FE           MOV     R6,A
   \   000076   75F005       MOV     B,#0x5
   \   000079   E9           MOV     A,R1
   \   00007A   A4           MUL     AB
   \   00007B   2E           ADD     A,R6
   \   00007C   F9           MOV     R1,A
   \   00007D   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000080   E0           MOVX    A,@DPTR
   \   000081   28           ADD     A,R0
   \   000082   F8           MOV     R0,A
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   39           ADDC    A,R1
   \   000086   F9           MOV     R1,A
   \   000087   8C82         MOV     DPL,R4
   \   000089   8D83         MOV     DPH,R5
   \   00008B   E8           MOV     A,R0
   \   00008C   F0           MOVX    @DPTR,A
   \   00008D   A3           INC     DPTR
   \   00008E   E9           MOV     A,R1
   \   00008F   F0           MOVX    @DPTR,A
    692          
    693                  // Set the authentication option to default
    694                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   000090   EA           MOV     A,R2
   \   000091   F8           MOV     R0,A
   \   000092   EB           MOV     A,R3
   \   000093   F9           MOV     R1,A
   \   000094   E8           MOV     A,R0
   \   000095   75F005       MOV     B,#0x5
   \   000098   A4           MUL     AB
   \   000099   C8           XCH     A,R0
   \   00009A   AEF0         MOV     R6,B
   \   00009C   75F000       MOV     B,#0x0
   \   00009F   A4           MUL     AB
   \   0000A0   2E           ADD     A,R6
   \   0000A1   FE           MOV     R6,A
   \   0000A2   75F005       MOV     B,#0x5
   \   0000A5   E9           MOV     A,R1
   \   0000A6   A4           MUL     AB
   \   0000A7   2E           ADD     A,R6
   \   0000A8   F9           MOV     R1,A
   \   0000A9   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000AC   E0           MOVX    A,@DPTR
   \   0000AD   28           ADD     A,R0
   \   0000AE   FE           MOV     R6,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   39           ADDC    A,R1
   \   0000B2   8E82         MOV     DPL,R6
   \   0000B4   F583         MOV     DPH,A
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   A3           INC     DPTR
   \   0000BA   7400         MOV     A,#0x0
   \   0000BC   F0           MOVX    @DPTR,A
    695          
    696                  // break from loop
    697                  return ZSuccess;
   \   0000BD   7900         MOV     R1,#0x0
   \   0000BF   800A         SJMP    ??ZDSecMgrEntryNew_4
    698                }
    699              }
   \                     ??ZDSecMgrEntryNew_3:
   \   0000C1   0A           INC     R2
   \   0000C2   EA           MOV     A,R2
   \   0000C3   7001         JNZ     ??ZDSecMgrEntryNew_5
   \   0000C5   0B           INC     R3
   \                     ??ZDSecMgrEntryNew_5:
   \   0000C6   02....       LJMP    ??ZDSecMgrEntryNew_1 & 0xFFFF
    700            }
    701          
    702            return ZNwkUnknownDevice;
   \                     ??ZDSecMgrEntryNew_0:
   \   0000C9   79C8         MOV     R1,#-0x38
   \                     ??ZDSecMgrEntryNew_4:
   \   0000CB   7F01         MOV     R7,#0x1
   \   0000CD   02....       LJMP    ?BANKED_LEAVE_XDATA
    703          }
    704          
    705          /******************************************************************************
    706           * @fn          ZDSecMgrAppKeyGet
    707           *
    708           * @brief       get an APP key - option APP(MASTER or LINK) key
    709           *
    710           * @param       initNwkAddr - [in] NWK address of initiator device
    711           * @param       initExtAddr - [in] EXT address of initiator device
    712           * @param       partNwkAddr - [in] NWK address of partner device
    713           * @param       partExtAddr - [in] EXT address of partner device
    714           * @param       key         - [out] APP(MASTER or LINK) key
    715           * @param       keyType     - [out] APP(MASTER or LINK) key type
    716           *
    717           * @return      ZStatus_t
    718           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
    719          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
    720                                                           // to KEY_TYPE_APP_LINK since
    721                                                           // only specific requirement
    722                                                           // right now comes from SE profile
    723          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    724          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
    725                                       uint8*  initExtAddr,
    726                                       uint16  partNwkAddr,
    727                                       uint8*  partExtAddr,
    728                                       uint8** key,
    729                                       uint8*  keyType )
    730          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V2,R2
   \   000007   8B..         MOV     ?V3,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   \   00000D   7412         MOV     A,#0x12
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   88..         MOV     ?V0,R0
   \   000019   89..         MOV     ?V1,R1
   \   00001B   7414         MOV     A,#0x14
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   E0           MOVX    A,@DPTR
   \   000021   F8           MOV     R0,A
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \   000024   F9           MOV     R1,A
   \   000025   88..         MOV     ?V4,R0
   \   000027   89..         MOV     ?V5,R1
    731            // Intentionally unreferenced parameters
    732            (void)initNwkAddr;
    733            (void)initExtAddr;
    734            (void)partNwkAddr;
    735            (void)partExtAddr;
    736          
    737            //---------------------------------------------------------------------------
    738            // note:
    739            // should use a robust mechanism to generate keys, for example
    740            // combine EXT addresses and call a hash function
    741            //---------------------------------------------------------------------------
    742            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \   000029                ; Setup parameters for call to function SSP_GetTrueRand
   \   000029   85..82       MOV     DPL,?V0
   \   00002C   85..83       MOV     DPH,?V1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FB           MOV     R3,A
   \   000034   7910         MOV     R1,#0x10
   \   000036   12....       LCALL   `??SSP_GetTrueRand::?relay`; Banked call to: SSP_GetTrueRand
    743          
    744            *keyType = ZDSecMgrAppKeyType;
   \   000039   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   C0E0         PUSH    A
   \   00003F   85..82       MOV     DPL,?V4
   \   000042   85..83       MOV     DPH,?V5
   \   000045   D0E0         POP     A
   \   000047   F0           MOVX    @DPTR,A
    745          
    746            return ZSuccess;
   \   000048   7900         MOV     R1,#0x0
   \   00004A   7F06         MOV     R7,#0x6
   \   00004C   02....       LJMP    ?BANKED_LEAVE_XDATA
    747          }
    748          
    749          /******************************************************************************
    750           * @fn          ZDSecMgrAppKeyReq
    751           *
    752           * @brief       Process request for APP key between two devices.
    753           *
    754           * @param       device - [in] ZDO_RequestKeyInd_t, request info
    755           *
    756           * @return      none
    757           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    758          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
    759          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    760            APSME_TransportKeyReq_t req;
    761            uint8                   initExtAddr[Z_EXTADDR_LEN];
    762            uint16                  partNwkAddr;
    763            uint8                   key[SEC_KEY_LEN];
    764          
    765          
    766            // validate initiator and partner
    767            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
    768                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   2405         ADD     A,#0x5
   \   000015   FA           MOV     R2,A
   \   000016   E4           CLR     A
   \   000017   3F           ADDC    A,R7
   \   000018   FB           MOV     R3,A
   \   000019   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00001C   E9           MOV     A,R1
   \   00001D   6401         XRL     A,#0x1
   \   00001F   6003         JZ      $+5
   \   000021   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000024                ; Setup parameters for call to function APSME_LookupExtAddr
   \   000024   740F         MOV     A,#0xf
   \   000026   12....       LCALL   ?XSTACK_DISP102_8
   \   000029   8E82         MOV     DPL,R6
   \   00002B   8F83         MOV     DPH,R7
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   FB           MOV     R3,A
   \   000034   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   000037   E9           MOV     A,R1
   \   000038   6401         XRL     A,#0x1
   \   00003A   6003         JZ      $+5
   \   00003C   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
    769            {
    770              // point the key to some memory
    771              req.key = key;
   \   00003F   7417         MOV     A,#0x17
   \   000041   12....       LCALL   ?XSTACK_DISP100_8
   \   000044   7406         MOV     A,#0x6
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E8           MOV     A,R0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E9           MOV     A,R1
   \   00004D   F0           MOVX    @DPTR,A
    772          
    773              // get an APP key - option APP (MASTER or LINK) key
    774              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
    775                                      initExtAddr,
    776                                      partNwkAddr,
    777                                      ind->partExtAddr,
    778                                      &req.key,
    779                                      &req.keyType ) == ZSuccess )
   \   00004E                ; Setup parameters for call to function ZDSecMgrAppKeyGet
   \   00004E   7404         MOV     A,#0x4
   \   000050   12....       LCALL   ?XSTACK_DISP0_8
   \   000053   8582..       MOV     ?V0,DPL
   \   000056   8583..       MOV     ?V1,DPH
   \   000059   78..         MOV     R0,#?V0
   \   00005B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005E   7408         MOV     A,#0x8
   \   000060   12....       LCALL   ?XSTACK_DISP0_8
   \   000063   8582..       MOV     ?V0,DPL
   \   000066   8583..       MOV     ?V1,DPH
   \   000069   78..         MOV     R0,#?V0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006E   EE           MOV     A,R6
   \   00006F   2405         ADD     A,#0x5
   \   000071   F5..         MOV     ?V0,A
   \   000073   E4           CLR     A
   \   000074   3F           ADDC    A,R7
   \   000075   F5..         MOV     ?V1,A
   \   000077   78..         MOV     R0,#?V0
   \   000079   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007C   7406         MOV     A,#0x6
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000084   7417         MOV     A,#0x17
   \   000086   12....       LCALL   ?XSTACK_DISP102_8
   \   000089   8E82         MOV     DPL,R6
   \   00008B   8F83         MOV     DPH,R7
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   FA           MOV     R2,A
   \   000091   A3           INC     DPTR
   \   000092   E0           MOVX    A,@DPTR
   \   000093   FB           MOV     R3,A
   \   000094   12....       LCALL   `??ZDSecMgrAppKeyGet::?relay`; Banked call to: ZDSecMgrAppKeyGet
   \   000097   7408         MOV     A,#0x8
   \   000099   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009C   E9           MOV     A,R1
   \   00009D   6003         JZ      $+5
   \   00009F   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
    780              {
    781                // always secure
    782                req.nwkSecure = TRUE;
   \   0000A2   740C         MOV     A,#0xc
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   7401         MOV     A,#0x1
   \   0000A9   F0           MOVX    @DPTR,A
    783                req.apsSecure = TRUE;
   \   0000AA   740B         MOV     A,#0xb
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   7401         MOV     A,#0x1
   \   0000B1   F0           MOVX    @DPTR,A
    784                req.tunnel    = NULL;
   \   0000B2   740D         MOV     A,#0xd
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   7400         MOV     A,#0x0
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   A3           INC     DPTR
   \   0000BB   7400         MOV     A,#0x0
   \   0000BD   F0           MOVX    @DPTR,A
    785          
    786                // send key to initiator device
    787                req.dstAddr   = ind->srcAddr;
   \   0000BE   8E82         MOV     DPL,R6
   \   0000C0   8F83         MOV     DPH,R7
   \   0000C2   A3           INC     DPTR
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   F8           MOV     R0,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E0           MOVX    A,@DPTR
   \   0000C8   F9           MOV     R1,A
   \   0000C9   7402         MOV     A,#0x2
   \   0000CB   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CE   E8           MOV     A,R0
   \   0000CF   F0           MOVX    @DPTR,A
   \   0000D0   A3           INC     DPTR
   \   0000D1   E9           MOV     A,R1
   \   0000D2   F0           MOVX    @DPTR,A
    788                req.extAddr   = ind->partExtAddr;
   \   0000D3   EE           MOV     A,R6
   \   0000D4   2405         ADD     A,#0x5
   \   0000D6   F8           MOV     R0,A
   \   0000D7   E4           CLR     A
   \   0000D8   3F           ADDC    A,R7
   \   0000D9   F9           MOV     R1,A
   \   0000DA   7408         MOV     A,#0x8
   \   0000DC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DF   E8           MOV     A,R0
   \   0000E0   F0           MOVX    @DPTR,A
   \   0000E1   A3           INC     DPTR
   \   0000E2   E9           MOV     A,R1
   \   0000E3   F0           MOVX    @DPTR,A
    789                req.initiator = TRUE;
   \   0000E4   740A         MOV     A,#0xa
   \   0000E6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E9   7401         MOV     A,#0x1
   \   0000EB   F0           MOVX    @DPTR,A
    790                APSME_TransportKeyReq( &req );
   \   0000EC                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000EC   7402         MOV     A,#0x2
   \   0000EE   12....       LCALL   ?XSTACK_DISP101_8
   \   0000F1   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   0000F4   E9           MOV     A,R1
    791          
    792                // send key to partner device
    793                req.dstAddr   = partNwkAddr;
   \   0000F5   85..82       MOV     DPL,?XSP + 0
   \   0000F8   85..83       MOV     DPH,?XSP + 1
   \   0000FB   E0           MOVX    A,@DPTR
   \   0000FC   F8           MOV     R0,A
   \   0000FD   A3           INC     DPTR
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   F9           MOV     R1,A
   \   000100   7402         MOV     A,#0x2
   \   000102   12....       LCALL   ?XSTACK_DISP0_8
   \   000105   E8           MOV     A,R0
   \   000106   F0           MOVX    @DPTR,A
   \   000107   A3           INC     DPTR
   \   000108   E9           MOV     A,R1
   \   000109   F0           MOVX    @DPTR,A
    794                req.extAddr   = initExtAddr;
   \   00010A   740F         MOV     A,#0xf
   \   00010C   12....       LCALL   ?XSTACK_DISP100_8
   \   00010F   7408         MOV     A,#0x8
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   E8           MOV     A,R0
   \   000115   F0           MOVX    @DPTR,A
   \   000116   A3           INC     DPTR
   \   000117   E9           MOV     A,R1
   \   000118   F0           MOVX    @DPTR,A
    795                req.initiator = FALSE;
   \   000119   740A         MOV     A,#0xa
   \   00011B   12....       LCALL   ?XSTACK_DISP0_8
   \   00011E   7400         MOV     A,#0x0
   \   000120   F0           MOVX    @DPTR,A
    796          
    797                APSME_TransportKeyReq( &req );
   \   000121                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000121   7402         MOV     A,#0x2
   \   000123   12....       LCALL   ?XSTACK_DISP101_8
   \   000126   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   000129   E9           MOV     A,R1
    798          
    799                // clear copy of key in RAM
    800                osal_memset( key, 0x00, SEC_KEY_LEN);
   \   00012A                ; Setup parameters for call to function osal_memset
   \   00012A   7C10         MOV     R4,#0x10
   \   00012C   7D00         MOV     R5,#0x0
   \   00012E   7900         MOV     R1,#0x0
   \   000130   7417         MOV     A,#0x17
   \   000132   12....       LCALL   ?XSTACK_DISP101_8
   \   000135   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    801          
    802              }
    803            }
    804          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   000138   7427         MOV     A,#0x27
   \   00013A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00013D   7F02         MOV     R7,#0x2
   \   00013F   02....       LJMP    ?BANKED_LEAVE_XDATA
    805          
    806          /******************************************************************************
    807           * @fn          ZDSecMgrSendNwkKey
    808           *
    809           * @brief       Send NWK key to device joining network.
    810           *
    811           * @param       device - [in] ZDSecMgrDevice_t, device info
    812           *
    813           * @return      ZStatus_t
    814           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    815          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
    816          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 30
   \   000005   74E2         MOV     A,#-0x1e
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    817            ZStatus_t status;
    818            APSME_TransportKeyReq_t req;
    819            APSDE_FrameTunnel_t tunnel;
    820            nwkKeyDesc tmpKey;
    821          
    822            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F8           MOV     R0,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   F9           MOV     R1,A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   E8           MOV     A,R0
   \   00001E   F0           MOVX    @DPTR,A
   \   00001F   A3           INC     DPTR
   \   000020   E9           MOV     A,R1
   \   000021   F0           MOVX    @DPTR,A
    823            req.extAddr   = device->extAddr;
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F8           MOV     R0,A
   \   00002A   A3           INC     DPTR
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   F9           MOV     R1,A
   \   00002D   7406         MOV     A,#0x6
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   E8           MOV     A,R0
   \   000033   F0           MOVX    @DPTR,A
   \   000034   A3           INC     DPTR
   \   000035   E9           MOV     A,R1
   \   000036   F0           MOVX    @DPTR,A
    824          
    825            req.keyType   = KEY_TYPE_NWK;
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   7401         MOV     A,#0x1
   \   00003E   F0           MOVX    @DPTR,A
    826          
    827            // get the Active Key into a local variable
    828            if ( NLME_ReadNwkKeyInfo( 0, sizeof(tmpKey), &tmpKey,
    829                                     ZCD_NV_NWK_ACTIVE_KEY_INFO ) != SUCCESS )
   \   00003F                ; Setup parameters for call to function NLME_ReadNwkKeyInfo
   \   00003F   75..3A       MOV     ?V2,#0x3a
   \   000042   75..00       MOV     ?V3,#0x0
   \   000045   78..         MOV     R0,#?V2
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   740F         MOV     A,#0xf
   \   00004C   12....       LCALL   ?XSTACK_DISP100_8
   \   00004F   88..         MOV     ?V2,R0
   \   000051   89..         MOV     ?V3,R1
   \   000053   78..         MOV     R0,#?V2
   \   000055   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000058   7C11         MOV     R4,#0x11
   \   00005A   7D00         MOV     R5,#0x0
   \   00005C   7A00         MOV     R2,#0x0
   \   00005E   7B00         MOV     R3,#0x0
   \   000060   12....       LCALL   `??NLME_ReadNwkKeyInfo::?relay`; Banked call to: NLME_ReadNwkKeyInfo
   \   000063   7404         MOV     A,#0x4
   \   000065   12....       LCALL   ?DEALLOC_XSTACK8
   \   000068   E9           MOV     A,R1
   \   000069   600E         JZ      ??ZDSecMgrSendNwkKey_0
    830            {
    831              // set key data to all 0s if NV read fails
    832              osal_memset(&tmpKey, 0x00, sizeof(tmpKey));
   \   00006B                ; Setup parameters for call to function osal_memset
   \   00006B   7C11         MOV     R4,#0x11
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   7900         MOV     R1,#0x0
   \   000071   740D         MOV     A,#0xd
   \   000073   12....       LCALL   ?XSTACK_DISP101_8
   \   000076   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    833            }
    834          
    835            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
    836            {
    837              // set values
    838              req.keySeqNum = tmpKey.keySeqNum;
    839              req.key       = tmpKey.key;
    840          
    841              //devtag.pro.security.todo - make sure that if there is no link key the NWK
    842              //key isn't used to secure the frame at the APS layer -- since the receiving
    843              //device may not have a NWK key yet
    844              req.apsSecure = TRUE;
    845          
    846              // check if using secure hop to parent
    847              if ( device->parentAddr == NLME_GetShortAddr() )
    848              {
    849                req.nwkSecure = FALSE;
    850                req.tunnel    = NULL;
    851              }
    852              else
    853              {
    854                req.nwkSecure   = TRUE;
    855                req.tunnel      = &tunnel;
    856                req.tunnel->tna = device->parentAddr;
    857                req.tunnel->dea = device->extAddr;
    858              }
    859            }
    860            else
    861            {
    862              // default values
    863              //devtag.0604.verify
    864              req.nwkSecure = TRUE;
   \                     ??ZDSecMgrSendNwkKey_0:
   \   000079   740A         MOV     A,#0xa
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   7401         MOV     A,#0x1
   \   000080   F0           MOVX    @DPTR,A
    865              req.apsSecure = FALSE;
   \   000081   7409         MOV     A,#0x9
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   7400         MOV     A,#0x0
   \   000088   F0           MOVX    @DPTR,A
    866              req.tunnel    = NULL;
   \   000089   740B         MOV     A,#0xb
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   7400         MOV     A,#0x0
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   7400         MOV     A,#0x0
   \   000094   F0           MOVX    @DPTR,A
    867          
    868              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000095                ; Setup parameters for call to function NLME_GetShortAddr
   \   000095   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000098   8A..         MOV     ?V2,R2
   \   00009A   8B..         MOV     ?V3,R3
   \   00009C   A8..         MOV     R0,?V2
   \   00009E   A9..         MOV     R1,?V3
   \   0000A0   8E82         MOV     DPL,R6
   \   0000A2   8F83         MOV     DPH,R7
   \   0000A4   A3           INC     DPTR
   \   0000A5   A3           INC     DPTR
   \   0000A6   A3           INC     DPTR
   \   0000A7   A3           INC     DPTR
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   68           XRL     A,R0
   \   0000AA   7003         JNZ     ??ZDSecMgrSendNwkKey_1
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000AF   6018         JZ      ??ZDSecMgrSendNwkKey_2
    869              {
    870                req.dstAddr = device->parentAddr;
   \   0000B1   8E82         MOV     DPL,R6
   \   0000B3   8F83         MOV     DPH,R7
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   A3           INC     DPTR
   \   0000B8   A3           INC     DPTR
   \   0000B9   E0           MOVX    A,@DPTR
   \   0000BA   F8           MOV     R0,A
   \   0000BB   A3           INC     DPTR
   \   0000BC   E0           MOVX    A,@DPTR
   \   0000BD   F9           MOV     R1,A
   \   0000BE   85..82       MOV     DPL,?XSP + 0
   \   0000C1   85..83       MOV     DPH,?XSP + 1
   \   0000C4   E8           MOV     A,R0
   \   0000C5   F0           MOVX    @DPTR,A
   \   0000C6   A3           INC     DPTR
   \   0000C7   E9           MOV     A,R1
   \   0000C8   F0           MOVX    @DPTR,A
    871              }
    872          
    873              // send the real key
    874              if ( zgPreConfigKeys == FALSE )
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000C9   90....       MOV     DPTR,#zgPreConfigKeys
   \   0000CC   E0           MOVX    A,@DPTR
   \   0000CD   7049         JNZ     ??ZDSecMgrSendNwkKey_3
    875              {
    876                req.keySeqNum = tmpKey.keySeqNum;
   \   0000CF   740D         MOV     A,#0xd
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   C0E0         PUSH    A
   \   0000D7   7403         MOV     A,#0x3
   \   0000D9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DC   D0E0         POP     A
   \   0000DE   F0           MOVX    @DPTR,A
    877                req.key       = tmpKey.key;
   \   0000DF   740E         MOV     A,#0xe
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   A882         MOV     R0,DPL
   \   0000E6   A983         MOV     R1,DPH
   \   0000E8   7404         MOV     A,#0x4
   \   0000EA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000ED   E8           MOV     A,R0
   \   0000EE   F0           MOVX    @DPTR,A
   \   0000EF   A3           INC     DPTR
   \   0000F0   E9           MOV     A,R1
   \   0000F1   F0           MOVX    @DPTR,A
    878          
    879                // check if using secure hop to to parent
    880                if ( device->parentAddr == NLME_GetShortAddr() )
   \   0000F2                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000F2   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   0000F5   8A..         MOV     ?V2,R2
   \   0000F7   8B..         MOV     ?V3,R3
   \   0000F9   A8..         MOV     R0,?V2
   \   0000FB   A9..         MOV     R1,?V3
   \   0000FD   8E82         MOV     DPL,R6
   \   0000FF   8F83         MOV     DPH,R7
   \   000101   A3           INC     DPTR
   \   000102   A3           INC     DPTR
   \   000103   A3           INC     DPTR
   \   000104   A3           INC     DPTR
   \   000105   E0           MOVX    A,@DPTR
   \   000106   68           XRL     A,R0
   \   000107   7003         JNZ     ??ZDSecMgrSendNwkKey_4
   \   000109   A3           INC     DPTR
   \   00010A   E0           MOVX    A,@DPTR
   \   00010B   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_4:
   \   00010C   701E         JNZ     ??ZDSecMgrSendNwkKey_5
    881                {
    882                  req.nwkSecure = FALSE;
   \   00010E   740A         MOV     A,#0xa
   \   000110   12....       LCALL   ?XSTACK_DISP0_8
   \   000113   7400         MOV     A,#0x0
   \   000115   F0           MOVX    @DPTR,A
   \   000116   8014         SJMP    ??ZDSecMgrSendNwkKey_5
    883                }
    884              }
    885              else
    886              {
    887                // this is to send the all zero key when the NWK key has been preconfigured
    888                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   000118   7404         MOV     A,#0x4
   \   00011A   12....       LCALL   ?XSTACK_DISP0_8
   \   00011D   7400         MOV     A,#0x0
   \   00011F   F0           MOVX    @DPTR,A
   \   000120   A3           INC     DPTR
   \   000121   7400         MOV     A,#0x0
   \   000123   F0           MOVX    @DPTR,A
    889                req.keySeqNum = 0;
   \   000124   7403         MOV     A,#0x3
   \   000126   12....       LCALL   ?XSTACK_DISP0_8
   \   000129   7400         MOV     A,#0x0
   \   00012B   F0           MOVX    @DPTR,A
    890              }
    891            }
    892          
    893            status = APSME_TransportKeyReq( &req );
   \                     ??ZDSecMgrSendNwkKey_5:
   \   00012C                ; Setup parameters for call to function APSME_TransportKeyReq
   \   00012C   AA..         MOV     R2,?XSP + 0
   \   00012E   AB..         MOV     R3,?XSP + 1
   \   000130   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   000133   E9           MOV     A,R1
   \   000134   F5..         MOV     ?V0,A
    894          
    895            // clear copy of key in RAM before return
    896            osal_memset( &tmpKey, 0x00, sizeof(nwkKeyDesc) );
   \   000136                ; Setup parameters for call to function osal_memset
   \   000136   7C11         MOV     R4,#0x11
   \   000138   7D00         MOV     R5,#0x0
   \   00013A   7900         MOV     R1,#0x0
   \   00013C   740D         MOV     A,#0xd
   \   00013E   12....       LCALL   ?XSTACK_DISP101_8
   \   000141   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
    897          
    898            return status;
   \   000144   A9..         MOV     R1,?V0
   \   000146   741E         MOV     A,#0x1e
   \   000148   12....       LCALL   ?DEALLOC_XSTACK8
   \   00014B   7F04         MOV     R7,#0x4
   \   00014D   02....       LJMP    ?BANKED_LEAVE_XDATA
    899          }
    900          
    901          /******************************************************************************
    902           * @fn          ZDSecMgrDeviceRemoveByExtAddr
    903           *
    904           * @brief       Remove device entry by its ext address.
    905           *
    906           * @param       pAddr - pointer to the extended address
    907           *
    908           * @return      ZStatus_t
    909           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    910          ZStatus_t ZDSecMgrDeviceRemoveByExtAddr( uint8 *pAddr )
   \                     ZDSecMgrDeviceRemoveByExtAddr:
    911          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    912            ZDSecMgrEntry_t *pEntry;
    913            uint8           retValue;
    914          
    915            retValue = (uint8)ZDSecMgrEntryLookupExt( pAddr, &pEntry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   EE           MOV     A,R6
   \   000013   FA           MOV     R2,A
   \   000014   EF           MOV     A,R7
   \   000015   FB           MOV     R3,A
   \   000016   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   000019   E9           MOV     A,R1
   \   00001A   F5..         MOV     ?V0,A
    916          
    917            if( retValue == ZSuccess )
   \   00001C   E5..         MOV     A,?V0
   \   00001E   700E         JNZ     ??ZDSecMgrDeviceRemoveByExtAddr_0
    918            {
    919              // remove device from entry data
    920              ZDSecMgrEntryFree( pEntry );
   \   000020                ; Setup parameters for call to function ZDSecMgrEntryFree
   \   000020   85..82       MOV     DPL,?XSP + 0
   \   000023   85..83       MOV     DPH,?XSP + 1
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FB           MOV     R3,A
   \   00002B   12....       LCALL   `??ZDSecMgrEntryFree::?relay`; Banked call to: ZDSecMgrEntryFree
    921            }
    922          
    923            return retValue;
   \                     ??ZDSecMgrDeviceRemoveByExtAddr_0:
   \   00002E   A9..         MOV     R1,?V0
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
   \   000035   7F01         MOV     R7,#0x1
   \   000037   02....       LJMP    ?BANKED_LEAVE_XDATA
    924          }
    925          
    926          /******************************************************************************
    927           * @fn          ZDSecMgrDeviceRemove
    928           *
    929           * @brief       Remove device from network.
    930           *
    931           * @param       device - [in] ZDSecMgrDevice_t, device info
    932           *
    933           * @return      none
    934           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    935          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
    936          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    937            APSME_RemoveDeviceReq_t remDevReq;
    938            NLME_LeaveReq_t         leaveReq;
    939            associated_devices_t*   assoc;
    940          
    941            // check if parent, remove the device
    942            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000011   8A..         MOV     ?V2,R2
   \   000013   8B..         MOV     ?V3,R3
   \   000015   A8..         MOV     R0,?V2
   \   000017   A9..         MOV     R1,?V3
   \   000019   8E82         MOV     DPL,R6
   \   00001B   8F83         MOV     DPH,R7
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \   000022   68           XRL     A,R0
   \   000023   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \   000027   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_0:
   \   000028   6003         JZ      $+5
   \   00002A   02....       LJMP    ??ZDSecMgrDeviceRemove_1 & 0xFFFF
    943            {
    944              // this is the parent of the device
    945              leaveReq.extAddr        = device->extAddr;
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F8           MOV     R0,A
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   F9           MOV     R1,A
   \   000038   85..82       MOV     DPL,?XSP + 0
   \   00003B   85..83       MOV     DPH,?XSP + 1
   \   00003E   E8           MOV     A,R0
   \   00003F   F0           MOVX    @DPTR,A
   \   000040   A3           INC     DPTR
   \   000041   E9           MOV     A,R1
   \   000042   F0           MOVX    @DPTR,A
    946              leaveReq.removeChildren = FALSE;
   \   000043   7402         MOV     A,#0x2
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   7400         MOV     A,#0x0
   \   00004A   F0           MOVX    @DPTR,A
    947              leaveReq.rejoin         = FALSE;
   \   00004B   7403         MOV     A,#0x3
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   7400         MOV     A,#0x0
   \   000052   F0           MOVX    @DPTR,A
    948          
    949              // find child association
    950              assoc = AssocGetWithExt( device->extAddr );
   \   000053                ; Setup parameters for call to function AssocGetWithExt
   \   000053   8E82         MOV     DPL,R6
   \   000055   8F83         MOV     DPH,R7
   \   000057   A3           INC     DPTR
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   FA           MOV     R2,A
   \   00005B   A3           INC     DPTR
   \   00005C   E0           MOVX    A,@DPTR
   \   00005D   FB           MOV     R3,A
   \   00005E   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   000061   8A..         MOV     ?V2,R2
   \   000063   8B..         MOV     ?V3,R3
   \   000065   85....       MOV     ?V0,?V2
   \   000068   85....       MOV     ?V1,?V3
    951          
    952              if ( ( assoc != NULL                            ) &&
    953                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
    954                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00006B   E5..         MOV     A,?V0
   \   00006D   45..         ORL     A,?V1
   \   00006F   6049         JZ      ??ZDSecMgrDeviceRemove_2
   \   000071   85..82       MOV     DPL,?V0
   \   000074   85..83       MOV     DPH,?V1
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   603C         JZ      ??ZDSecMgrDeviceRemove_2
   \   00007E   85..82       MOV     DPL,?V0
   \   000081   85..83       MOV     DPH,?V1
   \   000084   A3           INC     DPTR
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   A3           INC     DPTR
   \   000088   E0           MOVX    A,@DPTR
   \   000089   C3           CLR     C
   \   00008A   9405         SUBB    A,#0x5
   \   00008C   502C         JNC     ??ZDSecMgrDeviceRemove_2
    955              {
    956                // check if associated device is authenticated
    957                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   00008E   85..82       MOV     DPL,?V0
   \   000091   85..83       MOV     DPH,?V1
   \   000094   A3           INC     DPTR
   \   000095   A3           INC     DPTR
   \   000096   A3           INC     DPTR
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   A2E3         MOV     C,0xE0 /* A   */.3
   \   00009C   500A         JNC     ??ZDSecMgrDeviceRemove_3
    958                {
    959                  leaveReq.silent = FALSE;
   \   00009E   7404         MOV     A,#0x4
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   7400         MOV     A,#0x0
   \   0000A5   F0           MOVX    @DPTR,A
   \   0000A6   8008         SJMP    ??ZDSecMgrDeviceRemove_4
    960                }
    961                else
    962                {
    963                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000A8   7404         MOV     A,#0x4
   \   0000AA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AD   7401         MOV     A,#0x1
   \   0000AF   F0           MOVX    @DPTR,A
    964                }
    965          
    966                NLME_LeaveReq( &leaveReq );
   \                     ??ZDSecMgrDeviceRemove_4:
   \   0000B0                ; Setup parameters for call to function NLME_LeaveReq
   \   0000B0   AA..         MOV     R2,?XSP + 0
   \   0000B2   AB..         MOV     R3,?XSP + 1
   \   0000B4   12....       LCALL   `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   0000B7   E9           MOV     A,R1
   \   0000B8   8074         SJMP    ??ZDSecMgrDeviceRemove_5
    967              }
    968              else if ( device->nwkAddr == NLME_GetShortAddr() )
   \                     ??ZDSecMgrDeviceRemove_2:
   \   0000BA                ; Setup parameters for call to function NLME_GetShortAddr
   \   0000BA   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   0000BD   8A..         MOV     ?V2,R2
   \   0000BF   8B..         MOV     ?V3,R3
   \   0000C1   A8..         MOV     R0,?V2
   \   0000C3   A9..         MOV     R1,?V3
   \   0000C5   8E82         MOV     DPL,R6
   \   0000C7   8F83         MOV     DPH,R7
   \   0000C9   E0           MOVX    A,@DPTR
   \   0000CA   68           XRL     A,R0
   \   0000CB   7003         JNZ     ??ZDSecMgrDeviceRemove_6
   \   0000CD   A3           INC     DPTR
   \   0000CE   E0           MOVX    A,@DPTR
   \   0000CF   69           XRL     A,R1
   \                     ??ZDSecMgrDeviceRemove_6:
   \   0000D0   705C         JNZ     ??ZDSecMgrDeviceRemove_5
    969              {
    970                // this is when ZC wants that ZR removes itself from the network
    971                leaveReq.extAddr = NULL;
   \   0000D2   85..82       MOV     DPL,?XSP + 0
   \   0000D5   85..83       MOV     DPH,?XSP + 1
   \   0000D8   7400         MOV     A,#0x0
   \   0000DA   F0           MOVX    @DPTR,A
   \   0000DB   A3           INC     DPTR
   \   0000DC   7400         MOV     A,#0x0
   \   0000DE   F0           MOVX    @DPTR,A
    972                leaveReq.silent = FALSE;
   \   0000DF   7404         MOV     A,#0x4
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   7400         MOV     A,#0x0
   \   0000E6   F0           MOVX    @DPTR,A
    973          
    974                NLME_LeaveReq( &leaveReq );
   \   0000E7                ; Setup parameters for call to function NLME_LeaveReq
   \   0000E7   AA..         MOV     R2,?XSP + 0
   \   0000E9   AB..         MOV     R3,?XSP + 1
   \   0000EB   12....       LCALL   `??NLME_LeaveReq::?relay`; Banked call to: NLME_LeaveReq
   \   0000EE   E9           MOV     A,R1
   \   0000EF   803D         SJMP    ??ZDSecMgrDeviceRemove_5
    975              }
    976            }
    977            else
    978            {
    979              // this is not the parent of the device
    980              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   0000F1   8E82         MOV     DPL,R6
   \   0000F3   8F83         MOV     DPH,R7
   \   0000F5   A3           INC     DPTR
   \   0000F6   A3           INC     DPTR
   \   0000F7   A3           INC     DPTR
   \   0000F8   A3           INC     DPTR
   \   0000F9   E0           MOVX    A,@DPTR
   \   0000FA   F8           MOV     R0,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   F9           MOV     R1,A
   \   0000FE   7405         MOV     A,#0x5
   \   000100   12....       LCALL   ?XSTACK_DISP0_8
   \   000103   E8           MOV     A,R0
   \   000104   F0           MOVX    @DPTR,A
   \   000105   A3           INC     DPTR
   \   000106   E9           MOV     A,R1
   \   000107   F0           MOVX    @DPTR,A
    981              remDevReq.childExtAddr = device->extAddr;
   \   000108   8E82         MOV     DPL,R6
   \   00010A   8F83         MOV     DPH,R7
   \   00010C   A3           INC     DPTR
   \   00010D   A3           INC     DPTR
   \   00010E   E0           MOVX    A,@DPTR
   \   00010F   F8           MOV     R0,A
   \   000110   A3           INC     DPTR
   \   000111   E0           MOVX    A,@DPTR
   \   000112   F9           MOV     R1,A
   \   000113   7407         MOV     A,#0x7
   \   000115   12....       LCALL   ?XSTACK_DISP0_8
   \   000118   E8           MOV     A,R0
   \   000119   F0           MOVX    @DPTR,A
   \   00011A   A3           INC     DPTR
   \   00011B   E9           MOV     A,R1
   \   00011C   F0           MOVX    @DPTR,A
    982          
    983          #if defined ( APP_TP2_TEST_MODE )
    984              if ( guTxApsSecON == TRUE )
    985              {
    986                remDevReq.apsSecure = TRUE;
    987              }
    988              else
    989              {
    990                remDevReq.apsSecure = FALSE;
    991              }
    992          
    993              APSME_RemoveDeviceReq( &remDevReq );
    994          
    995          #else
    996              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
    997              {
    998                // For ZG_GLOBAL_LINK_KEY the message has to be sent twice, one
    999                // APS un-encrypted and one APS encrypted, to make sure that it can interoperate
   1000                // with legacy Coordinator devices which can only handle one or the other.
   1001                if ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY )
   1002                {
   1003                  remDevReq.apsSecure = FALSE;
   1004          
   1005                  APSME_RemoveDeviceReq( &remDevReq );
   1006                }
   1007          
   1008                remDevReq.apsSecure = TRUE;
   1009          
   1010                APSME_RemoveDeviceReq( &remDevReq );
   1011              }
   1012              else
   1013              {
   1014                remDevReq.apsSecure = FALSE;
   \   00011D   7409         MOV     A,#0x9
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   7400         MOV     A,#0x0
   \   000124   F0           MOVX    @DPTR,A
   1015          
   1016                APSME_RemoveDeviceReq( &remDevReq );
   \   000125                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000125   7405         MOV     A,#0x5
   \   000127   12....       LCALL   ?XSTACK_DISP101_8
   \   00012A   12....       LCALL   `??APSME_RemoveDeviceReq::?relay`; Banked call to: APSME_RemoveDeviceReq
   \   00012D   E9           MOV     A,R1
   1017              }
   1018          #endif
   1019            }
   1020          }
   \                     ??ZDSecMgrDeviceRemove_5:
   \   00012E   740A         MOV     A,#0xa
   \   000130   12....       LCALL   ?DEALLOC_XSTACK8
   \   000133   7F04         MOV     R7,#0x4
   \   000135   02....       LJMP    ?BANKED_LEAVE_XDATA
   1021          
   1022          /******************************************************************************
   1023           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1024           *
   1025           * @brief       Decide whether device is allowed.
   1026           *
   1027           * @param       device - [in] ZDSecMgrDevice_t, device info
   1028           *
   1029           * @return      ZStatus_t
   1030           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1031          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1032          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1033            ZStatus_t status;
   1034          
   1035            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1036          
   1037            (void)device;  // Intentionally unreferenced parameter
   1038          
   1039            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1040            // the trust center to reject any newly joining devices by sending
   1041            // Remove-device to the parents.
   1042            if ( zgSecurePermitJoin == FALSE )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1043            {
   1044              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1045            }
   1046          
   1047          
   1048          
   1049          #if 0  // Taken out because the following functionality is only used for test
   1050                 // purpose. A more efficient (above) way is used. It can be put
   1051                 // back in if customers request for a white/black list feature.
   1052                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1053          
   1054            // The following code processes the device black list (stored device list)
   1055            // If the joining device is not part of the forbidden device list
   1056            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1057            // will send Remove-device and ban the device from joining.
   1058          
   1059            uint8     index;
   1060            uint8*    restricted;
   1061          
   1062            // Look through the stored device list - used for restricted devices
   1063            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1064            {
   1065              restricted = ZDSecMgrStoredDeviceList[index];
   1066          
   1067              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1068              {
   1069                // return as unknown device in regards to validation
   1070                status = ZNwkUnknownDevice;
   1071          
   1072                // break from loop
   1073                index = ZDSECMGR_STORED_DEVICES;
   1074              }
   1075            }
   1076          
   1077          #endif
   1078          
   1079            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   D083         POP     DPH
   \   000010   D082         POP     DPL
   \   000012   02....       LJMP    ?BRET
   1080          }
   1081          
   1082          /******************************************************************************
   1083           * @fn          ZDSecMgrDeviceValidate
   1084           *
   1085           * @brief       Decide whether device is allowed.
   1086           *
   1087           * @param       device - [in] ZDSecMgrDevice_t, device info
   1088           *
   1089           * @return      ZStatus_t
   1090           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1091          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1092          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1093            ZStatus_t status;
   1094          
   1095            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000009   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   6401         XRL     A,#0x1
   \   00000F   700C         JNZ     ??ZDSecMgrDeviceValidate_0
   1096            {
   1097              status = ZDSecMgrDeviceValidateRM( device );
   \   000011                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   EF           MOV     A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   `??ZDSecMgrDeviceValidateRM::?relay`; Banked call to: ZDSecMgrDeviceValidateRM
   \   000018   E9           MOV     A,R1
   \   000019   F5..         MOV     ?V0,A
   \   00001B   8003         SJMP    ??ZDSecMgrDeviceValidate_1
   1098            }
   1099            else
   1100            {
   1101              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00001D   75..C8       MOV     ?V0,#-0x38
   1102            }
   1103          
   1104            return status;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000020   A9..         MOV     R1,?V0
   \   000022   7F01         MOV     R7,#0x1
   \   000024   02....       LJMP    ?BANKED_LEAVE_XDATA
   1105          }
   1106          
   1107          /******************************************************************************
   1108           * @fn          ZDSecMgrDeviceJoin
   1109           *
   1110           * @brief       Try to join this device.
   1111           *
   1112           * @param       device - [in] ZDSecMgrDevice_t, device info
   1113           *
   1114           * @return      ZStatus_t
   1115           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1116          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   1117          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 14
   \   000005   74F2         MOV     A,#-0xe
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1118            ZStatus_t status = ZSuccess;
   \   00000E   75..00       MOV     ?V0,#0x0
   1119            uint16    ami;
   1120          
   1121            // attempt to validate device that joined/rejoined without security
   1122            if ( device->secure == FALSE )
   \   000011   8E82         MOV     DPL,R6
   \   000013   8F83         MOV     DPH,R7
   \   000015   A3           INC     DPTR
   \   000016   A3           INC     DPTR
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   700A         JNZ     ??ZDSecMgrDeviceJoin_0
   1123            {
   1124              status = ZDSecMgrDeviceValidate( device );
   \   00001E                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   00001E   EE           MOV     A,R6
   \   00001F   FA           MOV     R2,A
   \   000020   EF           MOV     A,R7
   \   000021   FB           MOV     R3,A
   \   000022   12....       LCALL   `??ZDSecMgrDeviceValidate::?relay`; Banked call to: ZDSecMgrDeviceValidate
   \   000025   E9           MOV     A,R1
   \   000026   F5..         MOV     ?V0,A
   1125            }
   1126          
   1127          #if 0  //chaokw panid
   1128          #if NODE_AUTH   //chaokw
   1129            if ( status == ZSuccess )
   1130            {
   1131              if (!Authlist_verify_device(device->nwkAddr, device->extAddr, 0, 0))
   1132                status = ZNwkUnknownDevice;
   1133            }
   1134          #endif
   1135          #endif
   1136          
   1137            if ( status == ZSuccess )
   \                     ??ZDSecMgrDeviceJoin_0:
   \   000028   E5..         MOV     A,?V0
   \   00002A   7064         JNZ     ??ZDSecMgrDeviceJoin_1
   1138            {
   1139              // Add the device to the address manager
   1140              ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00002C                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00002C   A8..         MOV     R0,?XSP + 0
   \   00002E   A9..         MOV     R1,?XSP + 1
   \   000030   88..         MOV     ?V2,R0
   \   000032   89..         MOV     ?V3,R1
   \   000034   78..         MOV     R0,#?V2
   \   000036   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000039   8E82         MOV     DPL,R6
   \   00003B   8F83         MOV     DPH,R7
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FC           MOV     R4,A
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   FD           MOV     R5,A
   \   000044   8E82         MOV     DPL,R6
   \   000046   8F83         MOV     DPH,R7
   \   000048   E0           MOVX    A,@DPTR
   \   000049   FA           MOV     R2,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FB           MOV     R3,A
   \   00004D   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000050   7402         MOV     A,#0x2
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   \   000055   E9           MOV     A,R1
   1141          
   1142              // Only send the key to devices that have not been authenticated
   1143              if ( ( device->devStatus & DEV_SEC_INIT_STATUS ) &&
   1144                   ( device->secure == FALSE ) )
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   A2E2         MOV     C,0xE0 /* A   */.2
   \   000064   5017         JNC     ??ZDSecMgrDeviceJoin_2
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   700A         JNZ     ??ZDSecMgrDeviceJoin_2
   1145              {
   1146                //send the nwk key data to the joining device
   1147                status = ZDSecMgrSendNwkKey( device );
   \   000073                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   `??ZDSecMgrSendNwkKey::?relay`; Banked call to: ZDSecMgrSendNwkKey
   \   00007A   E9           MOV     A,R1
   \   00007B   F5..         MOV     ?V0,A
   1148              }
   1149          
   1150              if ( status != ZSuccess )
   \                     ??ZDSecMgrDeviceJoin_2:
   \   00007D   E5..         MOV     A,?V0
   \   00007F   600F         JZ      ??ZDSecMgrDeviceJoin_1
   1151              {
   1152                ZDSecMgrAddrClear( device->extAddr );
   \   000081                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   000081   8E82         MOV     DPL,R6
   \   000083   8F83         MOV     DPH,R7
   \   000085   A3           INC     DPTR
   \   000086   A3           INC     DPTR
   \   000087   E0           MOVX    A,@DPTR
   \   000088   FA           MOV     R2,A
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   FB           MOV     R3,A
   \   00008C   12....       LCALL   `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
   \   00008F   E9           MOV     A,R1
   1153              }
   1154            }
   1155          
   1156            if ( status != ZSuccess )
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000090   E5..         MOV     A,?V0
   \   000092   6009         JZ      ??ZDSecMgrDeviceJoin_3
   1157            {
   1158              // not allowed or transport key failed, remove the device
   1159              ZDSecMgrDeviceRemove( device );
   \   000094                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000094   EE           MOV     A,R6
   \   000095   FA           MOV     R2,A
   \   000096   EF           MOV     A,R7
   \   000097   FB           MOV     R3,A
   \   000098   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   \   00009B   8073         SJMP    ??ZDSecMgrDeviceJoin_4
   1160            }
   1161            else
   1162            {
   1163              // Pass the Trust Center Device Indication to higher layer if callback registered
   1164              if (zdoCBFunc[ZDO_TC_DEVICE_CBID] != NULL )
   \                     ??ZDSecMgrDeviceJoin_3:
   \   00009D   90....       MOV     DPTR,#zdoCBFunc + 16
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   F8           MOV     R0,A
   \   0000A2   A3           INC     DPTR
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   F9           MOV     R1,A
   \   0000A5   E8           MOV     A,R0
   \   0000A6   49           ORL     A,R1
   \   0000A7   6067         JZ      ??ZDSecMgrDeviceJoin_4
   1165              {
   1166                ZDO_TC_Device_t dev;
   1167          
   1168                dev.nwkAddr = device->nwkAddr;
   \   0000A9   8E82         MOV     DPL,R6
   \   0000AB   8F83         MOV     DPH,R7
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   F8           MOV     R0,A
   \   0000AF   A3           INC     DPTR
   \   0000B0   E0           MOVX    A,@DPTR
   \   0000B1   F9           MOV     R1,A
   \   0000B2   7402         MOV     A,#0x2
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   E8           MOV     A,R0
   \   0000B8   F0           MOVX    @DPTR,A
   \   0000B9   A3           INC     DPTR
   \   0000BA   E9           MOV     A,R1
   \   0000BB   F0           MOVX    @DPTR,A
   1169                osal_memcpy( dev.extAddr, device->extAddr, Z_EXTADDR_LEN );
   \   0000BC                ; Setup parameters for call to function osal_memcpy
   \   0000BC   8E82         MOV     DPL,R6
   \   0000BE   8F83         MOV     DPH,R7
   \   0000C0   A3           INC     DPTR
   \   0000C1   A3           INC     DPTR
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   F5..         MOV     ?V4,A
   \   0000C5   A3           INC     DPTR
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   F5..         MOV     ?V5,A
   \   0000C9   75..00       MOV     ?V6,#0x0
   \   0000CC   78..         MOV     R0,#?V4
   \   0000CE   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000D1   7C08         MOV     R4,#0x8
   \   0000D3   7D00         MOV     R5,#0x0
   \   0000D5   7407         MOV     A,#0x7
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   AA82         MOV     R2,DPL
   \   0000DC   AB83         MOV     R3,DPH
   \   0000DE   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000E1   7403         MOV     A,#0x3
   \   0000E3   12....       LCALL   ?DEALLOC_XSTACK8
   1170                dev.parentAddr = device->parentAddr;
   \   0000E6   8E82         MOV     DPL,R6
   \   0000E8   8F83         MOV     DPH,R7
   \   0000EA   A3           INC     DPTR
   \   0000EB   A3           INC     DPTR
   \   0000EC   A3           INC     DPTR
   \   0000ED   A3           INC     DPTR
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   F8           MOV     R0,A
   \   0000F0   A3           INC     DPTR
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   F9           MOV     R1,A
   \   0000F3   740C         MOV     A,#0xc
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   E8           MOV     A,R0
   \   0000F9   F0           MOVX    @DPTR,A
   \   0000FA   A3           INC     DPTR
   \   0000FB   E9           MOV     A,R1
   \   0000FC   F0           MOVX    @DPTR,A
   1171          
   1172                zdoCBFunc[ZDO_TC_DEVICE_CBID]( (void*)&dev );
   \   0000FD                ; Setup parameters for indirect call
   \   0000FD   7402         MOV     A,#0x2
   \   0000FF   12....       LCALL   ?XSTACK_DISP101_8
   \   000102   90....       MOV     DPTR,#zdoCBFunc + 16
   \   000105   E0           MOVX    A,@DPTR
   \   000106   F8           MOV     R0,A
   \   000107   A3           INC     DPTR
   \   000108   E0           MOVX    A,@DPTR
   \   000109   F583         MOV     DPH,A
   \   00010B   8882         MOV     DPL,R0
   \   00010D   12....       LCALL   ?CALL_IND
   1173              }
   1174            }
   1175          
   1176            return status;
   \                     ??ZDSecMgrDeviceJoin_4:
   \   000110   A9..         MOV     R1,?V0
   \   000112   740E         MOV     A,#0xe
   \   000114   12....       LCALL   ?DEALLOC_XSTACK8
   \   000117   7F07         MOV     R7,#0x7
   \   000119   02....       LJMP    ?BANKED_LEAVE_XDATA
   1177          }
   1178          
   1179          /******************************************************************************
   1180           * @fn          ZDSecMgrDeviceJoinDirect
   1181           *
   1182           * @brief       Try to join this device as a direct child.
   1183           *
   1184           * @param       device - [in] ZDSecMgrDevice_t, device info
   1185           *
   1186           * @return      ZStatus_t
   1187           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1188          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   1189          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1190            ZStatus_t status;
   1191          
   1192            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   000010   E9           MOV     A,R1
   \   000011   F5..         MOV     ?V0,A
   1193          
   1194            if ( status == ZSuccess )
   \   000013   E5..         MOV     A,?V0
   \   000015   700F         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   1195            {
   1196              // set association status to authenticated
   1197              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000017                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000017                ; Setup parameters for call to function AssocGetWithShort
   \   000017   8E82         MOV     DPL,R6
   \   000019   8F83         MOV     DPH,R7
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   FA           MOV     R2,A
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   000023   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1198            }
   1199          
   1200            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   000026   A9..         MOV     R1,?V0
   \   000028   7F01         MOV     R7,#0x1
   \   00002A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1201          }
   1202          
   1203          /******************************************************************************
   1204           * @fn          ZDSecMgrDeviceJoinFwd
   1205           *
   1206           * @brief       Forward join to Trust Center.
   1207           *
   1208           * @param       device - [in] ZDSecMgrDevice_t, device info
   1209           *
   1210           * @return      ZStatus_t
   1211           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1212          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   1213          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1214            ZStatus_t               status;
   1215            APSME_UpdateDeviceReq_t req;
   1216          
   1217            // forward any joining device to the Trust Center -- the Trust Center will
   1218            // decide if the device is allowed to join
   1219            status = ZSuccess;
   \   00000E   75..00       MOV     ?V0,#0x0
   1220          
   1221            // forward authorization to the Trust Center
   1222            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   7400         MOV     A,#0x0
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   7400         MOV     A,#0x0
   \   00001D   F0           MOVX    @DPTR,A
   1223            req.devAddr    = device->nwkAddr;
   \   00001E   8E82         MOV     DPL,R6
   \   000020   8F83         MOV     DPH,R7
   \   000022   E0           MOVX    A,@DPTR
   \   000023   F8           MOV     R0,A
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   F9           MOV     R1,A
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   E8           MOV     A,R0
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   E9           MOV     A,R1
   \   000030   F0           MOVX    @DPTR,A
   1224            req.devExtAddr = device->extAddr;
   \   000031   8E82         MOV     DPL,R6
   \   000033   8F83         MOV     DPH,R7
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   E8           MOV     A,R0
   \   000042   F0           MOVX    @DPTR,A
   \   000043   A3           INC     DPTR
   \   000044   E9           MOV     A,R1
   \   000045   F0           MOVX    @DPTR,A
   1225          
   1226            // set security status, option for router to reject if policy set
   1227            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   A3           INC     DPTR
   \   000051   E0           MOVX    A,@DPTR
   \   000052   A2E7         MOV     C,0xE0 /* A   */.7
   \   000054   503D         JNC     ??ZDSecMgrDeviceJoinFwd_0
   1228            {
   1229              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   A3           INC     DPTR
   \   00005B   A3           INC     DPTR
   \   00005C   A3           INC     DPTR
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   A2E6         MOV     C,0xE0 /* A   */.6
   \   000064   5023         JNC     ??ZDSecMgrDeviceJoinFwd_1
   1230              {
   1231                if ( device->secure == TRUE )
   \   000066   8E82         MOV     DPL,R6
   \   000068   8F83         MOV     DPH,R7
   \   00006A   A3           INC     DPTR
   \   00006B   A3           INC     DPTR
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   6401         XRL     A,#0x1
   \   000073   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   1232                {
   1233                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000075   7406         MOV     A,#0x6
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   7404         MOV     A,#0x4
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   804F         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1234                }
   1235                else
   1236                {
   1237                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00007F   7406         MOV     A,#0x6
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   7407         MOV     A,#0x7
   \   000086   F0           MOVX    @DPTR,A
   \   000087   8045         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1238                }
   1239              }
   1240              else
   1241              {
   1242                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000089   7406         MOV     A,#0x6
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   7405         MOV     A,#0x5
   \   000090   F0           MOVX    @DPTR,A
   \   000091   803B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1243              }
   1244            }
   1245            else
   1246            {
   1247              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   A3           INC     DPTR
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   A2E6         MOV     C,0xE0 /* A   */.6
   \   0000A1   5023         JNC     ??ZDSecMgrDeviceJoinFwd_4
   1248              {
   1249                if ( device->secure == TRUE )
   \   0000A3   8E82         MOV     DPL,R6
   \   0000A5   8F83         MOV     DPH,R7
   \   0000A7   A3           INC     DPTR
   \   0000A8   A3           INC     DPTR
   \   0000A9   A3           INC     DPTR
   \   0000AA   A3           INC     DPTR
   \   0000AB   A3           INC     DPTR
   \   0000AC   A3           INC     DPTR
   \   0000AD   E0           MOVX    A,@DPTR
   \   0000AE   6401         XRL     A,#0x1
   \   0000B0   700A         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   1250                {
   1251                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   0000B2   7406         MOV     A,#0x6
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   7400         MOV     A,#0x0
   \   0000B9   F0           MOVX    @DPTR,A
   \   0000BA   8012         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1252                }
   1253                else
   1254                {
   1255                  req.status = APSME_UD_STANDARD_TRUST_CENTER_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   0000BC   7406         MOV     A,#0x6
   \   0000BE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C1   7403         MOV     A,#0x3
   \   0000C3   F0           MOVX    @DPTR,A
   \   0000C4   8008         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   1256                }
   1257              }
   1258              else
   1259              {
   1260                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   0000C6   7406         MOV     A,#0x6
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   7401         MOV     A,#0x1
   \   0000CD   F0           MOVX    @DPTR,A
   1261              }
   1262            }
   1263          
   1264            // set association status to authenticated
   1265            ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   0000CE                ; Setup parameters for call to function AssocGetWithShort
   \   0000CE   8E82         MOV     DPL,R6
   \   0000D0   8F83         MOV     DPH,R7
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   FA           MOV     R2,A
   \   0000D4   A3           INC     DPTR
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   FB           MOV     R3,A
   \   0000D7   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   0000DA   8A..         MOV     ?V2,R2
   \   0000DC   8B..         MOV     ?V3,R3
   \   0000DE   AA..         MOV     R2,?V2
   \   0000E0   AB..         MOV     R3,?V3
   \   0000E2                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   0000E2   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1266          
   1267          #if defined ( APP_TP2_TEST_MODE )
   1268            if ( guTxApsSecON == TRUE )
   1269            {
   1270              req.apsSecure = TRUE;
   1271            }
   1272            else
   1273            {
   1274              req.apsSecure = FALSE;
   1275            }
   1276          
   1277            // send and APSME_UPDATE_DEVICE request to the trust center
   1278            status = APSME_UpdateDeviceReq( &req );
   1279          
   1280          #else
   1281            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1282            {
   1283              // For ZG_GLOBAL_LINK_KEY the message has to be sent twice one
   1284              // un-encrypted and one APS encrypted, to make sure that it can interoperate
   1285              // with legacy Coordinator devices which can only handle one or the other.
   1286              if ( zgApsLinkKeyType == ZG_GLOBAL_LINK_KEY )
   1287              {
   1288                req.apsSecure = FALSE;
   1289          
   1290                // send and APSME_UPDATE_DEVICE request to the trust center
   1291                status = APSME_UpdateDeviceReq( &req );
   1292              }
   1293          
   1294              // send the message APS encrypted
   1295              req.apsSecure = TRUE;
   1296          
   1297              // send and APSME_UPDATE_DEVICE request to the trust center
   1298              status = APSME_UpdateDeviceReq( &req );
   1299            }
   1300            else
   1301            {
   1302              req.apsSecure = FALSE;
   \   0000E5   7407         MOV     A,#0x7
   \   0000E7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EA   7400         MOV     A,#0x0
   \   0000EC   F0           MOVX    @DPTR,A
   1303          
   1304              // send and APSME_UPDATE_DEVICE request to the trust center
   1305              status = APSME_UpdateDeviceReq( &req );
   \   0000ED                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   0000ED   AA..         MOV     R2,?XSP + 0
   \   0000EF   AB..         MOV     R3,?XSP + 1
   \   0000F1   12....       LCALL   `??APSME_UpdateDeviceReq::?relay`; Banked call to: APSME_UpdateDeviceReq
   \   0000F4   E9           MOV     A,R1
   \   0000F5   F5..         MOV     ?V0,A
   1306            }
   1307          #endif
   1308          
   1309            return status;
   \   0000F7   A9..         MOV     R1,?V0
   \   0000F9   7408         MOV     A,#0x8
   \   0000FB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000FE   7F04         MOV     R7,#0x4
   \   000100   02....       LJMP    ?BANKED_LEAVE_XDATA
   1310          }
   1311          
   1312          /******************************************************************************
   1313           * @fn          ZDSecMgrDeviceNew
   1314           *
   1315           * @brief       Process a new device.
   1316           *
   1317           * @param       device - [in] ZDSecMgrDevice_t, device info
   1318           *
   1319           * @return      ZStatus_t
   1320           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1321          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   1322          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1323            ZStatus_t status;
   1324          
   1325            if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1326                || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   1327            {
   1328              // try to join this device
   1329              status = ZDSecMgrDeviceJoinDirect( joiner );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoinDirect
   \   000009   EE           MOV     A,R6
   \   00000A   FA           MOV     R2,A
   \   00000B   EF           MOV     A,R7
   \   00000C   FB           MOV     R3,A
   \   00000D   12....       LCALL   `??ZDSecMgrDeviceJoinDirect::?relay`; Banked call to: ZDSecMgrDeviceJoinDirect
   \   000010   E9           MOV     A,R1
   \   000011   F5..         MOV     ?V0,A
   1330            }
   1331            else
   1332            {
   1333              status = ZDSecMgrDeviceJoinFwd( joiner );
   1334            }
   1335          
   1336            return status;
   \   000013   A9..         MOV     R1,?V0
   \   000015   7F01         MOV     R7,#0x1
   \   000017   02....       LJMP    ?BANKED_LEAVE_XDATA
   1337          }
   1338          
   1339          /******************************************************************************
   1340           * @fn          ZDSecMgrAssocDeviceAuth
   1341           *
   1342           * @brief       Set associated device status to authenticated
   1343           *
   1344           * @param       assoc - [in, out] associated_devices_t
   1345           *
   1346           * @return      none
   1347           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1348          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   1349          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1350            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   4B           ORL     A,R3
   \   000006   600D         JZ      ??ZDSecMgrAssocDeviceAuth_0
   1351            {
   1352              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   000008   8A82         MOV     DPL,R2
   \   00000A   8B83         MOV     DPH,R3
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   D2E3         SETB    0xE0 /* A   */.3
   \   000014   F0           MOVX    @DPTR,A
   1353            }
   1354          }
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000015   D083         POP     DPH
   \   000017   D082         POP     DPL
   \   000019   02....       LJMP    ?BRET
   1355          
   1356          /******************************************************************************
   1357           * @fn          ZDSecMgrAuthNwkKey
   1358           *
   1359           * @brief       Handle next step in authentication process
   1360           *
   1361           * @param       none
   1362           *
   1363           * @return      none
   1364           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1365          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   1366          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1367            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700D         JNZ     ??ZDSecMgrAuthNwkKey_0
   1368            {
   1369              // inform ZDO that device has been authenticated
   1370              osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   000018   E9           MOV     A,R1
   1371            }
   1372          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000019   D083         POP     DPH
   \   00001B   D082         POP     DPL
   \   00001D   02....       LJMP    ?BRET
   1373          
   1374          /******************************************************************************
   1375           * PUBLIC FUNCTIONS
   1376           */
   1377          /******************************************************************************
   1378           * @fn          ZDSecMgrInit
   1379           *
   1380           * @brief       Initialize ZigBee Device Security Manager.
   1381           *
   1382           * @param       state - device initialization state
   1383           *
   1384           * @return      none
   1385           */
   1386          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1387          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   1388          void ZDSecMgrAddrMgrCB( uint8           update,
   1389                                  AddrMgrEntry_t* newEntry,
   1390                                  AddrMgrEntry_t* oldEntry )
   1391          {
   1392            (void)update;
   1393            (void)newEntry;
   1394            (void)oldEntry;
   1395          }
   1396          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1397          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1398          void ZDSecMgrInit(uint8 state)
   \                     ZDSecMgrInit:
   1399          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   1400            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1401            {
   1402              // initialize sub modules
   1403              ZDSecMgrEntryInit(state);
   1404          
   1405              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1406              {
   1407                APSME_SetRequest( apsTrustCenterAddress, 0, NLME_GetExtAddr() );
   1408              }
   1409          
   1410              // register with Address Manager
   1411          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   1412              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   1413          #endif
   1414            }
   1415          
   1416            if ( ZG_SECURE_ENABLED )
   1417            {
   1418              if ( ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1419                   || ( ( ZG_BUILD_RTR_TYPE ) && APSME_IsDistributedSecurity() ) )
   1420              {
   1421                // setup joining permissions
   1422                ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000007   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000A   7401         MOV     A,#0x1
   \   00000C   F0           MOVX    @DPTR,A
   1423                ZDSecMgrPermitJoiningTimed   = FALSE;
   \   00000D   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000010   7400         MOV     A,#0x0
   \   000012   F0           MOVX    @DPTR,A
   1424              }
   1425            }
   1426          
   1427            // configure security based on security mode and type of device
   1428            ZDSecMgrConfig();
   \   000013                ; Setup parameters for call to function ZDSecMgrConfig
   \   000013   12....       LCALL   `??ZDSecMgrConfig::?relay`; Banked call to: ZDSecMgrConfig
   1429          }
   \   000016   7F01         MOV     R7,#0x1
   \   000018   02....       LJMP    ?BANKED_LEAVE_XDATA
   1430          
   1431          /******************************************************************************
   1432           * @fn          ZDSecMgrConfig
   1433           *
   1434           * @brief       Configure ZigBee Device Security Manager.
   1435           *
   1436           * @param       none
   1437           *
   1438           * @return      none
   1439           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1440          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   1441          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1442            if ( ZG_SECURE_ENABLED )
   1443            {
   1444              SSP_Init();
   \   000004                ; Setup parameters for call to function SSP_Init
   \   000004   12....       LCALL   `??SSP_Init::?relay` ; Banked call to: SSP_Init
   1445          
   1446              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1447              {
   1448                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1449                {
   1450                  // COMMERCIAL MODE - COORDINATOR DEVICE
   1451                  APSME_SecurityCM_CD();
   1452                }
   1453                else if ( ZSTACK_ROUTER_BUILD )
   1454                {
   1455                  // COMMERCIAL MODE - ROUTER DEVICE
   1456                  APSME_SecurityCM_RD();
   1457                }
   1458                else
   1459                {
   1460                  // COMMERCIAL MODE - END DEVICE
   1461                  APSME_SecurityCM_ED();
   1462                }
   1463              }
   1464              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1465              {
   1466                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1467                {
   1468                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   1469                  APSME_SecurityRM_CD();
   \   000007                ; Setup parameters for call to function APSME_SecurityRM_CD
   \   000007   12....       LCALL   `??APSME_SecurityRM_CD::?relay`; Banked call to: APSME_SecurityRM_CD
   1470                }
   1471                else if ( ZSTACK_ROUTER_BUILD )
   1472                {
   1473                  // RESIDENTIAL MODE - ROUTER DEVICE
   1474                  APSME_SecurityRM_RD();
   1475                }
   1476                else
   1477                {
   1478                  // RESIDENTIAL MODE - END DEVICE
   1479                  APSME_SecurityRM_ED();
   1480                }
   1481              }
   1482            }
   1483            else
   1484            {
   1485              // NO SECURITY
   1486              APSME_SecurityNM();
   1487            }
   1488          }
   \   00000A   D083         POP     DPH
   \   00000C   D082         POP     DPL
   \   00000E   02....       LJMP    ?BRET
   1489          
   1490          /******************************************************************************
   1491           * @fn          ZDSecMgrPermitJoining
   1492           *
   1493           * @brief       Process request to change joining permissions.
   1494           *
   1495           * @param       duration - [in] timed duration for join in seconds
   1496           *                         - 0x00 not allowed
   1497           *                         - 0xFF allowed without timeout
   1498           *
   1499           * @return      uint8 - success(TRUE:FALSE)
   1500           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1501          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   1502          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   1503            uint8 accept;
   1504          
   1505            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000006   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000009   7400         MOV     A,#0x0
   \   00000B   F0           MOVX    @DPTR,A
   1506          
   1507            if ( duration > 0 )
   \   00000C   E8           MOV     A,R0
   \   00000D   6013         JZ      ??ZDSecMgrPermitJoining_0
   1508            {
   1509              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00000F   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000012   7401         MOV     A,#0x1
   \   000014   F0           MOVX    @DPTR,A
   1510          
   1511              if ( duration != 0xFF )
   \   000015   74FF         MOV     A,#-0x1
   \   000017   68           XRL     A,R0
   \   000018   600E         JZ      ??ZDSecMgrPermitJoining_1
   1512              {
   1513                ZDSecMgrPermitJoiningTimed = TRUE;
   \   00001A   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001D   7401         MOV     A,#0x1
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   8006         SJMP    ??ZDSecMgrPermitJoining_1
   1514              }
   1515            }
   1516            else
   1517            {
   1518              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   000022   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000025   7400         MOV     A,#0x0
   \   000027   F0           MOVX    @DPTR,A
   1519            }
   1520          
   1521            accept = TRUE;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000028   7901         MOV     R1,#0x1
   1522          
   1523            return accept;
   \   00002A   D083         POP     DPH
   \   00002C   D082         POP     DPL
   \   00002E   02....       LJMP    ?BRET
   1524          }
   1525          
   1526          /******************************************************************************
   1527           * @fn          ZDSecMgrPermitJoiningTimeout
   1528           *
   1529           * @brief       Process permit joining timeout
   1530           *
   1531           * @param       none
   1532           *
   1533           * @return      none
   1534           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1535          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   1536          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1537            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   700C         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   1538            {
   1539              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00000F   7400         MOV     A,#0x0
   \   000011   F0           MOVX    @DPTR,A
   1540              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000012   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000015   7400         MOV     A,#0x0
   \   000017   F0           MOVX    @DPTR,A
   1541            }
   1542          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000018   D083         POP     DPH
   \   00001A   D082         POP     DPL
   \   00001C   02....       LJMP    ?BRET
   1543          
   1544          /******************************************************************************
   1545           * @fn          ZDSecMgrNewDeviceEvent
   1546           *
   1547           * @brief       Process a the new device event, if found reset new device
   1548           *              event/timer.
   1549           *
   1550           * @param       ShortAddr - of New Device to process
   1551           *
   1552           * @return      uint8 - found(TRUE:FALSE)
   1553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1554          uint8 ZDSecMgrNewDeviceEvent( uint16 ShortAddr )
   \                     ZDSecMgrNewDeviceEvent:
   1555          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 21
   \   000005   74EB         MOV     A,#-0x15
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   1556            uint8                 found;
   1557            ZDSecMgrDevice_t      device;
   1558            AddrMgrEntry_t        addrEntry;
   1559            associated_devices_t* assoc;
   1560            ZStatus_t             status;
   1561          
   1562            // initialize return results
   1563            found = FALSE;
   \   00000E   75..00       MOV     ?V2,#0x0
   1564          
   1565            assoc = AssocGetWithShort( ShortAddr );
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   AA..         MOV     R2,?V0
   \   000013   AB..         MOV     R3,?V1
   \   000015   12....       LCALL   `??AssocGetWithShort::?relay`; Banked call to: AssocGetWithShort
   \   000018   8A..         MOV     ?V4,R2
   \   00001A   8B..         MOV     ?V5,R3
   \   00001C   AE..         MOV     R6,?V4
   \   00001E   AF..         MOV     R7,?V5
   1566          
   1567            if ( assoc != NULL )
   \   000020   EE           MOV     A,R6
   \   000021   4F           ORL     A,R7
   \   000022   7003         JNZ     $+5
   \   000024   02....       LJMP    ??ZDSecMgrNewDeviceEvent_0 & 0xFFFF
   1568            {
   1569              // device found
   1570              found = TRUE;
   \   000027   75..01       MOV     ?V2,#0x1
   1571          
   1572              // check for preconfigured security
   1573              if ( zgPreConfigKeys == TRUE )
   \   00002A   90....       MOV     DPTR,#zgPreConfigKeys
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   6401         XRL     A,#0x1
   \   000030   7007         JNZ     ??ZDSecMgrNewDeviceEvent_1
   1574              {
   1575                // set association status to authenticated
   1576                ZDSecMgrAssocDeviceAuth( assoc );
   \   000032                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000032   EE           MOV     A,R6
   \   000033   FA           MOV     R2,A
   \   000034   EF           MOV     A,R7
   \   000035   FB           MOV     R3,A
   \   000036   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   1577              }
   1578          
   1579              // set up device info
   1580              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   000039   7408         MOV     A,#0x8
   \   00003B   12....       LCALL   ?XSTACK_DISP0_8
   \   00003E   7400         MOV     A,#0x0
   \   000040   F0           MOVX    @DPTR,A
   1581              addrEntry.index = assoc->addrIdx;
   \   000041   8E82         MOV     DPL,R6
   \   000043   8F83         MOV     DPH,R7
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F8           MOV     R0,A
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F9           MOV     R1,A
   \   00004C   7413         MOV     A,#0x13
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   E8           MOV     A,R0
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   E9           MOV     A,R1
   \   000055   F0           MOVX    @DPTR,A
   1582              AddrMgrEntryGet( &addrEntry );
   \   000056                ; Setup parameters for call to function AddrMgrEntryGet
   \   000056   7408         MOV     A,#0x8
   \   000058   12....       LCALL   ?XSTACK_DISP101_8
   \   00005B   12....       LCALL   `??AddrMgrEntryGet::?relay`; Banked call to: AddrMgrEntryGet
   \   00005E   E9           MOV     A,R1
   1583          
   1584              device.nwkAddr    = assoc->shortAddr;
   \   00005F   8E82         MOV     DPL,R6
   \   000061   8F83         MOV     DPH,R7
   \   000063   E0           MOVX    A,@DPTR
   \   000064   F8           MOV     R0,A
   \   000065   A3           INC     DPTR
   \   000066   E0           MOVX    A,@DPTR
   \   000067   F9           MOV     R1,A
   \   000068   85..82       MOV     DPL,?XSP + 0
   \   00006B   85..83       MOV     DPH,?XSP + 1
   \   00006E   E8           MOV     A,R0
   \   00006F   F0           MOVX    @DPTR,A
   \   000070   A3           INC     DPTR
   \   000071   E9           MOV     A,R1
   \   000072   F0           MOVX    @DPTR,A
   1585              device.extAddr    = addrEntry.extAddr;
   \   000073   740B         MOV     A,#0xb
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   A882         MOV     R0,DPL
   \   00007A   A983         MOV     R1,DPH
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E8           MOV     A,R0
   \   000082   F0           MOVX    @DPTR,A
   \   000083   A3           INC     DPTR
   \   000084   E9           MOV     A,R1
   \   000085   F0           MOVX    @DPTR,A
   1586              device.parentAddr = NLME_GetShortAddr();
   \   000086                ; Setup parameters for call to function NLME_GetShortAddr
   \   000086   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000089   7404         MOV     A,#0x4
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   EA           MOV     A,R2
   \   00008F   F0           MOVX    @DPTR,A
   \   000090   A3           INC     DPTR
   \   000091   EB           MOV     A,R3
   \   000092   F0           MOVX    @DPTR,A
   1587          
   1588              // the new device performed Secured Rejoin
   1589              if ( ( assoc->devStatus & DEV_SECURED_JOIN ) &&
   1590                   ( assoc->devStatus & DEV_REJOIN_STATUS ) )
   \   000093   8E82         MOV     DPL,R6
   \   000095   8F83         MOV     DPH,R7
   \   000097   A3           INC     DPTR
   \   000098   A3           INC     DPTR
   \   000099   A3           INC     DPTR
   \   00009A   A3           INC     DPTR
   \   00009B   A3           INC     DPTR
   \   00009C   E0           MOVX    A,@DPTR
   \   00009D   5460         ANL     A,#0x60
   \   00009F   6460         XRL     A,#0x60
   \   0000A1   700A         JNZ     ??ZDSecMgrNewDeviceEvent_2
   1591              {
   1592                device.secure     = TRUE;
   \   0000A3   7406         MOV     A,#0x6
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   7401         MOV     A,#0x1
   \   0000AA   F0           MOVX    @DPTR,A
   \   0000AB   8008         SJMP    ??ZDSecMgrNewDeviceEvent_3
   1593              }
   1594              else
   1595              {
   1596                device.secure     = FALSE;
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   0000AD   7406         MOV     A,#0x6
   \   0000AF   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B2   7400         MOV     A,#0x0
   \   0000B4   F0           MOVX    @DPTR,A
   1597              }
   1598              device.devStatus  = assoc->devStatus;
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   0000B5   8E82         MOV     DPL,R6
   \   0000B7   8F83         MOV     DPH,R7
   \   0000B9   A3           INC     DPTR
   \   0000BA   A3           INC     DPTR
   \   0000BB   A3           INC     DPTR
   \   0000BC   A3           INC     DPTR
   \   0000BD   A3           INC     DPTR
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   C0E0         PUSH    A
   \   0000C1   7407         MOV     A,#0x7
   \   0000C3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C6   D0E0         POP     A
   \   0000C8   F0           MOVX    @DPTR,A
   1599          
   1600              // process new device
   1601              status = ZDSecMgrDeviceNew( &device );
   \   0000C9                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   0000C9   AA..         MOV     R2,?XSP + 0
   \   0000CB   AB..         MOV     R3,?XSP + 1
   \   0000CD   12....       LCALL   `??ZDSecMgrDeviceNew::?relay`; Banked call to: ZDSecMgrDeviceNew
   \   0000D0   E9           MOV     A,R1
   \   0000D1   F5..         MOV     ?V3,A
   1602          
   1603              if ( status == ZSuccess )
   \   0000D3   E5..         MOV     A,?V3
   \   0000D5   700F         JNZ     ??ZDSecMgrNewDeviceEvent_4
   1604              {
   1605                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   0000D7   8E82         MOV     DPL,R6
   \   0000D9   8F83         MOV     DPH,R7
   \   0000DB   A3           INC     DPTR
   \   0000DC   A3           INC     DPTR
   \   0000DD   A3           INC     DPTR
   \   0000DE   A3           INC     DPTR
   \   0000DF   A3           INC     DPTR
   \   0000E0   E0           MOVX    A,@DPTR
   \   0000E1   C2E2         CLR     0xE0 /* A   */.2
   \   0000E3   F0           MOVX    @DPTR,A
   \   0000E4   801A         SJMP    ??ZDSecMgrNewDeviceEvent_0
   1606              }
   1607              else
   1608              {
   1609                // Clear SECURITY bit from Address Manager
   1610                ZDSecMgrAddrClear( addrEntry.extAddr );
   \                     ??ZDSecMgrNewDeviceEvent_4:
   \   0000E6                ; Setup parameters for call to function ZDSecMgrAddrClear
   \   0000E6   740B         MOV     A,#0xb
   \   0000E8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000EB   AA82         MOV     R2,DPL
   \   0000ED   AB83         MOV     R3,DPH
   \   0000EF   12....       LCALL   `??ZDSecMgrAddrClear::?relay`; Banked call to: ZDSecMgrAddrClear
   \   0000F2   E9           MOV     A,R1
   1611          
   1612                // Remove the Association completely
   1613                AssocRemove( addrEntry.extAddr );
   \   0000F3                ; Setup parameters for call to function AssocRemove
   \   0000F3   740B         MOV     A,#0xb
   \   0000F5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F8   AA82         MOV     R2,DPL
   \   0000FA   AB83         MOV     R3,DPH
   \   0000FC   12....       LCALL   `??AssocRemove::?relay`; Banked call to: AssocRemove
   \   0000FF   E9           MOV     A,R1
   1614              }
   1615            }
   1616          
   1617            return found;
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   000100   A9..         MOV     R1,?V2
   \   000102   7415         MOV     A,#0x15
   \   000104   12....       LCALL   ?DEALLOC_XSTACK8
   \   000107   7F06         MOV     R7,#0x6
   \   000109   02....       LJMP    ?BANKED_LEAVE_XDATA
   1618          }
   1619          
   1620          /******************************************************************************
   1621           * @fn          ZDSecMgrTCExtAddrCheck
   1622           *
   1623           * @brief       Verifies if received ext. address matches TC ext. address.
   1624           *
   1625           * @param       extAddr - Extended address to be verified.
   1626           *
   1627           * @return      TRUE - extended address matches
   1628           *              FALSE - otherwise
   1629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1630          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   1631          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1632            uint8  lookup[Z_EXTADDR_LEN];
   1633            APSME_GetRequest( apsTrustCenterAddress, 0, lookup );
   \   00000E                ; Setup parameters for call to function APSME_GetRequest
   \   00000E   AC..         MOV     R4,?XSP + 0
   \   000010   AD..         MOV     R5,?XSP + 1
   \   000012   7A00         MOV     R2,#0x0
   \   000014   7B00         MOV     R3,#0x0
   \   000016   79AB         MOV     R1,#-0x55
   \   000018   12....       LCALL   `??APSME_GetRequest::?relay`; Banked call to: APSME_GetRequest
   \   00001B   E9           MOV     A,R1
   1634            return osal_ExtAddrEqual( extAddr, lookup );
   \   00001C                ; Setup parameters for call to function sAddrExtCmp
   \   00001C   AC..         MOV     R4,?XSP + 0
   \   00001E   AD..         MOV     R5,?XSP + 1
   \   000020   EE           MOV     A,R6
   \   000021   FA           MOV     R2,A
   \   000022   EF           MOV     A,R7
   \   000023   FB           MOV     R3,A
   \   000024   12....       LCALL   `??sAddrExtCmp::?relay`; Banked call to: sAddrExtCmp
   \   000027   7408         MOV     A,#0x8
   \   000029   12....       LCALL   ?DEALLOC_XSTACK8
   \   00002C   7F01         MOV     R7,#0x1
   \   00002E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1635          }
   1636          
   1637          /******************************************************************************
   1638           * @fn          ZDSecMgrTCDataLoad
   1639           *
   1640           * @brief       Stores the address of TC into address manager.
   1641           *
   1642           * @param       extAddr - Extended address to be verified.
   1643           *
   1644           * @return      none
   1645           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1646          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   1647          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 15
   \   000005   74F1         MOV     A,#-0xf
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1648            uint16 ami;
   1649            AddrMgrEntry_t entry;
   1650          
   1651            // lookup using TC short address
   1652            entry.user    = ADDRMGR_USER_DEFAULT;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7400         MOV     A,#0x0
   \   000015   F0           MOVX    @DPTR,A
   1653            osal_cpyExtAddr( entry.extAddr, extAddr );
   \   000016                ; Setup parameters for call to function sAddrExtCpy
   \   000016   EE           MOV     A,R6
   \   000017   FC           MOV     R4,A
   \   000018   EF           MOV     A,R7
   \   000019   FD           MOV     R5,A
   \   00001A   7405         MOV     A,#0x5
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   AA82         MOV     R2,DPL
   \   000021   AB83         MOV     R3,DPH
   \   000023   12....       LCALL   `??sAddrExtCpy::?relay`; Banked call to: sAddrExtCpy
   1654          
   1655            // Verify if TC address has been added to Address Manager
   1656            if ( !APSME_IsDistributedSecurity() && ( AddrMgrEntryLookupExt( &entry ) != TRUE ) )
   \   000026                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   000026   12....       LCALL   `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   000029   E9           MOV     A,R1
   \   00002A   702B         JNZ     ??ZDSecMgrTCDataLoad_0
   \   00002C                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?XSTACK_DISP101_8
   \   000031   12....       LCALL   `??AddrMgrEntryLookupExt::?relay`; Banked call to: AddrMgrEntryLookupExt
   \   000034   E9           MOV     A,R1
   \   000035   6401         XRL     A,#0x1
   \   000037   601E         JZ      ??ZDSecMgrTCDataLoad_0
   1657            {
   1658              ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami );
   \   000039                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000039   A8..         MOV     R0,?XSP + 0
   \   00003B   A9..         MOV     R1,?XSP + 1
   \   00003D   88..         MOV     ?V0,R0
   \   00003F   89..         MOV     ?V1,R1
   \   000041   78..         MOV     R0,#?V0
   \   000043   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000046   EE           MOV     A,R6
   \   000047   FC           MOV     R4,A
   \   000048   EF           MOV     A,R7
   \   000049   FD           MOV     R5,A
   \   00004A   7A00         MOV     R2,#0x0
   \   00004C   7B00         MOV     R3,#0x0
   \   00004E   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?DEALLOC_XSTACK8
   \   000056   E9           MOV     A,R1
   1659            }
   1660          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000057   740F         MOV     A,#0xf
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005C   7F02         MOV     R7,#0x2
   \   00005E   02....       LJMP    ?BANKED_LEAVE_XDATA
   1661          
   1662          /******************************************************************************
   1663           * @fn          ZDSecMgrTransportKeyInd
   1664           *
   1665           * @brief       Process the ZDO_TransportKeyInd_t message.
   1666           *
   1667           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   1668           *
   1669           * @return      none
   1670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1671          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   1672          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 16
   \   000005   74F0         MOV     A,#-0x10
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1673            uint8 index;
   1674            uint8 zgPreConfigKey[SEC_KEY_LEN];
   1675          
   1676            ZDSecMgrUpdateTCAddress( ind->srcExtAddr );
   \   00000E                ; Setup parameters for call to function ZDSecMgrUpdateTCAddress
   \   00000E   EE           MOV     A,R6
   \   00000F   2416         ADD     A,#0x16
   \   000011   FA           MOV     R2,A
   \   000012   E4           CLR     A
   \   000013   3F           ADDC    A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   `??ZDSecMgrUpdateTCAddress::?relay`; Banked call to: ZDSecMgrUpdateTCAddress
   1677            // check for distributed security
   1678            if ( ( ZG_BUILD_RTR_TYPE ) && osal_isbufset( ind->srcExtAddr, 0xFF, Z_EXTADDR_LEN ) )
   \   000018                ; Setup parameters for call to function osal_isbufset
   \   000018   7C08         MOV     R4,#0x8
   \   00001A   79FF         MOV     R1,#-0x1
   \   00001C   EE           MOV     A,R6
   \   00001D   2416         ADD     A,#0x16
   \   00001F   FA           MOV     R2,A
   \   000020   E4           CLR     A
   \   000021   3F           ADDC    A,R7
   \   000022   FB           MOV     R3,A
   \   000023   12....       LCALL   `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   000026   E9           MOV     A,R1
   \   000027   6006         JZ      ??ZDSecMgrTransportKeyInd_0
   1679            {
   1680              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   000029   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   00002C   7401         MOV     A,#0x1
   \   00002E   F0           MOVX    @DPTR,A
   1681            }
   1682          
   1683            // load Trust Center data if needed
   1684            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   00002F                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   00002F   EE           MOV     A,R6
   \   000030   2416         ADD     A,#0x16
   \   000032   FA           MOV     R2,A
   \   000033   E4           CLR     A
   \   000034   3F           ADDC    A,R7
   \   000035   FB           MOV     R3,A
   \   000036   12....       LCALL   `??ZDSecMgrTCDataLoad::?relay`; Banked call to: ZDSecMgrTCDataLoad
   1685          
   1686            if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   1687                 ( ind->keyType == 6            ) )
   \   000039   8E82         MOV     DPL,R6
   \   00003B   8F83         MOV     DPH,R7
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   6401         XRL     A,#0x1
   \   000044   6010         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000046   8E82         MOV     DPL,R6
   \   000048   8F83         MOV     DPH,R7
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   A3           INC     DPTR
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   6406         XRL     A,#0x6
   \   000051   6003         JZ      $+5
   \   000053   02....       LJMP    ??ZDSecMgrTransportKeyInd_2 & 0xFFFF
   1688            {
   1689              // check for dummy NWK key (all zeros)
   1690              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   000056   75..00       MOV     ?V0,#0x0
   1691                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   000059   E5..         MOV     A,?V0
   \   00005B   C3           CLR     C
   \   00005C   9410         SUBB    A,#0x10
   \   00005E   5019         JNC     ??ZDSecMgrTransportKeyInd_4
   \   000060   A8..         MOV     R0,?V0
   \   000062   7900         MOV     R1,#0x0
   \   000064   EE           MOV     A,R6
   \   000065   28           ADD     A,R0
   \   000066   F582         MOV     DPL,A
   \   000068   EF           MOV     A,R7
   \   000069   39           ADDC    A,R1
   \   00006A   F583         MOV     DPH,A
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   7004         JNZ     ??ZDSecMgrTransportKeyInd_4
   1692                    index++ );
   \   000075   05..         INC     ?V0
   \   000077   80E0         SJMP    ??ZDSecMgrTransportKeyInd_3
   1693          
   1694              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000079   7410         MOV     A,#0x10
   \   00007B   65..         XRL     A,?V0
   \   00007D   702F         JNZ     ??ZDSecMgrTransportKeyInd_5
   1695              {
   1696                // load preconfigured key - once!!
   1697                if ( !_NIB.nwkKeyLoaded )
   \   00007F   90....       MOV     DPTR,#_NIB + 61
   \   000082   E0           MOVX    A,@DPTR
   \   000083   7052         JNZ     ??ZDSecMgrTransportKeyInd_6
   1698                {
   1699                  ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY, zgPreConfigKey);
   \   000085                ; Setup parameters for call to function ZDSecMgrReadKeyFromNv
   \   000085   AC..         MOV     R4,?XSP + 0
   \   000087   AD..         MOV     R5,?XSP + 1
   \   000089   7A62         MOV     R2,#0x62
   \   00008B   7B00         MOV     R3,#0x0
   \   00008D   12....       LCALL   `??ZDSecMgrReadKeyFromNv::?relay`; Banked call to: ZDSecMgrReadKeyFromNv
   \   000090   E9           MOV     A,R1
   1700                  SSP_UpdateNwkKey( zgPreConfigKey, 0 );
   \   000091                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000091   7900         MOV     R1,#0x0
   \   000093   AA..         MOV     R2,?XSP + 0
   \   000095   AB..         MOV     R3,?XSP + 1
   \   000097   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   1701                  SSP_SwitchNwkKey( 0 );
   \   00009A                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00009A   7900         MOV     R1,#0x0
   \   00009C   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1702          
   1703                  // clear local copy of key
   1704                  osal_memset(zgPreConfigKey, 0x00, SEC_KEY_LEN);
   \   00009F                ; Setup parameters for call to function osal_memset
   \   00009F   7C10         MOV     R4,#0x10
   \   0000A1   7D00         MOV     R5,#0x0
   \   0000A3   7900         MOV     R1,#0x0
   \   0000A5   AA..         MOV     R2,?XSP + 0
   \   0000A7   AB..         MOV     R3,?XSP + 1
   \   0000A9   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   \   0000AC   8029         SJMP    ??ZDSecMgrTransportKeyInd_6
   1705                }
   1706              }
   1707              else
   1708              {
   1709                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   0000AE                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   0000AE   8E82         MOV     DPL,R6
   \   0000B0   8F83         MOV     DPH,R7
   \   0000B2   A3           INC     DPTR
   \   0000B3   A3           INC     DPTR
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   A3           INC     DPTR
   \   0000B7   E0           MOVX    A,@DPTR
   \   0000B8   F9           MOV     R1,A
   \   0000B9   EE           MOV     A,R6
   \   0000BA   2406         ADD     A,#0x6
   \   0000BC   FA           MOV     R2,A
   \   0000BD   E4           CLR     A
   \   0000BE   3F           ADDC    A,R7
   \   0000BF   FB           MOV     R3,A
   \   0000C0   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   1710                if ( !_NIB.nwkKeyLoaded )
   \   0000C3   90....       MOV     DPTR,#_NIB + 61
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   700E         JNZ     ??ZDSecMgrTransportKeyInd_6
   1711                {
   1712                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   0000C9                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   0000C9   8E82         MOV     DPL,R6
   \   0000CB   8F83         MOV     DPH,R7
   \   0000CD   A3           INC     DPTR
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   A3           INC     DPTR
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   F9           MOV     R1,A
   \   0000D4   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1713                }
   1714              }
   1715          
   1716              // handle next step in authentication process
   1717              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   0000D7                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   0000D7   12....       LCALL   `??ZDSecMgrAuthNwkKey::?relay`; Banked call to: ZDSecMgrAuthNwkKey
   \   0000DA   8018         SJMP    ??ZDSecMgrTransportKeyInd_7
   1718            }
   1719            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   0000DC   8E82         MOV     DPL,R6
   \   0000DE   8F83         MOV     DPH,R7
   \   0000E0   A3           INC     DPTR
   \   0000E1   A3           INC     DPTR
   \   0000E2   A3           INC     DPTR
   \   0000E3   A3           INC     DPTR
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   6404         XRL     A,#0x4
   \   0000E7   600B         JZ      ??ZDSecMgrTransportKeyInd_7
   1720            {
   1721              // This should not happen because TCLK should not be Tx
   1722            }
   1723            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   \   0000E9   8E82         MOV     DPL,R6
   \   0000EB   8F83         MOV     DPH,R7
   \   0000ED   A3           INC     DPTR
   \   0000EE   A3           INC     DPTR
   \   0000EF   A3           INC     DPTR
   \   0000F0   A3           INC     DPTR
   \   0000F1   E0           MOVX    A,@DPTR
   \   0000F2   6403         XRL     A,#0x3
   1724            {
   1725              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1726              {
   1727                uint16           ami;
   1728                ZDSecMgrEntry_t* entry;
   1729          
   1730                // get the address index
   1731                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   1732                {
   1733                  // store new EXT address
   1734                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   1735                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   1736                }
   1737          
   1738                ZDSecMgrEntryLookupAMI( ami, &entry );
   1739          
   1740                if ( entry == NULL )
   1741                {
   1742                  // get new entry
   1743                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   1744                  {
   1745                    // finish setting up entry
   1746                    entry->ami = ami;
   1747                  }
   1748                }
   1749          
   1750                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   1751          
   1752          #if defined NV_RESTORE
   1753                ZDSecMgrWriteNV();  // Write the control record for the new established link key to NV.
   1754          #endif
   1755              }
   1756            }
   1757          }
   \                     ??ZDSecMgrTransportKeyInd_7:
   \   0000F4   7410         MOV     A,#0x10
   \   0000F6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000F9   7F01         MOV     R7,#0x1
   \   0000FB   02....       LJMP    ?BANKED_LEAVE_XDATA
   1758          
   1759          /******************************************************************************
   1760           * @fn          ZDSecMgrUpdateDeviceInd
   1761           *
   1762           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   1763           *
   1764           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   1765           *
   1766           * @return      none
   1767           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1768          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   1769          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1770            ZDSecMgrDevice_t device;
   1771          
   1772            device.nwkAddr    = ind->devAddr;
   \   00000E   EE           MOV     A,R6
   \   00000F   240C         ADD     A,#0xc
   \   000011   F582         MOV     DPL,A
   \   000013   E4           CLR     A
   \   000014   3F           ADDC    A,R7
   \   000015   F583         MOV     DPH,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F8           MOV     R0,A
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F9           MOV     R1,A
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   E8           MOV     A,R0
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   E9           MOV     A,R1
   \   000026   F0           MOVX    @DPTR,A
   1773            device.extAddr    = ind->devExtAddr;
   \   000027   EE           MOV     A,R6
   \   000028   2404         ADD     A,#0x4
   \   00002A   F8           MOV     R0,A
   \   00002B   E4           CLR     A
   \   00002C   3F           ADDC    A,R7
   \   00002D   F9           MOV     R1,A
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   E8           MOV     A,R0
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   E9           MOV     A,R1
   \   000037   F0           MOVX    @DPTR,A
   1774            device.parentAddr = ind->srcAddr;
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F8           MOV     R0,A
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   F9           MOV     R1,A
   \   000043   7404         MOV     A,#0x4
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   E8           MOV     A,R0
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   E9           MOV     A,R1
   \   00004C   F0           MOVX    @DPTR,A
   1775            device.devStatus  = DEV_SEC_INIT_STATUS;
   \   00004D   7407         MOV     A,#0x7
   \   00004F   12....       LCALL   ?XSTACK_DISP0_8
   \   000052   7404         MOV     A,#0x4
   \   000054   F0           MOVX    @DPTR,A
   1776            device.secure     = FALSE;
   \   000055   7406         MOV     A,#0x6
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   7400         MOV     A,#0x0
   \   00005C   F0           MOVX    @DPTR,A
   1777          
   1778            // Trust Center should identify the type of JOIN/REJOIN and
   1779            // Transport the NWK key accordingly, it will only be transported for:
   1780            //              APSME_UD_STANDARD_UNSECURED_JOIN
   1781            //   OR         APSME_UD_STANDARD_TRUST_CENTER_REJOIN
   1782            if ( ind->status != APSME_UD_DEVICE_LEFT )
   \   00005D   EE           MOV     A,R6
   \   00005E   240E         ADD     A,#0xe
   \   000060   F582         MOV     DPL,A
   \   000062   E4           CLR     A
   \   000063   3F           ADDC    A,R7
   \   000064   F583         MOV     DPH,A
   \   000066   E0           MOVX    A,@DPTR
   \   000067   6402         XRL     A,#0x2
   \   000069   602E         JZ      ??ZDSecMgrUpdateDeviceInd_0
   1783            {
   1784              if ( ind->status == APSME_UD_STANDARD_SECURED_REJOIN )
   \   00006B   EE           MOV     A,R6
   \   00006C   240E         ADD     A,#0xe
   \   00006E   F582         MOV     DPL,A
   \   000070   E4           CLR     A
   \   000071   3F           ADDC    A,R7
   \   000072   F583         MOV     DPH,A
   \   000074   E0           MOVX    A,@DPTR
   \   000075   701A         JNZ     ??ZDSecMgrUpdateDeviceInd_1
   1785              {
   1786                device.devStatus &= ~DEV_SEC_INIT_STATUS;
   \   000077   7407         MOV     A,#0x7
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   E0           MOVX    A,@DPTR
   \   00007D   C2E2         CLR     0xE0 /* A   */.2
   \   00007F   F0           MOVX    @DPTR,A
   1787                device.devStatus |=  DEV_SEC_AUTH_STATUS;
   \   000080   7407         MOV     A,#0x7
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   E0           MOVX    A,@DPTR
   \   000086   D2E3         SETB    0xE0 /* A   */.3
   \   000088   F0           MOVX    @DPTR,A
   1788                device.secure = TRUE;
   \   000089   7406         MOV     A,#0x6
   \   00008B   12....       LCALL   ?XSTACK_DISP0_8
   \   00008E   7401         MOV     A,#0x1
   \   000090   F0           MOVX    @DPTR,A
   1789              }
   1790          
   1791              ZDSecMgrDeviceJoin( &device );
   \                     ??ZDSecMgrUpdateDeviceInd_1:
   \   000091                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000091   AA..         MOV     R2,?XSP + 0
   \   000093   AB..         MOV     R3,?XSP + 1
   \   000095   12....       LCALL   `??ZDSecMgrDeviceJoin::?relay`; Banked call to: ZDSecMgrDeviceJoin
   \   000098   E9           MOV     A,R1
   1792            }
   1793          }
   \                     ??ZDSecMgrUpdateDeviceInd_0:
   \   000099   7408         MOV     A,#0x8
   \   00009B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00009E   7F01         MOV     R7,#0x1
   \   0000A0   02....       LJMP    ?BANKED_LEAVE_XDATA
   1794          
   1795          /******************************************************************************
   1796           * @fn          ZDSecMgrRemoveDeviceInd
   1797           *
   1798           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   1799           *
   1800           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   1801           *
   1802           * @return      none
   1803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1804          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   1805          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1806            ZDSecMgrDevice_t device;
   1807          
   1808            // only accept from Trust Center
   1809            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F8           MOV     R0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   49           ORL     A,R1
   \   00001B   7038         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   1810            {
   1811              // look up NWK address
   1812              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   00001D                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001D   AC..         MOV     R4,?XSP + 0
   \   00001F   AD..         MOV     R5,?XSP + 1
   \   000021   EE           MOV     A,R6
   \   000022   2404         ADD     A,#0x4
   \   000024   FA           MOV     R2,A
   \   000025   E4           CLR     A
   \   000026   3F           ADDC    A,R7
   \   000027   FB           MOV     R3,A
   \   000028   12....       LCALL   `??APSME_LookupNwkAddr::?relay`; Banked call to: APSME_LookupNwkAddr
   \   00002B   E9           MOV     A,R1
   \   00002C   6401         XRL     A,#0x1
   \   00002E   7025         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   1813              {
   1814                device.parentAddr = NLME_GetShortAddr();
   \   000030                ; Setup parameters for call to function NLME_GetShortAddr
   \   000030   12....       LCALL   `??NLME_GetShortAddr::?relay`; Banked call to: NLME_GetShortAddr
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   EA           MOV     A,R2
   \   000039   F0           MOVX    @DPTR,A
   \   00003A   A3           INC     DPTR
   \   00003B   EB           MOV     A,R3
   \   00003C   F0           MOVX    @DPTR,A
   1815                device.extAddr    = ind->childExtAddr;
   \   00003D   EE           MOV     A,R6
   \   00003E   2404         ADD     A,#0x4
   \   000040   F8           MOV     R0,A
   \   000041   E4           CLR     A
   \   000042   3F           ADDC    A,R7
   \   000043   F9           MOV     R1,A
   \   000044   7402         MOV     A,#0x2
   \   000046   12....       LCALL   ?XSTACK_DISP0_8
   \   000049   E8           MOV     A,R0
   \   00004A   F0           MOVX    @DPTR,A
   \   00004B   A3           INC     DPTR
   \   00004C   E9           MOV     A,R1
   \   00004D   F0           MOVX    @DPTR,A
   1816          
   1817                // remove device
   1818                ZDSecMgrDeviceRemove( &device );
   \   00004E                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00004E   AA..         MOV     R2,?XSP + 0
   \   000050   AB..         MOV     R3,?XSP + 1
   \   000052   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   1819              }
   1820            }
   1821          }
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000055   7408         MOV     A,#0x8
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   7F01         MOV     R7,#0x1
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1822          
   1823          /******************************************************************************
   1824           * @fn          ZDSecMgrRequestKeyInd
   1825           *
   1826           * @brief       Process the ZDO_RequestKeyInd_t message.
   1827           *
   1828           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   1829           *
   1830           * @return      none
   1831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1832          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   1833          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1834            if ( ind->keyType == KEY_TYPE_NWK )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   6401         XRL     A,#0x1
   \   000014   6014         JZ      ??ZDSecMgrRequestKeyInd_0
   1835            {
   1836            }
   1837            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   6402         XRL     A,#0x2
   \   000021   7007         JNZ     ??ZDSecMgrRequestKeyInd_0
   1838            {
   1839              ZDSecMgrAppKeyReq( ind );
   \   000023                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   `??ZDSecMgrAppKeyReq::?relay`; Banked call to: ZDSecMgrAppKeyReq
   1840            }
   1841            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   1842            {
   1843            }
   1844            //else ignore
   1845          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00002A   7F01         MOV     R7,#0x1
   \   00002C   02....       LJMP    ?BANKED_LEAVE_XDATA
   1846          
   1847          /******************************************************************************
   1848           * @fn          ZDSecMgrSwitchKeyInd
   1849           *
   1850           * @brief       Process the ZDO_SwitchKeyInd_t message.
   1851           *
   1852           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   1853           *
   1854           * @return      none
   1855           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1856          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   1857          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   1858            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000009                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   A3           INC     DPTR
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F9           MOV     R1,A
   \   000013   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1859          
   1860            // Save if nv
   1861            ZDApp_NVUpdate();
   \   000016                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000016   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   1862          }
   \   000019   7F01         MOV     R7,#0x1
   \   00001B   02....       LJMP    ?BANKED_LEAVE_XDATA
   1863          
   1864          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1865          /******************************************************************************
   1866           * @fn          ZDSecMgrUpdateNwkKey
   1867           *
   1868           * @brief       Load a new NWK key and trigger a network update to the dstAddr.
   1869           *
   1870           * @param       key       - [in] new NWK key
   1871           * @param       keySeqNum - [in] new NWK key sequence number
   1872           *
   1873           * @return      ZStatus_t
   1874           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1875          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrUpdateNwkKey:
   1876          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V3,R1
   \   000010   8C..         MOV     ?V0,R4
   \   000012   8D..         MOV     ?V1,R5
   1877            ZStatus_t               status;
   1878            APSME_TransportKeyReq_t req;
   1879          
   1880            // initialize common elements of local variables
   1881            req.keyType   = KEY_TYPE_NWK;
   \   000014   7402         MOV     A,#0x2
   \   000016   12....       LCALL   ?XSTACK_DISP0_8
   \   000019   7401         MOV     A,#0x1
   \   00001B   F0           MOVX    @DPTR,A
   1882          
   1883            req.dstAddr   = dstAddr;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   E5..         MOV     A,?V0
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   E5..         MOV     A,?V1
   \   000028   F0           MOVX    @DPTR,A
   1884            req.keySeqNum = keySeqNum;
   \   000029   E5..         MOV     A,?V3
   \   00002B   C0E0         PUSH    A
   \   00002D   7403         MOV     A,#0x3
   \   00002F   12....       LCALL   ?XSTACK_DISP0_8
   \   000032   D0E0         POP     A
   \   000034   F0           MOVX    @DPTR,A
   1885            req.key       = key;
   \   000035   7404         MOV     A,#0x4
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   EE           MOV     A,R6
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   EF           MOV     A,R7
   \   00003E   F0           MOVX    @DPTR,A
   1886            req.extAddr   = NULL;
   \   00003F   7406         MOV     A,#0x6
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   7400         MOV     A,#0x0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   7400         MOV     A,#0x0
   \   00004A   F0           MOVX    @DPTR,A
   1887            req.nwkSecure = TRUE;
   \   00004B   740A         MOV     A,#0xa
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   7401         MOV     A,#0x1
   \   000052   F0           MOVX    @DPTR,A
   1888            req.tunnel    = NULL;
   \   000053   740B         MOV     A,#0xb
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   7400         MOV     A,#0x0
   \   00005A   F0           MOVX    @DPTR,A
   \   00005B   A3           INC     DPTR
   \   00005C   7400         MOV     A,#0x0
   \   00005E   F0           MOVX    @DPTR,A
   1889          
   1890            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1891            {
   1892              // Broadcast transport NWK key
   1893              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   1894                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   1895                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   1896              {
   1897                req.apsSecure = FALSE;
   1898                status = APSME_TransportKeyReq( &req );
   1899              }
   1900              else
   1901              {
   1902                AddrMgrEntry_t          addrEntry;
   1903          
   1904                addrEntry.user = ADDRMGR_USER_SECURITY;
   1905                addrEntry.nwkAddr = dstAddr;
   1906          
   1907                status = ZFailure;
   1908          
   1909                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   1910                {
   1911                  req.extAddr = addrEntry.extAddr;
   1912                  req.apsSecure = TRUE;
   1913                  status = APSME_TransportKeyReq( &req );
   1914                }
   1915              }
   1916            }
   1917            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1918            {
   1919              req.apsSecure = FALSE;
   \   00005F   7409         MOV     A,#0x9
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   7400         MOV     A,#0x0
   \   000066   F0           MOVX    @DPTR,A
   1920              status = APSME_TransportKeyReq( &req );
   \   000067                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000067   AA..         MOV     R2,?XSP + 0
   \   000069   AB..         MOV     R3,?XSP + 1
   \   00006B   12....       LCALL   `??APSME_TransportKeyReq::?relay`; Banked call to: APSME_TransportKeyReq
   \   00006E   E9           MOV     A,R1
   \   00006F   F5..         MOV     ?V2,A
   1921            }
   1922          
   1923            SSP_UpdateNwkKey( key, keySeqNum );
   \   000071                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000071   A9..         MOV     R1,?V3
   \   000073   EE           MOV     A,R6
   \   000074   FA           MOV     R2,A
   \   000075   EF           MOV     A,R7
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   `??SSP_UpdateNwkKey::?relay`; Banked call to: SSP_UpdateNwkKey
   1924          
   1925            // Save if nv
   1926            ZDApp_NVUpdate();
   \   00007A                ; Setup parameters for call to function ZDApp_NVUpdate
   \   00007A   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   1927          
   1928            return status;
   \   00007D   A9..         MOV     R1,?V2
   \   00007F   740D         MOV     A,#0xd
   \   000081   12....       LCALL   ?DEALLOC_XSTACK8
   \   000084   7F04         MOV     R7,#0x4
   \   000086   02....       LJMP    ?BANKED_LEAVE_XDATA
   1929          }
   1930          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   1931          
   1932          #if ( ZG_BUILD_COORDINATOR_TYPE )
   1933          /******************************************************************************
   1934           * @fn          ZDSecMgrSwitchNwkKey
   1935           *
   1936           * @brief       Causes the NWK key to switch via a network command to the dstAddr.
   1937           *
   1938           * @param       keySeqNum - [in] new NWK key sequence number
   1939           *
   1940           * @return      ZStatus_t
   1941           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1942          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   \                     ZDSecMgrSwitchNwkKey:
   1943          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   \   00000C   8A..         MOV     ?V0,R2
   \   00000E   8B..         MOV     ?V1,R3
   1944            ZStatus_t            status;
   1945            APSME_SwitchKeyReq_t req;
   1946          
   1947            // initialize common elements of local variables
   1948            req.dstAddr = dstAddr;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   E5..         MOV     A,?V0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   E5..         MOV     A,?V1
   \   00001C   F0           MOVX    @DPTR,A
   1949            req.keySeqNum = keySeqNum;
   \   00001D   EF           MOV     A,R7
   \   00001E   C0E0         PUSH    A
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   D0E0         POP     A
   \   000027   F0           MOVX    @DPTR,A
   1950          
   1951            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   1952            {
   1953              // Broadcast switch NWK key
   1954              if (( dstAddr == NWK_BROADCAST_SHORTADDR_DEVALL ) ||
   1955                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVZCZR) ||
   1956                  ( dstAddr == NWK_BROADCAST_SHORTADDR_DEVRXON))
   1957              {
   1958                req.apsSecure = FALSE;
   1959                status = APSME_SwitchKeyReq( &req );
   1960              }
   1961              else
   1962              {
   1963                AddrMgrEntry_t          addrEntry;
   1964          
   1965                addrEntry.user = ADDRMGR_USER_SECURITY;
   1966                addrEntry.nwkAddr = dstAddr;
   1967          
   1968                status = ZFailure;
   1969          
   1970                if ( AddrMgrEntryLookupNwk( &addrEntry ) == TRUE )
   1971                {
   1972                  req.dstAddr = addrEntry.nwkAddr;
   1973                  req.apsSecure = TRUE;
   1974                  status = APSME_SwitchKeyReq( &req );
   1975                }
   1976              }
   1977            }
   1978            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1979            {
   1980              req.apsSecure = FALSE;
   \   000028   7403         MOV     A,#0x3
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   7400         MOV     A,#0x0
   \   00002F   F0           MOVX    @DPTR,A
   1981              status = APSME_SwitchKeyReq( &req );
   \   000030                ; Setup parameters for call to function APSME_SwitchKeyReq
   \   000030   AA..         MOV     R2,?XSP + 0
   \   000032   AB..         MOV     R3,?XSP + 1
   \   000034   12....       LCALL   `??APSME_SwitchKeyReq::?relay`; Banked call to: APSME_SwitchKeyReq
   \   000037   E9           MOV     A,R1
   \   000038   FE           MOV     R6,A
   1982            }
   1983          
   1984            SSP_SwitchNwkKey( keySeqNum );
   \   000039                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000039   EF           MOV     A,R7
   \   00003A   F9           MOV     R1,A
   \   00003B   12....       LCALL   `??SSP_SwitchNwkKey::?relay`; Banked call to: SSP_SwitchNwkKey
   1985          
   1986            // Save if nv
   1987            ZDApp_NVUpdate();
   \   00003E                ; Setup parameters for call to function ZDApp_NVUpdate
   \   00003E   12....       LCALL   `??ZDApp_NVUpdate::?relay`; Banked call to: ZDApp_NVUpdate
   1988          
   1989            return status;
   \   000041   EE           MOV     A,R6
   \   000042   F9           MOV     R1,A
   \   000043   7404         MOV     A,#0x4
   \   000045   12....       LCALL   ?DEALLOC_XSTACK8
   \   000048   7F02         MOV     R7,#0x2
   \   00004A   02....       LJMP    ?BANKED_LEAVE_XDATA
   1990          }
   1991          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   1992          
   1993          /******************************************************************************
   1994           * @fn          ZDSecMgrRequestAppKey
   1995           *
   1996           * @brief       Request an application key with partner.
   1997           *
   1998           * @param       partExtAddr - [in] partner extended address
   1999           *
   2000           * @return      ZStatus_t
   2001           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2002          ZStatus_t ZDSecMgrRequestAppKey( uint8 *partExtAddr )
   \                     ZDSecMgrRequestAppKey:
   2003          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2004            ZStatus_t status;
   2005            APSME_RequestKeyReq_t req;
   2006          
   2007            req.dstAddr = 0;
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   7400         MOV     A,#0x0
   \   000016   F0           MOVX    @DPTR,A
   2008            req.keyType = KEY_TYPE_APP_MASTER;
   \   000017   7401         MOV     A,#0x1
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   7402         MOV     A,#0x2
   \   00001E   F0           MOVX    @DPTR,A
   2009          
   2010            req.partExtAddr = partExtAddr;
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   EE           MOV     A,R6
   \   000025   F0           MOVX    @DPTR,A
   \   000026   A3           INC     DPTR
   \   000027   EF           MOV     A,R7
   \   000028   F0           MOVX    @DPTR,A
   2011            status = APSME_RequestKeyReq( &req );
   \   000029                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000029   AA..         MOV     R2,?XSP + 0
   \   00002B   AB..         MOV     R3,?XSP + 1
   \   00002D   12....       LCALL   `??APSME_RequestKeyReq::?relay`; Banked call to: APSME_RequestKeyReq
   \   000030   E9           MOV     A,R1
   \   000031   F5..         MOV     ?V0,A
   2012          
   2013            return status;
   \   000033   A9..         MOV     R1,?V0
   \   000035   7404         MOV     A,#0x4
   \   000037   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003A   7F01         MOV     R7,#0x1
   \   00003C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2014          }
   2015          
   2016          #if ( ZG_BUILD_JOINING_TYPE )
   2017          /******************************************************************************
   2018           * @fn          ZDSecMgrSetupPartner
   2019           *
   2020           * @brief       Setup for application key partner.
   2021           *
   2022           * @param       partNwkAddr - [in] partner network address
   2023           *
   2024           * @return      ZStatus_t
   2025           */
   2026          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   2027          {
   2028            AddrMgrEntry_t entry;
   2029            ZStatus_t      status;
   2030          
   2031            status = ZFailure;
   2032          
   2033            // update the address manager
   2034            entry.user    = ADDRMGR_USER_SECURITY;
   2035            entry.nwkAddr = partNwkAddr;
   2036            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   2037          
   2038            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   2039            {
   2040              status = ZSuccess;
   2041          
   2042              // check for address discovery
   2043              if ( partNwkAddr == INVALID_NODE_ADDR )
   2044              {
   2045                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2046              }
   2047              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   2048              {
   2049                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2050              }
   2051            }
   2052          
   2053            return status;
   2054          }
   2055          #endif // ( ZG_BUILD_JOINING_TYPE )
   2056          
   2057          #if ( ZG_BUILD_COORDINATOR_TYPE )
   2058          /******************************************************************************
   2059           * @fn          ZDSecMgrAppKeyTypeSet
   2060           *
   2061           * @brief       Set application key type.
   2062           *
   2063           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   2064           *                                                   KEY_TYPE_APP_LINK@3
   2065           *
   2066           * @return      ZStatus_t
   2067           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2068          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   \                     ZDSecMgrAppKeyTypeSet:
   2069          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   E9           MOV     A,R1
   \   000005   F8           MOV     R0,A
   2070            if ( keyType == KEY_TYPE_APP_LINK )
   \   000006   7403         MOV     A,#0x3
   \   000008   68           XRL     A,R0
   \   000009   7008         JNZ     ??ZDSecMgrAppKeyTypeSet_0
   2071            {
   2072              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   \   00000B   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   00000E   7403         MOV     A,#0x3
   \   000010   F0           MOVX    @DPTR,A
   \   000011   8006         SJMP    ??ZDSecMgrAppKeyTypeSet_1
   2073            }
   2074            else
   2075            {
   2076              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   \                     ??ZDSecMgrAppKeyTypeSet_0:
   \   000013   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000016   7402         MOV     A,#0x2
   \   000018   F0           MOVX    @DPTR,A
   2077            }
   2078          
   2079            return ZSuccess;
   \                     ??ZDSecMgrAppKeyTypeSet_1:
   \   000019   7900         MOV     R1,#0x0
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET
   2080          }
   2081          #endif
   2082          
   2083          /******************************************************************************
   2084           * ZigBee Device Security Manager - Stub Implementations
   2085           */
   2086          
   2087          
   2088          /******************************************************************************
   2089           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   2090           *
   2091           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   2092           *
   2093           * @param       extAddr - [in] EXT address
   2094           * @param       data    - [in] APSME_LinkKeyData_t
   2095           *
   2096           * @return      ZStatus_t
   2097           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2098          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   2099          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000   74ED         MOV     A,#-0x13
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 19
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V4,R2
   \   00000C   8B..         MOV     ?V5,R3
   \   00000E   8C..         MOV     ?V6,R4
   \   000010   8D..         MOV     ?V7,R5
   2100            ZStatus_t status;
   2101            ZDSecMgrEntry_t* entry;
   2102            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   \   000012   75..00       MOV     ?V0,#0x0
   \   000015   75..00       MOV     ?V1,#0x0
   2103            uint16 Index;
   2104          
   2105            // lookup entry index for specified EXT address
   2106            status = ZDSecMgrEntryLookupExtGetIndex( extAddr, &entry, &Index );
   \   000018                ; Setup parameters for call to function ZDSecMgrEntryLookupExtGetIndex
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP100_8
   \   00001D   88..         MOV     ?V8,R0
   \   00001F   89..         MOV     ?V9,R1
   \   000021   78..         MOV     R0,#?V8
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   7402         MOV     A,#0x2
   \   000028   12....       LCALL   ?XSTACK_DISP102_8
   \   00002B   AA..         MOV     R2,?V4
   \   00002D   AB..         MOV     R3,?V5
   \   00002F   12....       LCALL   `??ZDSecMgrEntryLookupExtGetIndex::?relay`; Banked call to: ZDSecMgrEntryLookupExtGetIndex
   \   000032   7402         MOV     A,#0x2
   \   000034   12....       LCALL   ?DEALLOC_XSTACK8
   \   000037   E9           MOV     A,R1
   \   000038   F5..         MOV     ?V2,A
   2107          
   2108            if ( status == ZSuccess )
   \   00003A   E5..         MOV     A,?V2
   \   00003C   6003         JZ      $+5
   \   00003E   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   2109            {
   2110              // point to NV item
   2111              entry->keyNvId = ZCD_NV_APS_LINK_KEY_DATA_START + Index;
   \   000041   7402         MOV     A,#0x2
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   E0           MOVX    A,@DPTR
   \   000047   2401         ADD     A,#0x1
   \   000049   FA           MOV     R2,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   3402         ADDC    A,#0x2
   \   00004E   FB           MOV     R3,A
   \   00004F   85..82       MOV     DPL,?XSP + 0
   \   000052   85..83       MOV     DPH,?XSP + 1
   \   000055   E0           MOVX    A,@DPTR
   \   000056   F8           MOV     R0,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F583         MOV     DPH,A
   \   00005B   8882         MOV     DPL,R0
   \   00005D   A3           INC     DPTR
   \   00005E   A3           INC     DPTR
   \   00005F   EA           MOV     A,R2
   \   000060   F0           MOVX    @DPTR,A
   \   000061   A3           INC     DPTR
   \   000062   EB           MOV     A,R3
   \   000063   F0           MOVX    @DPTR,A
   2112          
   2113              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000064                ; Setup parameters for call to function osal_mem_alloc
   \   000064   7A18         MOV     R2,#0x18
   \   000066   7B00         MOV     R3,#0x0
   \   000068   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00006B   8A..         MOV     ?V8,R2
   \   00006D   8B..         MOV     ?V9,R3
   \   00006F   85....       MOV     ?V0,?V8
   \   000072   85....       MOV     ?V1,?V9
   2114          
   2115              if (pApsLinkKey != NULL)
   \   000075   E5..         MOV     A,?V0
   \   000077   45..         ORL     A,?V1
   \   000079   7003         JNZ     $+5
   \   00007B   02....       LJMP    ??APSME_LinkKeySet_0 & 0xFFFF
   2116              {
   2117                // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2118                osal_nv_read( entry->keyNvId, 0,
   2119                             sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   00007E                ; Setup parameters for call to function osal_nv_read
   \   00007E   78..         MOV     R0,#?V0
   \   000080   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000083   75..18       MOV     ?V8,#0x18
   \   000086   75..00       MOV     ?V9,#0x0
   \   000089   78..         MOV     R0,#?V8
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008E   7C00         MOV     R4,#0x0
   \   000090   7D00         MOV     R5,#0x0
   \   000092   7404         MOV     A,#0x4
   \   000094   12....       LCALL   ?XSTACK_DISP0_8
   \   000097   E0           MOVX    A,@DPTR
   \   000098   F8           MOV     R0,A
   \   000099   A3           INC     DPTR
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   F583         MOV     DPH,A
   \   00009D   8882         MOV     DPL,R0
   \   00009F   A3           INC     DPTR
   \   0000A0   A3           INC     DPTR
   \   0000A1   E0           MOVX    A,@DPTR
   \   0000A2   FA           MOV     R2,A
   \   0000A3   A3           INC     DPTR
   \   0000A4   E0           MOVX    A,@DPTR
   \   0000A5   FB           MOV     R3,A
   \   0000A6   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000A9   7404         MOV     A,#0x4
   \   0000AB   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AE   E9           MOV     A,R1
   2120          
   2121                // set new values of the key
   2122                osal_memcpy( pApsLinkKey->key, key, SEC_KEY_LEN );
   \   0000AF                ; Setup parameters for call to function osal_memcpy
   \   0000AF   85....       MOV     ?V8,?V6
   \   0000B2   85....       MOV     ?V9,?V7
   \   0000B5   75..00       MOV     ?V10,#0x0
   \   0000B8   78..         MOV     R0,#?V8
   \   0000BA   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   0000BD   7C10         MOV     R4,#0x10
   \   0000BF   7D00         MOV     R5,#0x0
   \   0000C1   AA..         MOV     R2,?V0
   \   0000C3   AB..         MOV     R3,?V1
   \   0000C5   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   0000C8   7403         MOV     A,#0x3
   \   0000CA   12....       LCALL   ?DEALLOC_XSTACK8
   2123                pApsLinkKey->rxFrmCntr = 0;
   \   0000CD   7C00         MOV     R4,#0x0
   \   0000CF   7D00         MOV     R5,#0x0
   \   0000D1   7E00         MOV     R6,#0x0
   \   0000D3   7F00         MOV     R7,#0x0
   \   0000D5   E5..         MOV     A,?V0
   \   0000D7   2414         ADD     A,#0x14
   \   0000D9   F582         MOV     DPL,A
   \   0000DB   E4           CLR     A
   \   0000DC   35..         ADDC    A,?V1
   \   0000DE   F583         MOV     DPH,A
   \   0000E0   EC           MOV     A,R4
   \   0000E1   F0           MOVX    @DPTR,A
   \   0000E2   A3           INC     DPTR
   \   0000E3   ED           MOV     A,R5
   \   0000E4   F0           MOVX    @DPTR,A
   \   0000E5   A3           INC     DPTR
   \   0000E6   EE           MOV     A,R6
   \   0000E7   F0           MOVX    @DPTR,A
   \   0000E8   A3           INC     DPTR
   \   0000E9   EF           MOV     A,R7
   \   0000EA   F0           MOVX    @DPTR,A
   2124                pApsLinkKey->txFrmCntr = 0;
   \   0000EB   7C00         MOV     R4,#0x0
   \   0000ED   7D00         MOV     R5,#0x0
   \   0000EF   7E00         MOV     R6,#0x0
   \   0000F1   7F00         MOV     R7,#0x0
   \   0000F3   E5..         MOV     A,?V0
   \   0000F5   2410         ADD     A,#0x10
   \   0000F7   F582         MOV     DPL,A
   \   0000F9   E4           CLR     A
   \   0000FA   35..         ADDC    A,?V1
   \   0000FC   F583         MOV     DPH,A
   \   0000FE   EC           MOV     A,R4
   \   0000FF   F0           MOVX    @DPTR,A
   \   000100   A3           INC     DPTR
   \   000101   ED           MOV     A,R5
   \   000102   F0           MOVX    @DPTR,A
   \   000103   A3           INC     DPTR
   \   000104   EE           MOV     A,R6
   \   000105   F0           MOVX    @DPTR,A
   \   000106   A3           INC     DPTR
   \   000107   EF           MOV     A,R7
   \   000108   F0           MOVX    @DPTR,A
   2125          
   2126                osal_nv_write( entry->keyNvId, 0,
   2127                              sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000109                ; Setup parameters for call to function osal_nv_write
   \   000109   78..         MOV     R0,#?V0
   \   00010B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00010E   75..18       MOV     ?V8,#0x18
   \   000111   75..00       MOV     ?V9,#0x0
   \   000114   78..         MOV     R0,#?V8
   \   000116   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000119   7C00         MOV     R4,#0x0
   \   00011B   7D00         MOV     R5,#0x0
   \   00011D   7404         MOV     A,#0x4
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   E0           MOVX    A,@DPTR
   \   000123   F8           MOV     R0,A
   \   000124   A3           INC     DPTR
   \   000125   E0           MOVX    A,@DPTR
   \   000126   F583         MOV     DPH,A
   \   000128   8882         MOV     DPL,R0
   \   00012A   A3           INC     DPTR
   \   00012B   A3           INC     DPTR
   \   00012C   E0           MOVX    A,@DPTR
   \   00012D   FA           MOV     R2,A
   \   00012E   A3           INC     DPTR
   \   00012F   E0           MOVX    A,@DPTR
   \   000130   FB           MOV     R3,A
   \   000131   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000134   7404         MOV     A,#0x4
   \   000136   12....       LCALL   ?DEALLOC_XSTACK8
   \   000139   E9           MOV     A,R1
   2128          
   2129                // clear copy of key in RAM
   2130                osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   00013A                ; Setup parameters for call to function osal_memset
   \   00013A   7C18         MOV     R4,#0x18
   \   00013C   7D00         MOV     R5,#0x0
   \   00013E   7900         MOV     R1,#0x0
   \   000140   AA..         MOV     R2,?V0
   \   000142   AB..         MOV     R3,?V1
   \   000144   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2131          
   2132                osal_mem_free(pApsLinkKey);
   \   000147                ; Setup parameters for call to function osal_mem_free
   \   000147   AA..         MOV     R2,?V0
   \   000149   AB..         MOV     R3,?V1
   \   00014B   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2133          
   2134                // set initial values for counters in RAM
   2135                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr = 0;
   \   00014E   7C00         MOV     R4,#0x0
   \   000150   7D00         MOV     R5,#0x0
   \   000152   7E00         MOV     R6,#0x0
   \   000154   7F00         MOV     R7,#0x0
   \   000156   85..82       MOV     DPL,?XSP + 0
   \   000159   85..83       MOV     DPH,?XSP + 1
   \   00015C   E0           MOVX    A,@DPTR
   \   00015D   F8           MOV     R0,A
   \   00015E   A3           INC     DPTR
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   F583         MOV     DPH,A
   \   000162   8882         MOV     DPL,R0
   \   000164   A3           INC     DPTR
   \   000165   A3           INC     DPTR
   \   000166   E0           MOVX    A,@DPTR
   \   000167   F8           MOV     R0,A
   \   000168   A3           INC     DPTR
   \   000169   E0           MOVX    A,@DPTR
   \   00016A   F9           MOV     R1,A
   \   00016B   E8           MOV     A,R0
   \   00016C   75F009       MOV     B,#0x9
   \   00016F   A4           MUL     AB
   \   000170   C8           XCH     A,R0
   \   000171   AAF0         MOV     R2,B
   \   000173   75F000       MOV     B,#0x0
   \   000176   A4           MUL     AB
   \   000177   2A           ADD     A,R2
   \   000178   FA           MOV     R2,A
   \   000179   75F009       MOV     B,#0x9
   \   00017C   E9           MOV     A,R1
   \   00017D   A4           MUL     AB
   \   00017E   2A           ADD     A,R2
   \   00017F   F9           MOV     R1,A
   \   000180   74..         MOV     A,#(ApsLinkKeyFrmCntr + 247) & 0xff
   \   000182   28           ADD     A,R0
   \   000183   F582         MOV     DPL,A
   \   000185   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4617) >> 8) & 0xff
   \   000187   39           ADDC    A,R1
   \   000188   F583         MOV     DPH,A
   \   00018A   EC           MOV     A,R4
   \   00018B   F0           MOVX    @DPTR,A
   \   00018C   A3           INC     DPTR
   \   00018D   ED           MOV     A,R5
   \   00018E   F0           MOVX    @DPTR,A
   \   00018F   A3           INC     DPTR
   \   000190   EE           MOV     A,R6
   \   000191   F0           MOVX    @DPTR,A
   \   000192   A3           INC     DPTR
   \   000193   EF           MOV     A,R7
   \   000194   F0           MOVX    @DPTR,A
   2136                ApsLinkKeyFrmCntr[entry->keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr = 0;
   \   000195   7C00         MOV     R4,#0x0
   \   000197   7D00         MOV     R5,#0x0
   \   000199   7E00         MOV     R6,#0x0
   \   00019B   7F00         MOV     R7,#0x0
   \   00019D   85..82       MOV     DPL,?XSP + 0
   \   0001A0   85..83       MOV     DPH,?XSP + 1
   \   0001A3   E0           MOVX    A,@DPTR
   \   0001A4   F8           MOV     R0,A
   \   0001A5   A3           INC     DPTR
   \   0001A6   E0           MOVX    A,@DPTR
   \   0001A7   F583         MOV     DPH,A
   \   0001A9   8882         MOV     DPL,R0
   \   0001AB   A3           INC     DPTR
   \   0001AC   A3           INC     DPTR
   \   0001AD   E0           MOVX    A,@DPTR
   \   0001AE   F8           MOV     R0,A
   \   0001AF   A3           INC     DPTR
   \   0001B0   E0           MOVX    A,@DPTR
   \   0001B1   F9           MOV     R1,A
   \   0001B2   E8           MOV     A,R0
   \   0001B3   75F009       MOV     B,#0x9
   \   0001B6   A4           MUL     AB
   \   0001B7   C8           XCH     A,R0
   \   0001B8   AAF0         MOV     R2,B
   \   0001BA   75F000       MOV     B,#0x0
   \   0001BD   A4           MUL     AB
   \   0001BE   2A           ADD     A,R2
   \   0001BF   FA           MOV     R2,A
   \   0001C0   75F009       MOV     B,#0x9
   \   0001C3   E9           MOV     A,R1
   \   0001C4   A4           MUL     AB
   \   0001C5   2A           ADD     A,R2
   \   0001C6   F9           MOV     R1,A
   \   0001C7   74..         MOV     A,#(ApsLinkKeyFrmCntr + 251) & 0xff
   \   0001C9   28           ADD     A,R0
   \   0001CA   F582         MOV     DPL,A
   \   0001CC   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4613) >> 8) & 0xff
   \   0001CE   39           ADDC    A,R1
   \   0001CF   F583         MOV     DPH,A
   \   0001D1   EC           MOV     A,R4
   \   0001D2   F0           MOVX    @DPTR,A
   \   0001D3   A3           INC     DPTR
   \   0001D4   ED           MOV     A,R5
   \   0001D5   F0           MOVX    @DPTR,A
   \   0001D6   A3           INC     DPTR
   \   0001D7   EE           MOV     A,R6
   \   0001D8   F0           MOVX    @DPTR,A
   \   0001D9   A3           INC     DPTR
   \   0001DA   EF           MOV     A,R7
   \   0001DB   F0           MOVX    @DPTR,A
   2137              }
   2138            }
   2139          
   2140            return status;
   \                     ??APSME_LinkKeySet_0:
   \   0001DC   A9..         MOV     R1,?V2
   \   0001DE   7404         MOV     A,#0x4
   \   0001E0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001E3   7F0B         MOV     R7,#0xb
   \   0001E5   02....       LJMP    ?BANKED_LEAVE_XDATA
   2141          }
   2142          
   2143          /******************************************************************************
   2144           * @fn          ZDSecMgrAuthenticationSet
   2145           *
   2146           * @brief       Mark the specific device as authenticated or not
   2147           *
   2148           * @param       extAddr - [in] EXT address
   2149           * @param       option  - [in] authenticated or not
   2150           *
   2151           * @return      ZStatus_t
   2152           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2153          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   2154          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   89..         MOV     ?V1,R1
   2155            ZStatus_t        status;
   2156            ZDSecMgrEntry_t* entry;
   2157          
   2158          
   2159            // lookup entry index for specified EXT address
   2160            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000010                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000010   AC..         MOV     R4,?XSP + 0
   \   000012   AD..         MOV     R5,?XSP + 1
   \   000014   EE           MOV     A,R6
   \   000015   FA           MOV     R2,A
   \   000016   EF           MOV     A,R7
   \   000017   FB           MOV     R3,A
   \   000018   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0,A
   2161          
   2162            if ( status == ZSuccess )
   \   00001E   E5..         MOV     A,?V0
   \   000020   7019         JNZ     ??ZDSecMgrAuthenticationSet_0
   2163            {
   2164              entry->authenticateOption = option;
   \   000022   E5..         MOV     A,?V1
   \   000024   C0E0         PUSH    A
   \   000026   85..82       MOV     DPL,?XSP + 0
   \   000029   85..83       MOV     DPH,?XSP + 1
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   F8           MOV     R0,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F583         MOV     DPH,A
   \   000032   8882         MOV     DPL,R0
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   D0E0         POP     A
   \   00003A   F0           MOVX    @DPTR,A
   2165            }
   2166          
   2167            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   00003B   A9..         MOV     R1,?V0
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000042   7F02         MOV     R7,#0x2
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
   2168          }
   2169          
   2170          /******************************************************************************
   2171           * @fn          ZDSecMgrAuthenticationCheck
   2172           *
   2173           * @brief       Check if the specific device has been authenticated or not
   2174           *              For non-trust center device, always return TRUE
   2175           *
   2176           * @param       shortAddr - [in] short address
   2177           *
   2178           * @return      TRUE @ authenticated with CBKE
   2179           *              FALSE @ not authenticated
   2180           */
   2181          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2182          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   2183          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2184          #if defined (TC_LINKKEY_JOIN)
   2185          
   2186            ZDSecMgrEntry_t* entry;
   2187            uint8 extAddr[Z_EXTADDR_LEN];
   2188          
   2189            // If the local device is not the trust center, always return TRUE
   2190            APSME_GetRequest( apsTrustCenterAddress, 0, extAddr );
   2191            if ( ! osal_ExtAddrEqual( extAddr , NLME_GetExtAddr() ) )
   2192            {
   2193              return TRUE;
   2194            }
   2195            // Otherwise, check the authentication option
   2196            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   2197            {
   2198              // lookup entry index for specified EXT address
   2199              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   2200              {
   2201                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   2202                {
   2203                  return TRUE;
   2204                }
   2205                else
   2206                {
   2207                  return FALSE;
   2208                }
   2209              }
   2210              else
   2211              {
   2212                // it may have been secured with TCLK only
   2213                uint16    ami;
   2214          
   2215                // lookup address index in address manager
   2216                if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   2217                {
   2218                  return TRUE;
   2219                }
   2220              }
   2221            }
   2222            return FALSE;
   2223          
   2224          #else
   2225            (void)shortAddr;  // Intentionally unreferenced parameter
   2226          
   2227            // For non AMI/SE Profile, perform no check and always return TRUE.
   2228            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   2229          
   2230          #endif // TC_LINKKEY_JOIN
   2231          }
   2232          
   2233          /******************************************************************************
   2234           * @fn          ZDSecMgrLinkKeyNVIdGet (stubs APSME_LinkKeyNVIdGet)
   2235           *
   2236           * @brief       Get Key NV ID for specified NWK address.
   2237           *
   2238           * @param       extAddr - [in] EXT address
   2239           * @param       keyNvId - [out] NV ID
   2240           *
   2241           * @return      ZStatus_t
   2242           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2243          ZStatus_t ZDSecMgrLinkKeyNVIdGet(uint8* extAddr, uint16 *pKeyNvId)
   \                     APSME_LinkKeyNVIdGet:
   2244          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0,R4
   \   000010   8D..         MOV     ?V1,R5
   2245            ZStatus_t status;
   2246            ZDSecMgrEntry_t* entry;
   2247          
   2248            // lookup entry index for specified NWK address
   2249            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   000012                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   000012   AC..         MOV     R4,?XSP + 0
   \   000014   AD..         MOV     R5,?XSP + 1
   \   000016   EE           MOV     A,R6
   \   000017   FA           MOV     R2,A
   \   000018   EF           MOV     A,R7
   \   000019   FB           MOV     R3,A
   \   00001A   12....       LCALL   `??ZDSecMgrEntryLookupExt::?relay`; Banked call to: ZDSecMgrEntryLookupExt
   \   00001D   E9           MOV     A,R1
   \   00001E   F5..         MOV     ?V2,A
   2250          
   2251            if ( status == ZSuccess )
   \   000020   E5..         MOV     A,?V2
   \   000022   7022         JNZ     ??APSME_LinkKeyNVIdGet_0
   2252            {
   2253              // return the index to the NV table
   2254              *pKeyNvId = entry->keyNvId;
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F583         MOV     DPH,A
   \   000030   8882         MOV     DPL,R0
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F8           MOV     R0,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F9           MOV     R1,A
   \   000039   85..82       MOV     DPL,?V0
   \   00003C   85..83       MOV     DPH,?V1
   \   00003F   E8           MOV     A,R0
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   E9           MOV     A,R1
   \   000043   F0           MOVX    @DPTR,A
   \   000044   800D         SJMP    ??APSME_LinkKeyNVIdGet_1
   2255            }
   2256            else
   2257            {
   2258              *pKeyNvId = SEC_NO_KEY_NV_ID;
   \                     ??APSME_LinkKeyNVIdGet_0:
   \   000046   85..82       MOV     DPL,?V0
   \   000049   85..83       MOV     DPH,?V1
   \   00004C   7400         MOV     A,#0x0
   \   00004E   F0           MOVX    @DPTR,A
   \   00004F   A3           INC     DPTR
   \   000050   7400         MOV     A,#0x0
   \   000052   F0           MOVX    @DPTR,A
   2259            }
   2260          
   2261            return status;
   \                     ??APSME_LinkKeyNVIdGet_1:
   \   000053   A9..         MOV     R1,?V2
   \   000055   7402         MOV     A,#0x2
   \   000057   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005A   7F03         MOV     R7,#0x3
   \   00005C   02....       LJMP    ?BANKED_LEAVE_XDATA
   2262          }
   2263          
   2264          /******************************************************************************
   2265           * @fn          ZDSecMgrIsLinkKeyValid (stubs APSME_IsLinkKeyValid)
   2266           *
   2267           * @brief       Verifies if Link Key in NV has been set.
   2268           *
   2269           * @param       extAddr - [in] EXT address
   2270           *
   2271           * @return      TRUE - Link Key has been established
   2272           *              FALSE - Link Key in NV has default value.
   2273           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2274          uint8 ZDSecMgrIsLinkKeyValid(uint8* extAddr)
   \                     APSME_IsLinkKeyValid:
   2275          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 18
   \   000005   74EE         MOV     A,#-0x12
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2276            APSME_LinkKeyData_t *pKeyData;
   2277            uint16 apsLinkKeyNvId;
   2278            uint8 nullKey[SEC_KEY_LEN];
   2279            uint8 status = FALSE;
   \   00000E   75..00       MOV     ?V0,#0x0
   2280          
   2281            // initialize default vealue to compare to
   2282            osal_memset(nullKey, 0x00, SEC_KEY_LEN);
   \   000011                ; Setup parameters for call to function osal_memset
   \   000011   7C10         MOV     R4,#0x10
   \   000013   7D00         MOV     R5,#0x0
   \   000015   7900         MOV     R1,#0x0
   \   000017   7402         MOV     A,#0x2
   \   000019   12....       LCALL   ?XSTACK_DISP101_8
   \   00001C   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2283          
   2284            // check for APS link NV ID
   2285            APSME_LinkKeyNVIdGet( extAddr, &apsLinkKeyNvId );
   \   00001F                ; Setup parameters for call to function APSME_LinkKeyNVIdGet
   \   00001F   AC..         MOV     R4,?XSP + 0
   \   000021   AD..         MOV     R5,?XSP + 1
   \   000023   EE           MOV     A,R6
   \   000024   FA           MOV     R2,A
   \   000025   EF           MOV     A,R7
   \   000026   FB           MOV     R3,A
   \   000027   12....       LCALL   `??APSME_LinkKeyNVIdGet::?relay`; Banked call to: APSME_LinkKeyNVIdGet
   \   00002A   E9           MOV     A,R1
   2286          
   2287            if (apsLinkKeyNvId != SEC_NO_KEY_NV_ID )
   \   00002B   85..82       MOV     DPL,?XSP + 0
   \   00002E   85..83       MOV     DPH,?XSP + 1
   \   000031   E0           MOVX    A,@DPTR
   \   000032   F8           MOV     R0,A
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \   000035   F9           MOV     R1,A
   \   000036   E8           MOV     A,R0
   \   000037   49           ORL     A,R1
   \   000038   7003         JNZ     $+5
   \   00003A   02....       LJMP    ??APSME_IsLinkKeyValid_0 & 0xFFFF
   2288            {
   2289              pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00003D                ; Setup parameters for call to function osal_mem_alloc
   \   00003D   7A18         MOV     R2,#0x18
   \   00003F   7B00         MOV     R3,#0x0
   \   000041   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000044   8A..         MOV     ?V4,R2
   \   000046   8B..         MOV     ?V5,R3
   \   000048   85....       MOV     ?V2,?V4
   \   00004B   85....       MOV     ?V3,?V5
   2290          
   2291              if (pKeyData != NULL)
   \   00004E   E5..         MOV     A,?V2
   \   000050   45..         ORL     A,?V3
   \   000052   606C         JZ      ??APSME_IsLinkKeyValid_0
   2292              {
   2293                // retrieve key from NV
   2294                if ( osal_nv_read( apsLinkKeyNvId, 0,
   2295                                  sizeof(APSME_LinkKeyData_t), pKeyData) == ZSUCCESS)
   \   000054                ; Setup parameters for call to function osal_nv_read
   \   000054   78..         MOV     R0,#?V2
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000059   75..18       MOV     ?V4,#0x18
   \   00005C   75..00       MOV     ?V5,#0x0
   \   00005F   78..         MOV     R0,#?V4
   \   000061   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000064   7C00         MOV     R4,#0x0
   \   000066   7D00         MOV     R5,#0x0
   \   000068   7404         MOV     A,#0x4
   \   00006A   12....       LCALL   ?XSTACK_DISP0_8
   \   00006D   E0           MOVX    A,@DPTR
   \   00006E   FA           MOV     R2,A
   \   00006F   A3           INC     DPTR
   \   000070   E0           MOVX    A,@DPTR
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000075   7404         MOV     A,#0x4
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007A   E9           MOV     A,R1
   \   00007B   702F         JNZ     ??APSME_IsLinkKeyValid_1
   2296                {
   2297                  // if stored key is different than default value, then a key has been established
   2298                  if (!osal_memcmp(pKeyData, nullKey, SEC_KEY_LEN))
   \   00007D                ; Setup parameters for call to function osal_memcmp
   \   00007D   7402         MOV     A,#0x2
   \   00007F   12....       LCALL   ?XSTACK_DISP100_8
   \   000082   88..         MOV     ?V4,R0
   \   000084   89..         MOV     ?V5,R1
   \   000086   75..00       MOV     ?V6,#0x0
   \   000089   78..         MOV     R0,#?V4
   \   00008B   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00008E   7C10         MOV     R4,#0x10
   \   000090   7D00         MOV     R5,#0x0
   \   000092   85..82       MOV     DPL,?V2
   \   000095   85..83       MOV     DPH,?V3
   \   000098   A982         MOV     R1,DPL
   \   00009A   AA83         MOV     R2,DPH
   \   00009C   7B00         MOV     R3,#0x0
   \   00009E   12....       LCALL   `??osal_memcmp::?relay`; Banked call to: osal_memcmp
   \   0000A1   7403         MOV     A,#0x3
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A6   E9           MOV     A,R1
   \   0000A7   7003         JNZ     ??APSME_IsLinkKeyValid_1
   2299                  {
   2300                    status = TRUE;
   \   0000A9   75..01       MOV     ?V0,#0x1
   2301                  }
   2302                }
   2303          
   2304                // clear copy of key in RAM
   2305                osal_memset(pKeyData, 0x00, sizeof(APSME_LinkKeyData_t));
   \                     ??APSME_IsLinkKeyValid_1:
   \   0000AC                ; Setup parameters for call to function osal_memset
   \   0000AC   7C18         MOV     R4,#0x18
   \   0000AE   7D00         MOV     R5,#0x0
   \   0000B0   7900         MOV     R1,#0x0
   \   0000B2   AA..         MOV     R2,?V2
   \   0000B4   AB..         MOV     R3,?V3
   \   0000B6   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2306          
   2307                osal_mem_free(pKeyData);
   \   0000B9                ; Setup parameters for call to function osal_mem_free
   \   0000B9   AA..         MOV     R2,?V2
   \   0000BB   AB..         MOV     R3,?V3
   \   0000BD   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2308              }
   2309            }
   2310          
   2311            return status;
   \                     ??APSME_IsLinkKeyValid_0:
   \   0000C0   A9..         MOV     R1,?V0
   \   0000C2   7412         MOV     A,#0x12
   \   0000C4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C7   7F07         MOV     R7,#0x7
   \   0000C9   02....       LJMP    ?BANKED_LEAVE_XDATA
   2312          }
   2313          
   2314          /******************************************************************************
   2315           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   2316           *
   2317           * @brief       Verify and process key transportation to child.
   2318           *
   2319           * @param       ind - [in] APSME_TransportKeyInd_t
   2320           *
   2321           * @return      uint8 - success(TRUE:FALSE)
   2322           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2323          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   2324          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2325            // verify from Trust Center
   2326            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000009   8E82         MOV     DPL,R6
   \   00000B   8F83         MOV     DPH,R7
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F8           MOV     R0,A
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F9           MOV     R1,A
   \   000012   E8           MOV     A,R0
   \   000013   49           ORL     A,R1
   \   000014   702F         JNZ     ??APSME_KeyFwdToChild_0
   2327            {
   2328              // check for initial NWK key
   2329              if ( ( ind->keyType == KEY_TYPE_NWK ) ||
   2330                   ( ind->keyType == 6            ) )
   \   000016   8E82         MOV     DPL,R6
   \   000018   8F83         MOV     DPH,R7
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   6401         XRL     A,#0x1
   \   00001F   600B         JZ      ??APSME_KeyFwdToChild_1
   \   000021   8E82         MOV     DPL,R6
   \   000023   8F83         MOV     DPH,R7
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6406         XRL     A,#0x6
   \   00002A   7015         JNZ     ??APSME_KeyFwdToChild_2
   2331              {
   2332                // set association status to authenticated
   2333                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_1:
   \   00002C                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002C                ; Setup parameters for call to function AssocGetWithExt
   \   00002C   8E82         MOV     DPL,R6
   \   00002E   8F83         MOV     DPH,R7
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FA           MOV     R2,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FB           MOV     R3,A
   \   00003B   12....       LCALL   `??AssocGetWithExt::?relay`; Banked call to: AssocGetWithExt
   \   00003E   12....       LCALL   `??ZDSecMgrAssocDeviceAuth::?relay`; Banked call to: ZDSecMgrAssocDeviceAuth
   2334              }
   2335          
   2336              return TRUE;
   \                     ??APSME_KeyFwdToChild_2:
   \   000041   7901         MOV     R1,#0x1
   \   000043   8002         SJMP    ??APSME_KeyFwdToChild_3
   2337            }
   2338          
   2339            return FALSE;
   \                     ??APSME_KeyFwdToChild_0:
   \   000045   7900         MOV     R1,#0x0
   \                     ??APSME_KeyFwdToChild_3:
   \   000047   7F01         MOV     R7,#0x1
   \   000049   02....       LJMP    ?BANKED_LEAVE_XDATA
   2340          }
   2341          
   2342          /******************************************************************************
   2343           * @fn          ZDSecMgrAddLinkKey
   2344           *
   2345           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   2346           *              as authenticated in the authenticateOption. Note that this function
   2347           *              is hardwared to CBKE right now.
   2348           *
   2349           * @param       shortAddr - short address of the partner device
   2350           * @param       extAddr - extended address of the partner device
   2351           * @param       key - link key
   2352           *
   2353           * @return      ZStatus_t
   2354           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2355          ZStatus_t ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   2356          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V2,R2
   \   00000C   8B..         MOV     ?V3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7412         MOV     A,#0x12
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V1,A
   2357            uint16           ami;
   2358            ZDSecMgrEntry_t* entry;
   2359          
   2360            /* Store the device address in the addr manager */
   2361            if( ZDSecMgrAddrStore( shortAddr, extAddr, &ami ) != ZSuccess )
   \   00001E                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP100_8
   \   000023   88..         MOV     ?V4,R0
   \   000025   89..         MOV     ?V5,R1
   \   000027   78..         MOV     R0,#?V4
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   EE           MOV     A,R6
   \   00002D   FC           MOV     R4,A
   \   00002E   EF           MOV     A,R7
   \   00002F   FD           MOV     R5,A
   \   000030   AA..         MOV     R2,?V2
   \   000032   AB..         MOV     R3,?V3
   \   000034   12....       LCALL   `??ZDSecMgrAddrStore::?relay`; Banked call to: ZDSecMgrAddrStore
   \   000037   7402         MOV     A,#0x2
   \   000039   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003C   E9           MOV     A,R1
   \   00003D   6004         JZ      ??ZDSecMgrAddLinkKey_0
   2362            {
   2363              /* Adding to Addr Manager fails */
   2364              return ZFailure;
   \   00003F   7901         MOV     R1,#0x1
   \   000041   805F         SJMP    ??ZDSecMgrAddLinkKey_1
   2365            }
   2366          
   2367            /* Lookup entry using specified address index */
   2368            ZDSecMgrEntryLookupAMI( ami, &entry );
   \                     ??ZDSecMgrAddLinkKey_0:
   \   000043                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000043   AC..         MOV     R4,?XSP + 0
   \   000045   AD..         MOV     R5,?XSP + 1
   \   000047   7402         MOV     A,#0x2
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   FA           MOV     R2,A
   \   00004E   A3           INC     DPTR
   \   00004F   E0           MOVX    A,@DPTR
   \   000050   FB           MOV     R3,A
   \   000051   12....       LCALL   `??ZDSecMgrEntryLookupAMI::?relay`; Banked call to: ZDSecMgrEntryLookupAMI
   \   000054   E9           MOV     A,R1
   2369          
   2370            // If no existing entry, create one
   2371            if ( entry == NULL )
   \   000055   85..82       MOV     DPL,?XSP + 0
   \   000058   85..83       MOV     DPH,?XSP + 1
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   F8           MOV     R0,A
   \   00005D   A3           INC     DPTR
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   F9           MOV     R1,A
   \   000060   E8           MOV     A,R0
   \   000061   49           ORL     A,R1
   \   000062   702D         JNZ     ??ZDSecMgrAddLinkKey_2
   2372            {
   2373              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000064                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000064   AA..         MOV     R2,?XSP + 0
   \   000066   AB..         MOV     R3,?XSP + 1
   \   000068   12....       LCALL   `??ZDSecMgrEntryNew::?relay`; Banked call to: ZDSecMgrEntryNew
   \   00006B   E9           MOV     A,R1
   \   00006C   701F         JNZ     ??ZDSecMgrAddLinkKey_3
   2374              {
   2375                entry->ami = ami;
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   E0           MOVX    A,@DPTR
   \   000074   FA           MOV     R2,A
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   FB           MOV     R3,A
   \   000078   85..82       MOV     DPL,?XSP + 0
   \   00007B   85..83       MOV     DPH,?XSP + 1
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F8           MOV     R0,A
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F583         MOV     DPH,A
   \   000084   8882         MOV     DPL,R0
   \   000086   EA           MOV     A,R2
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   EB           MOV     A,R3
   \   00008A   F0           MOVX    @DPTR,A
   \   00008B   8004         SJMP    ??ZDSecMgrAddLinkKey_2
   2376              }
   2377              else
   2378              {
   2379                /* Security Manager full */
   2380                return ZBufferFull;
   \                     ??ZDSecMgrAddLinkKey_3:
   \   00008D   7911         MOV     R1,#0x11
   \   00008F   8011         SJMP    ??ZDSecMgrAddLinkKey_1
   2381              }
   2382            }
   2383            // Write the link key
   2384            APSME_LinkKeySet( extAddr, key );
   \                     ??ZDSecMgrAddLinkKey_2:
   \   000091                ; Setup parameters for call to function APSME_LinkKeySet
   \   000091   AC..         MOV     R4,?V0
   \   000093   AD..         MOV     R5,?V1
   \   000095   EE           MOV     A,R6
   \   000096   FA           MOV     R2,A
   \   000097   EF           MOV     A,R7
   \   000098   FB           MOV     R3,A
   \   000099   12....       LCALL   `??APSME_LinkKeySet::?relay`; Banked call to: APSME_LinkKeySet
   \   00009C   E9           MOV     A,R1
   2385          
   2386          #if defined (TC_LINKKEY_JOIN)
   2387            // Mark the device as authenticated.
   2388            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   2389          #endif
   2390          
   2391          #if defined NV_RESTORE
   2392            ZDSecMgrWriteNV();  // Write the new established link key to NV.
   \   00009D                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   00009D   12....       LCALL   `??ZDSecMgrWriteNV::?relay`; Banked call to: ZDSecMgrWriteNV
   2393          #endif
   2394          
   2395            return ZSuccess;
   \   0000A0   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAddLinkKey_1:
   \   0000A2   7404         MOV     A,#0x4
   \   0000A4   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A7   7F06         MOV     R7,#0x6
   \   0000A9   02....       LJMP    ?BANKED_LEAVE_XDATA
   2396          }
   2397          
   2398          /******************************************************************************
   2399           * @fn          ZDSecMgrInitNV
   2400           *
   2401           * @brief       Initialize the SecMgr entry data in NV with all values set to 0
   2402           *
   2403           * @param       none
   2404           *
   2405           * @return      uint8 - <osal_nv_item_init> return codes
   2406           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2407          uint8 ZDSecMgrInitNV(void)
   \                     ZDSecMgrInitNV:
   2408          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2409          
   2410            uint8 rtrn = osal_nv_item_init(ZCD_NV_APS_LINK_KEY_TABLE,
   2411                          (sizeof(nvDeviceListHdr_t) + (sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX)), NULL);
   \   00000A                ; Setup parameters for call to function osal_nv_item_init
   \   00000A   E4           CLR     A
   \   00000B   F5..         MOV     ?V0,A
   \   00000D   F5..         MOV     ?V1,A
   \   00000F   78..         MOV     R0,#?V0
   \   000011   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000014   7C11         MOV     R4,#0x11
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7A4C         MOV     R2,#0x4c
   \   00001A   7B00         MOV     R3,#0x0
   \   00001C   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00001F   7402         MOV     A,#0x2
   \   000021   12....       LCALL   ?DEALLOC_XSTACK8
   \   000024   E9           MOV     A,R1
   \   000025   FE           MOV     R6,A
   2412          
   2413            // If the item does not already exist, set all values to 0
   2414            if (rtrn != SUCCESS)
   \   000026   EE           MOV     A,R6
   \   000027   6036         JZ      ??ZDSecMgrInitNV_0
   2415            {
   2416              nvDeviceListHdr_t hdr;
   2417              hdr.numRecs = 0;
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   7400         MOV     A,#0x0
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   7400         MOV     A,#0x0
   \   000035   F0           MOVX    @DPTR,A
   2418              osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   000036                ; Setup parameters for call to function osal_nv_write
   \   000036   A8..         MOV     R0,?XSP + 0
   \   000038   A9..         MOV     R1,?XSP + 1
   \   00003A   88..         MOV     ?V0,R0
   \   00003C   89..         MOV     ?V1,R1
   \   00003E   78..         MOV     R0,#?V0
   \   000040   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000043   75..02       MOV     ?V0,#0x2
   \   000046   75..00       MOV     ?V1,#0x0
   \   000049   78..         MOV     R0,#?V0
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   7C00         MOV     R4,#0x0
   \   000050   7D00         MOV     R5,#0x0
   \   000052   7A4C         MOV     R2,#0x4c
   \   000054   7B00         MOV     R3,#0x0
   \   000056   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000059   7404         MOV     A,#0x4
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005E   E9           MOV     A,R1
   2419            }
   2420          
   2421            rtrn |= osal_nv_item_init( ZCD_NV_TRUSTCENTER_ADDR, Z_EXTADDR_LEN,
   2422                                       zgApsTrustCenterAddr );
   \                     ??ZDSecMgrInitNV_0:
   \   00005F                ; Setup parameters for call to function osal_nv_item_init
   \   00005F   75....       MOV     ?V0,#zgApsTrustCenterAddr & 0xff
   \   000062   75....       MOV     ?V1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   000065   78..         MOV     R0,#?V0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   7C08         MOV     R4,#0x8
   \   00006C   7D00         MOV     R5,#0x0
   \   00006E   7A71         MOV     R2,#0x71
   \   000070   7B00         MOV     R3,#0x0
   \   000072   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000075   7402         MOV     A,#0x2
   \   000077   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007A   E9           MOV     A,R1
   \   00007B   CE           XCH     A,R6
   \   00007C   4E           ORL     A,R6
   \   00007D   CE           XCH     A,R6
   2423          
   2424            return rtrn;
   \   00007E   EE           MOV     A,R6
   \   00007F   F9           MOV     R1,A
   \   000080   7402         MOV     A,#0x2
   \   000082   12....       LCALL   ?DEALLOC_XSTACK8
   \   000085   7F02         MOV     R7,#0x2
   \   000087   02....       LJMP    ?BANKED_LEAVE_XDATA
   2425          }
   2426          
   2427          #if defined ( NV_RESTORE )
   2428          /*********************************************************************
   2429           * @fn      ZDSecMgrWriteNV()
   2430           *
   2431           * @brief   Save off the APS link key list to NV
   2432           *
   2433           * @param   none
   2434           *
   2435           * @return  none
   2436           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2437          static void ZDSecMgrWriteNV( void )
   \                     ZDSecMgrWriteNV:
   2438          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2439            uint16 i;
   2440            nvDeviceListHdr_t hdr;
   2441          
   2442            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   7400         MOV     A,#0x0
   \   000012   F0           MOVX    @DPTR,A
   \   000013   A3           INC     DPTR
   \   000014   7400         MOV     A,#0x0
   \   000016   F0           MOVX    @DPTR,A
   2443          
   2444            if (ZDSecMgrEntries != NULL)
   \   000017   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   F8           MOV     R0,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   F9           MOV     R1,A
   \   00001F   E8           MOV     A,R0
   \   000020   49           ORL     A,R1
   \   000021   7003         JNZ     $+5
   \   000023   02....       LJMP    ??ZDSecMgrWriteNV_0 & 0xFFFF
   2445            {
   2446              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000026   7E00         MOV     R6,#0x0
   \   000028   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrWriteNV_1:
   \   00002A   C3           CLR     C
   \   00002B   EE           MOV     A,R6
   \   00002C   9403         SUBB    A,#0x3
   \   00002E   EF           MOV     A,R7
   \   00002F   9400         SUBB    A,#0x0
   \   000031   4003         JC      $+5
   \   000033   02....       LJMP    ??ZDSecMgrWriteNV_0 & 0xFFFF
   2447              {
   2448                // Save off the record
   2449                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2450                              (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2451                              sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   \   000036                ; Setup parameters for call to function osal_nv_write
   \   000036   EE           MOV     A,R6
   \   000037   F8           MOV     R0,A
   \   000038   EF           MOV     A,R7
   \   000039   F9           MOV     R1,A
   \   00003A   E8           MOV     A,R0
   \   00003B   75F005       MOV     B,#0x5
   \   00003E   A4           MUL     AB
   \   00003F   C8           XCH     A,R0
   \   000040   AAF0         MOV     R2,B
   \   000042   75F000       MOV     B,#0x0
   \   000045   A4           MUL     AB
   \   000046   2A           ADD     A,R2
   \   000047   FA           MOV     R2,A
   \   000048   75F005       MOV     B,#0x5
   \   00004B   E9           MOV     A,R1
   \   00004C   A4           MUL     AB
   \   00004D   2A           ADD     A,R2
   \   00004E   F9           MOV     R1,A
   \   00004F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000052   E0           MOVX    A,@DPTR
   \   000053   28           ADD     A,R0
   \   000054   F5..         MOV     ?V0,A
   \   000056   A3           INC     DPTR
   \   000057   E0           MOVX    A,@DPTR
   \   000058   39           ADDC    A,R1
   \   000059   F5..         MOV     ?V1,A
   \   00005B   78..         MOV     R0,#?V0
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   75..05       MOV     ?V0,#0x5
   \   000063   75..00       MOV     ?V1,#0x0
   \   000066   78..         MOV     R0,#?V0
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006B   EE           MOV     A,R6
   \   00006C   F8           MOV     R0,A
   \   00006D   EF           MOV     A,R7
   \   00006E   F9           MOV     R1,A
   \   00006F   E8           MOV     A,R0
   \   000070   75F005       MOV     B,#0x5
   \   000073   A4           MUL     AB
   \   000074   C8           XCH     A,R0
   \   000075   AAF0         MOV     R2,B
   \   000077   75F000       MOV     B,#0x0
   \   00007A   A4           MUL     AB
   \   00007B   2A           ADD     A,R2
   \   00007C   FA           MOV     R2,A
   \   00007D   75F005       MOV     B,#0x5
   \   000080   E9           MOV     A,R1
   \   000081   A4           MUL     AB
   \   000082   2A           ADD     A,R2
   \   000083   F9           MOV     R1,A
   \   000084   E8           MOV     A,R0
   \   000085   2402         ADD     A,#0x2
   \   000087   FC           MOV     R4,A
   \   000088   E4           CLR     A
   \   000089   39           ADDC    A,R1
   \   00008A   FD           MOV     R5,A
   \   00008B   7A4C         MOV     R2,#0x4c
   \   00008D   7B00         MOV     R3,#0x0
   \   00008F   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000092   7404         MOV     A,#0x4
   \   000094   12....       LCALL   ?DEALLOC_XSTACK8
   \   000097   E9           MOV     A,R1
   2452          
   2453                if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   \   000098   EE           MOV     A,R6
   \   000099   F8           MOV     R0,A
   \   00009A   EF           MOV     A,R7
   \   00009B   F9           MOV     R1,A
   \   00009C   E8           MOV     A,R0
   \   00009D   75F005       MOV     B,#0x5
   \   0000A0   A4           MUL     AB
   \   0000A1   C8           XCH     A,R0
   \   0000A2   AAF0         MOV     R2,B
   \   0000A4   75F000       MOV     B,#0x0
   \   0000A7   A4           MUL     AB
   \   0000A8   2A           ADD     A,R2
   \   0000A9   FA           MOV     R2,A
   \   0000AA   75F005       MOV     B,#0x5
   \   0000AD   E9           MOV     A,R1
   \   0000AE   A4           MUL     AB
   \   0000AF   2A           ADD     A,R2
   \   0000B0   F9           MOV     R1,A
   \   0000B1   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000B4   E0           MOVX    A,@DPTR
   \   0000B5   28           ADD     A,R0
   \   0000B6   FA           MOV     R2,A
   \   0000B7   A3           INC     DPTR
   \   0000B8   E0           MOVX    A,@DPTR
   \   0000B9   39           ADDC    A,R1
   \   0000BA   8A82         MOV     DPL,R2
   \   0000BC   F583         MOV     DPH,A
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   64FE         XRL     A,#0xfe
   \   0000C1   7004         JNZ     ??ZDSecMgrWriteNV_2
   \   0000C3   A3           INC     DPTR
   \   0000C4   E0           MOVX    A,@DPTR
   \   0000C5   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrWriteNV_2:
   \   0000C7   600F         JZ      ??ZDSecMgrWriteNV_3
   2454                {
   2455                  hdr.numRecs++;
   \   0000C9   85..82       MOV     DPL,?XSP + 0
   \   0000CC   85..83       MOV     DPH,?XSP + 1
   \   0000CF   E0           MOVX    A,@DPTR
   \   0000D0   2401         ADD     A,#0x1
   \   0000D2   F0           MOVX    @DPTR,A
   \   0000D3   A3           INC     DPTR
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   3400         ADDC    A,#0x0
   \   0000D7   F0           MOVX    @DPTR,A
   2456                }
   2457              }
   \                     ??ZDSecMgrWriteNV_3:
   \   0000D8   0E           INC     R6
   \   0000D9   EE           MOV     A,R6
   \   0000DA   7001         JNZ     ??ZDSecMgrWriteNV_4
   \   0000DC   0F           INC     R7
   \                     ??ZDSecMgrWriteNV_4:
   \   0000DD   02....       LJMP    ??ZDSecMgrWriteNV_1 & 0xFFFF
   2458            }
   2459          
   2460            // Save off the header
   2461            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \                     ??ZDSecMgrWriteNV_0:
   \   0000E0                ; Setup parameters for call to function osal_nv_write
   \   0000E0   A8..         MOV     R0,?XSP + 0
   \   0000E2   A9..         MOV     R1,?XSP + 1
   \   0000E4   88..         MOV     ?V0,R0
   \   0000E6   89..         MOV     ?V1,R1
   \   0000E8   78..         MOV     R0,#?V0
   \   0000EA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000ED   75..02       MOV     ?V0,#0x2
   \   0000F0   75..00       MOV     ?V1,#0x0
   \   0000F3   78..         MOV     R0,#?V0
   \   0000F5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F8   7C00         MOV     R4,#0x0
   \   0000FA   7D00         MOV     R5,#0x0
   \   0000FC   7A4C         MOV     R2,#0x4c
   \   0000FE   7B00         MOV     R3,#0x0
   \   000100   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000103   7404         MOV     A,#0x4
   \   000105   12....       LCALL   ?DEALLOC_XSTACK8
   \   000108   E9           MOV     A,R1
   2462          }
   \   000109   7402         MOV     A,#0x2
   \   00010B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00010E   7F02         MOV     R7,#0x2
   \   000110   02....       LJMP    ?BANKED_LEAVE_XDATA
   2463          #endif // NV_RESTORE
   2464          
   2465          #if defined ( NV_RESTORE )
   2466          /******************************************************************************
   2467           * @fn          ZDSecMgrRestoreFromNV
   2468           *
   2469           * @brief       Restore the APS Link Key entry data from NV. It does not restore
   2470           *              the key data itself as they remain in NV until they are used.
   2471           *              Only list data is restored.
   2472           *              Restore zgTrustCenterAdress from NV.
   2473           *
   2474           * @param       none
   2475           *
   2476           * @return      None.
   2477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2478          static void ZDSecMgrRestoreFromNV( void )
   \                     ZDSecMgrRestoreFromNV:
   2479          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2480            nvDeviceListHdr_t hdr;
   2481            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   \   00000A   75..00       MOV     ?V0,#0x0
   \   00000D   75..00       MOV     ?V1,#0x0
   2482          
   2483            if ((osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS) &&
   2484                ((hdr.numRecs > 0) && (hdr.numRecs <= ZDSECMGR_ENTRY_MAX)))
   \   000010                ; Setup parameters for call to function osal_nv_read
   \   000010   A8..         MOV     R0,?XSP + 0
   \   000012   A9..         MOV     R1,?XSP + 1
   \   000014   88..         MOV     ?V2,R0
   \   000016   89..         MOV     ?V3,R1
   \   000018   78..         MOV     R0,#?V2
   \   00001A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001D   75..02       MOV     ?V2,#0x2
   \   000020   75..00       MOV     ?V3,#0x0
   \   000023   78..         MOV     R0,#?V2
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7C00         MOV     R4,#0x0
   \   00002A   7D00         MOV     R5,#0x0
   \   00002C   7A4C         MOV     R2,#0x4c
   \   00002E   7B00         MOV     R3,#0x0
   \   000030   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000033   7404         MOV     A,#0x4
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   E9           MOV     A,R1
   \   000039   6003         JZ      $+5
   \   00003B   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E0           MOVX    A,@DPTR
   \   000045   F8           MOV     R0,A
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   F9           MOV     R1,A
   \   000049   E8           MOV     A,R0
   \   00004A   49           ORL     A,R1
   \   00004B   7003         JNZ     $+5
   \   00004D   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   \   000050   85..82       MOV     DPL,?XSP + 0
   \   000053   85..83       MOV     DPH,?XSP + 1
   \   000056   C3           CLR     C
   \   000057   E0           MOVX    A,@DPTR
   \   000058   9404         SUBB    A,#0x4
   \   00005A   A3           INC     DPTR
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   9400         SUBB    A,#0x0
   \   00005E   4003         JC      $+5
   \   000060   02....       LJMP    ??ZDSecMgrRestoreFromNV_0 & 0xFFFF
   2485            {
   2486              uint8 x;
   2487          
   2488              pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   000063                ; Setup parameters for call to function osal_mem_alloc
   \   000063   7A18         MOV     R2,#0x18
   \   000065   7B00         MOV     R3,#0x0
   \   000067   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   00006A   8A..         MOV     ?V2,R2
   \   00006C   8B..         MOV     ?V3,R3
   \   00006E   85....       MOV     ?V0,?V2
   \   000071   85....       MOV     ?V1,?V3
   2489          
   2490              for (x = 0; x < ZDSECMGR_ENTRY_MAX; x++)
   \   000074   7E00         MOV     R6,#0x0
   \                     ??ZDSecMgrRestoreFromNV_1:
   \   000076   EE           MOV     A,R6
   \   000077   C3           CLR     C
   \   000078   9403         SUBB    A,#0x3
   \   00007A   4003         JC      $+5
   \   00007C   02....       LJMP    ??ZDSecMgrRestoreFromNV_2 & 0xFFFF
   2491              {
   2492                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   2493                                  (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   2494                                  sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == SUCCESS )
   \   00007F                ; Setup parameters for call to function osal_nv_read
   \   00007F   EE           MOV     A,R6
   \   000080   F8           MOV     R0,A
   \   000081   7900         MOV     R1,#0x0
   \   000083   E8           MOV     A,R0
   \   000084   75F005       MOV     B,#0x5
   \   000087   A4           MUL     AB
   \   000088   C8           XCH     A,R0
   \   000089   AAF0         MOV     R2,B
   \   00008B   75F000       MOV     B,#0x0
   \   00008E   A4           MUL     AB
   \   00008F   2A           ADD     A,R2
   \   000090   FA           MOV     R2,A
   \   000091   75F005       MOV     B,#0x5
   \   000094   E9           MOV     A,R1
   \   000095   A4           MUL     AB
   \   000096   2A           ADD     A,R2
   \   000097   F9           MOV     R1,A
   \   000098   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   28           ADD     A,R0
   \   00009D   F5..         MOV     ?V2,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E0           MOVX    A,@DPTR
   \   0000A1   39           ADDC    A,R1
   \   0000A2   F5..         MOV     ?V3,A
   \   0000A4   78..         MOV     R0,#?V2
   \   0000A6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A9   75..05       MOV     ?V2,#0x5
   \   0000AC   75..00       MOV     ?V3,#0x0
   \   0000AF   78..         MOV     R0,#?V2
   \   0000B1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B4   EE           MOV     A,R6
   \   0000B5   F8           MOV     R0,A
   \   0000B6   7900         MOV     R1,#0x0
   \   0000B8   E8           MOV     A,R0
   \   0000B9   75F005       MOV     B,#0x5
   \   0000BC   A4           MUL     AB
   \   0000BD   C8           XCH     A,R0
   \   0000BE   AAF0         MOV     R2,B
   \   0000C0   75F000       MOV     B,#0x0
   \   0000C3   A4           MUL     AB
   \   0000C4   2A           ADD     A,R2
   \   0000C5   FA           MOV     R2,A
   \   0000C6   75F005       MOV     B,#0x5
   \   0000C9   E9           MOV     A,R1
   \   0000CA   A4           MUL     AB
   \   0000CB   2A           ADD     A,R2
   \   0000CC   F9           MOV     R1,A
   \   0000CD   E8           MOV     A,R0
   \   0000CE   2402         ADD     A,#0x2
   \   0000D0   FC           MOV     R4,A
   \   0000D1   E4           CLR     A
   \   0000D2   39           ADDC    A,R1
   \   0000D3   FD           MOV     R5,A
   \   0000D4   7A4C         MOV     R2,#0x4c
   \   0000D6   7B00         MOV     R3,#0x0
   \   0000D8   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000DB   7404         MOV     A,#0x4
   \   0000DD   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E0   E9           MOV     A,R1
   \   0000E1   6003         JZ      $+5
   \   0000E3   02....       LJMP    ??ZDSecMgrRestoreFromNV_3 & 0xFFFF
   2495                {
   2496                  // update data only for valid entries
   2497                  if ( ZDSecMgrEntries[x].ami != INVALID_NODE_ADDR )
   \   0000E6   EE           MOV     A,R6
   \   0000E7   F8           MOV     R0,A
   \   0000E8   7900         MOV     R1,#0x0
   \   0000EA   E8           MOV     A,R0
   \   0000EB   75F005       MOV     B,#0x5
   \   0000EE   A4           MUL     AB
   \   0000EF   C8           XCH     A,R0
   \   0000F0   AAF0         MOV     R2,B
   \   0000F2   75F000       MOV     B,#0x0
   \   0000F5   A4           MUL     AB
   \   0000F6   2A           ADD     A,R2
   \   0000F7   FA           MOV     R2,A
   \   0000F8   75F005       MOV     B,#0x5
   \   0000FB   E9           MOV     A,R1
   \   0000FC   A4           MUL     AB
   \   0000FD   2A           ADD     A,R2
   \   0000FE   F9           MOV     R1,A
   \   0000FF   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000102   E0           MOVX    A,@DPTR
   \   000103   28           ADD     A,R0
   \   000104   FA           MOV     R2,A
   \   000105   A3           INC     DPTR
   \   000106   E0           MOVX    A,@DPTR
   \   000107   39           ADDC    A,R1
   \   000108   8A82         MOV     DPL,R2
   \   00010A   F583         MOV     DPH,A
   \   00010C   E0           MOVX    A,@DPTR
   \   00010D   64FE         XRL     A,#0xfe
   \   00010F   7004         JNZ     ??ZDSecMgrRestoreFromNV_4
   \   000111   A3           INC     DPTR
   \   000112   E0           MOVX    A,@DPTR
   \   000113   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrRestoreFromNV_4:
   \   000115   7003         JNZ     $+5
   \   000117   02....       LJMP    ??ZDSecMgrRestoreFromNV_3 & 0xFFFF
   2498                  {
   2499                    if (pApsLinkKey != NULL)
   \   00011A   E5..         MOV     A,?V0
   \   00011C   45..         ORL     A,?V1
   \   00011E   7003         JNZ     $+5
   \   000120   02....       LJMP    ??ZDSecMgrRestoreFromNV_3 & 0xFFFF
   2500                    {
   2501                      // read the key form NV, keyNvId must be ZCD_NV_APS_LINK_KEY_DATA_START based
   2502                      osal_nv_read( ZDSecMgrEntries[x].keyNvId, 0,
   2503                                   sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   000123                ; Setup parameters for call to function osal_nv_read
   \   000123   78..         MOV     R0,#?V0
   \   000125   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000128   75..18       MOV     ?V2,#0x18
   \   00012B   75..00       MOV     ?V3,#0x0
   \   00012E   78..         MOV     R0,#?V2
   \   000130   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000133   7C00         MOV     R4,#0x0
   \   000135   7D00         MOV     R5,#0x0
   \   000137   EE           MOV     A,R6
   \   000138   F8           MOV     R0,A
   \   000139   7900         MOV     R1,#0x0
   \   00013B   E8           MOV     A,R0
   \   00013C   75F005       MOV     B,#0x5
   \   00013F   A4           MUL     AB
   \   000140   C8           XCH     A,R0
   \   000141   AAF0         MOV     R2,B
   \   000143   75F000       MOV     B,#0x0
   \   000146   A4           MUL     AB
   \   000147   2A           ADD     A,R2
   \   000148   FA           MOV     R2,A
   \   000149   75F005       MOV     B,#0x5
   \   00014C   E9           MOV     A,R1
   \   00014D   A4           MUL     AB
   \   00014E   2A           ADD     A,R2
   \   00014F   F9           MOV     R1,A
   \   000150   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000153   E0           MOVX    A,@DPTR
   \   000154   28           ADD     A,R0
   \   000155   FA           MOV     R2,A
   \   000156   A3           INC     DPTR
   \   000157   E0           MOVX    A,@DPTR
   \   000158   39           ADDC    A,R1
   \   000159   8A82         MOV     DPL,R2
   \   00015B   F583         MOV     DPH,A
   \   00015D   A3           INC     DPTR
   \   00015E   A3           INC     DPTR
   \   00015F   E0           MOVX    A,@DPTR
   \   000160   FA           MOV     R2,A
   \   000161   A3           INC     DPTR
   \   000162   E0           MOVX    A,@DPTR
   \   000163   FB           MOV     R3,A
   \   000164   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000167   7404         MOV     A,#0x4
   \   000169   12....       LCALL   ?DEALLOC_XSTACK8
   \   00016C   E9           MOV     A,R1
   2504          
   2505                      // set new values for the counter
   2506                      pApsLinkKey->txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   \   00016D   90....       MOV     DPTR,#__Constant_3e9
   \   000170   78..         MOV     R0,#?V4
   \   000172   12....       LCALL   ?L_MOV_X
   \   000175   E5..         MOV     A,?V0
   \   000177   2410         ADD     A,#0x10
   \   000179   F582         MOV     DPL,A
   \   00017B   E4           CLR     A
   \   00017C   35..         ADDC    A,?V1
   \   00017E   F583         MOV     DPH,A
   \   000180   78..         MOV     R0,#?V4
   \   000182   12....       LCALL   ?L_ADD_TO_X
   2507          
   2508                      // restore values for counters in RAM
   2509                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr =
   2510                                                      pApsLinkKey->txFrmCntr;
   \   000185   E5..         MOV     A,?V0
   \   000187   2410         ADD     A,#0x10
   \   000189   F582         MOV     DPL,A
   \   00018B   E4           CLR     A
   \   00018C   35..         ADDC    A,?V1
   \   00018E   F583         MOV     DPH,A
   \   000190   12....       LCALL   ?XLOAD_R0123
   \   000193   EE           MOV     A,R6
   \   000194   FC           MOV     R4,A
   \   000195   7D00         MOV     R5,#0x0
   \   000197   EC           MOV     A,R4
   \   000198   75F005       MOV     B,#0x5
   \   00019B   A4           MUL     AB
   \   00019C   CC           XCH     A,R4
   \   00019D   AFF0         MOV     R7,B
   \   00019F   75F000       MOV     B,#0x0
   \   0001A2   A4           MUL     AB
   \   0001A3   2F           ADD     A,R7
   \   0001A4   FF           MOV     R7,A
   \   0001A5   75F005       MOV     B,#0x5
   \   0001A8   ED           MOV     A,R5
   \   0001A9   A4           MUL     AB
   \   0001AA   2F           ADD     A,R7
   \   0001AB   FD           MOV     R5,A
   \   0001AC   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0001AF   E0           MOVX    A,@DPTR
   \   0001B0   2C           ADD     A,R4
   \   0001B1   FF           MOV     R7,A
   \   0001B2   A3           INC     DPTR
   \   0001B3   E0           MOVX    A,@DPTR
   \   0001B4   3D           ADDC    A,R5
   \   0001B5   8F82         MOV     DPL,R7
   \   0001B7   F583         MOV     DPH,A
   \   0001B9   A3           INC     DPTR
   \   0001BA   A3           INC     DPTR
   \   0001BB   E0           MOVX    A,@DPTR
   \   0001BC   FC           MOV     R4,A
   \   0001BD   A3           INC     DPTR
   \   0001BE   E0           MOVX    A,@DPTR
   \   0001BF   FD           MOV     R5,A
   \   0001C0   EC           MOV     A,R4
   \   0001C1   75F009       MOV     B,#0x9
   \   0001C4   A4           MUL     AB
   \   0001C5   CC           XCH     A,R4
   \   0001C6   AFF0         MOV     R7,B
   \   0001C8   75F000       MOV     B,#0x0
   \   0001CB   A4           MUL     AB
   \   0001CC   2F           ADD     A,R7
   \   0001CD   FF           MOV     R7,A
   \   0001CE   75F009       MOV     B,#0x9
   \   0001D1   ED           MOV     A,R5
   \   0001D2   A4           MUL     AB
   \   0001D3   2F           ADD     A,R7
   \   0001D4   FD           MOV     R5,A
   \   0001D5   74..         MOV     A,#(ApsLinkKeyFrmCntr + 247) & 0xff
   \   0001D7   2C           ADD     A,R4
   \   0001D8   F582         MOV     DPL,A
   \   0001DA   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4617) >> 8) & 0xff
   \   0001DC   3D           ADDC    A,R5
   \   0001DD   F583         MOV     DPH,A
   \   0001DF   12....       LCALL   ?XSTORE_R0123
   2511          
   2512                      ApsLinkKeyFrmCntr[ZDSecMgrEntries[x].keyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr =
   2513                                                      pApsLinkKey->rxFrmCntr;
   \   0001E2   E5..         MOV     A,?V0
   \   0001E4   2414         ADD     A,#0x14
   \   0001E6   F582         MOV     DPL,A
   \   0001E8   E4           CLR     A
   \   0001E9   35..         ADDC    A,?V1
   \   0001EB   F583         MOV     DPH,A
   \   0001ED   12....       LCALL   ?XLOAD_R0123
   \   0001F0   EE           MOV     A,R6
   \   0001F1   FC           MOV     R4,A
   \   0001F2   7D00         MOV     R5,#0x0
   \   0001F4   EC           MOV     A,R4
   \   0001F5   75F005       MOV     B,#0x5
   \   0001F8   A4           MUL     AB
   \   0001F9   CC           XCH     A,R4
   \   0001FA   AFF0         MOV     R7,B
   \   0001FC   75F000       MOV     B,#0x0
   \   0001FF   A4           MUL     AB
   \   000200   2F           ADD     A,R7
   \   000201   FF           MOV     R7,A
   \   000202   75F005       MOV     B,#0x5
   \   000205   ED           MOV     A,R5
   \   000206   A4           MUL     AB
   \   000207   2F           ADD     A,R7
   \   000208   FD           MOV     R5,A
   \   000209   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00020C   E0           MOVX    A,@DPTR
   \   00020D   2C           ADD     A,R4
   \   00020E   FF           MOV     R7,A
   \   00020F   A3           INC     DPTR
   \   000210   E0           MOVX    A,@DPTR
   \   000211   3D           ADDC    A,R5
   \   000212   8F82         MOV     DPL,R7
   \   000214   F583         MOV     DPH,A
   \   000216   A3           INC     DPTR
   \   000217   A3           INC     DPTR
   \   000218   E0           MOVX    A,@DPTR
   \   000219   FC           MOV     R4,A
   \   00021A   A3           INC     DPTR
   \   00021B   E0           MOVX    A,@DPTR
   \   00021C   FD           MOV     R5,A
   \   00021D   EC           MOV     A,R4
   \   00021E   75F009       MOV     B,#0x9
   \   000221   A4           MUL     AB
   \   000222   CC           XCH     A,R4
   \   000223   AFF0         MOV     R7,B
   \   000225   75F000       MOV     B,#0x0
   \   000228   A4           MUL     AB
   \   000229   2F           ADD     A,R7
   \   00022A   FF           MOV     R7,A
   \   00022B   75F009       MOV     B,#0x9
   \   00022E   ED           MOV     A,R5
   \   00022F   A4           MUL     AB
   \   000230   2F           ADD     A,R7
   \   000231   FD           MOV     R5,A
   \   000232   74..         MOV     A,#(ApsLinkKeyFrmCntr + 251) & 0xff
   \   000234   2C           ADD     A,R4
   \   000235   F582         MOV     DPL,A
   \   000237   74..         MOV     A,#((ApsLinkKeyFrmCntr - 4613) >> 8) & 0xff
   \   000239   3D           ADDC    A,R5
   \   00023A   F583         MOV     DPH,A
   \   00023C   12....       LCALL   ?XSTORE_R0123
   2514          
   2515                      osal_nv_write( ZDSecMgrEntries[x].keyNvId, 0,
   2516                                    sizeof(APSME_LinkKeyData_t), pApsLinkKey );
   \   00023F                ; Setup parameters for call to function osal_nv_write
   \   00023F   78..         MOV     R0,#?V0
   \   000241   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000244   75..18       MOV     ?V2,#0x18
   \   000247   75..00       MOV     ?V3,#0x0
   \   00024A   78..         MOV     R0,#?V2
   \   00024C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00024F   7C00         MOV     R4,#0x0
   \   000251   7D00         MOV     R5,#0x0
   \   000253   EE           MOV     A,R6
   \   000254   F8           MOV     R0,A
   \   000255   7900         MOV     R1,#0x0
   \   000257   E8           MOV     A,R0
   \   000258   75F005       MOV     B,#0x5
   \   00025B   A4           MUL     AB
   \   00025C   C8           XCH     A,R0
   \   00025D   AAF0         MOV     R2,B
   \   00025F   75F000       MOV     B,#0x0
   \   000262   A4           MUL     AB
   \   000263   2A           ADD     A,R2
   \   000264   FA           MOV     R2,A
   \   000265   75F005       MOV     B,#0x5
   \   000268   E9           MOV     A,R1
   \   000269   A4           MUL     AB
   \   00026A   2A           ADD     A,R2
   \   00026B   F9           MOV     R1,A
   \   00026C   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00026F   E0           MOVX    A,@DPTR
   \   000270   28           ADD     A,R0
   \   000271   FA           MOV     R2,A
   \   000272   A3           INC     DPTR
   \   000273   E0           MOVX    A,@DPTR
   \   000274   39           ADDC    A,R1
   \   000275   8A82         MOV     DPL,R2
   \   000277   F583         MOV     DPH,A
   \   000279   A3           INC     DPTR
   \   00027A   A3           INC     DPTR
   \   00027B   E0           MOVX    A,@DPTR
   \   00027C   FA           MOV     R2,A
   \   00027D   A3           INC     DPTR
   \   00027E   E0           MOVX    A,@DPTR
   \   00027F   FB           MOV     R3,A
   \   000280   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000283   7404         MOV     A,#0x4
   \   000285   12....       LCALL   ?DEALLOC_XSTACK8
   \   000288   E9           MOV     A,R1
   2517          
   2518                      // clear copy of key in RAM
   2519                      osal_memset(pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t));
   \   000289                ; Setup parameters for call to function osal_memset
   \   000289   7C18         MOV     R4,#0x18
   \   00028B   7D00         MOV     R5,#0x0
   \   00028D   7900         MOV     R1,#0x0
   \   00028F   AA..         MOV     R2,?V0
   \   000291   AB..         MOV     R3,?V1
   \   000293   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2520                    }
   2521                  }
   2522                }
   2523              }
   \                     ??ZDSecMgrRestoreFromNV_3:
   \   000296   0E           INC     R6
   \   000297   02....       LJMP    ??ZDSecMgrRestoreFromNV_1 & 0xFFFF
   2524          
   2525              if (pApsLinkKey != NULL)
   \                     ??ZDSecMgrRestoreFromNV_2:
   \   00029A   E5..         MOV     A,?V0
   \   00029C   45..         ORL     A,?V1
   \   00029E   6007         JZ      ??ZDSecMgrRestoreFromNV_0
   2526              {
   2527                osal_mem_free(pApsLinkKey);
   \   0002A0                ; Setup parameters for call to function osal_mem_free
   \   0002A0   AA..         MOV     R2,?V0
   \   0002A2   AB..         MOV     R3,?V1
   \   0002A4   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2528              }
   2529            }
   2530          
   2531            osal_nv_read( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   \                     ??ZDSecMgrRestoreFromNV_0:
   \   0002A7                ; Setup parameters for call to function osal_nv_read
   \   0002A7   75....       MOV     ?V2,#zgApsTrustCenterAddr & 0xff
   \   0002AA   75....       MOV     ?V3,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   0002AD   78..         MOV     R0,#?V2
   \   0002AF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002B2   75..08       MOV     ?V2,#0x8
   \   0002B5   75..00       MOV     ?V3,#0x0
   \   0002B8   78..         MOV     R0,#?V2
   \   0002BA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0002BD   7C00         MOV     R4,#0x0
   \   0002BF   7D00         MOV     R5,#0x0
   \   0002C1   7A71         MOV     R2,#0x71
   \   0002C3   7B00         MOV     R3,#0x0
   \   0002C5   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0002C8   7404         MOV     A,#0x4
   \   0002CA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002CD   E9           MOV     A,R1
   2532          }
   \   0002CE   7402         MOV     A,#0x2
   \   0002D0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0002D3   7F08         MOV     R7,#0x8
   \   0002D5   02....       LJMP    ?BANKED_LEAVE_XDATA
   2533          #endif // NV_RESTORE
   2534          
   2535          /*********************************************************************
   2536           * @fn          ZDSecMgrSetDefaultNV
   2537           *
   2538           * @brief       Write the defaults to NV for Entry table and for APS key data table
   2539           *
   2540           * @param       none
   2541           *
   2542           * @return      none
   2543           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2544          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   2545          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2546            uint16 i;
   2547            nvDeviceListHdr_t hdr;
   2548            ZDSecMgrEntry_t secMgrEntry;
   2549            APSME_LinkKeyData_t *pApsLinkKey = NULL;
   \   00000A   75..00       MOV     ?V0,#0x0
   \   00000D   75..00       MOV     ?V1,#0x0
   2550          
   2551            // Initialize the header
   2552            hdr.numRecs = 0;
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   7400         MOV     A,#0x0
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   7400         MOV     A,#0x0
   \   00001C   F0           MOVX    @DPTR,A
   2553          
   2554            // clear the header
   2555            osal_nv_write(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr);
   \   00001D                ; Setup parameters for call to function osal_nv_write
   \   00001D   A8..         MOV     R0,?XSP + 0
   \   00001F   A9..         MOV     R1,?XSP + 1
   \   000021   88..         MOV     ?V2,R0
   \   000023   89..         MOV     ?V3,R1
   \   000025   78..         MOV     R0,#?V2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   75..02       MOV     ?V2,#0x2
   \   00002D   75..00       MOV     ?V3,#0x0
   \   000030   78..         MOV     R0,#?V2
   \   000032   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000035   7C00         MOV     R4,#0x0
   \   000037   7D00         MOV     R5,#0x0
   \   000039   7A4C         MOV     R2,#0x4c
   \   00003B   7B00         MOV     R3,#0x0
   \   00003D   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000040   7404         MOV     A,#0x4
   \   000042   12....       LCALL   ?DEALLOC_XSTACK8
   \   000045   E9           MOV     A,R1
   2556          
   2557            osal_memset( &secMgrEntry, 0x00, sizeof(ZDSecMgrEntry_t) );
   \   000046                ; Setup parameters for call to function osal_memset
   \   000046   7C05         MOV     R4,#0x5
   \   000048   7D00         MOV     R5,#0x0
   \   00004A   7900         MOV     R1,#0x0
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP101_8
   \   000051   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2558          
   2559            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000054   7E00         MOV     R6,#0x0
   \   000056   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSetDefaultNV_0:
   \   000058   C3           CLR     C
   \   000059   EE           MOV     A,R6
   \   00005A   9403         SUBB    A,#0x3
   \   00005C   EF           MOV     A,R7
   \   00005D   9400         SUBB    A,#0x0
   \   00005F   504D         JNC     ??ZDSecMgrSetDefaultNV_1
   2560            {
   2561              // Clear the record
   2562              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2563                          (uint16)((sizeof(nvDeviceListHdr_t)) + (i * sizeof(ZDSecMgrEntry_t))),
   2564                                  sizeof(ZDSecMgrEntry_t), &secMgrEntry );
   \   000061                ; Setup parameters for call to function osal_nv_write
   \   000061   7402         MOV     A,#0x2
   \   000063   12....       LCALL   ?XSTACK_DISP100_8
   \   000066   88..         MOV     ?V2,R0
   \   000068   89..         MOV     ?V3,R1
   \   00006A   78..         MOV     R0,#?V2
   \   00006C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006F   75..05       MOV     ?V2,#0x5
   \   000072   75..00       MOV     ?V3,#0x0
   \   000075   78..         MOV     R0,#?V2
   \   000077   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007A   EE           MOV     A,R6
   \   00007B   F8           MOV     R0,A
   \   00007C   EF           MOV     A,R7
   \   00007D   F9           MOV     R1,A
   \   00007E   E8           MOV     A,R0
   \   00007F   75F005       MOV     B,#0x5
   \   000082   A4           MUL     AB
   \   000083   C8           XCH     A,R0
   \   000084   AAF0         MOV     R2,B
   \   000086   75F000       MOV     B,#0x0
   \   000089   A4           MUL     AB
   \   00008A   2A           ADD     A,R2
   \   00008B   FA           MOV     R2,A
   \   00008C   75F005       MOV     B,#0x5
   \   00008F   E9           MOV     A,R1
   \   000090   A4           MUL     AB
   \   000091   2A           ADD     A,R2
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   2402         ADD     A,#0x2
   \   000096   FC           MOV     R4,A
   \   000097   E4           CLR     A
   \   000098   39           ADDC    A,R1
   \   000099   FD           MOV     R5,A
   \   00009A   7A4C         MOV     R2,#0x4c
   \   00009C   7B00         MOV     R3,#0x0
   \   00009E   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000A1   7404         MOV     A,#0x4
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A6   E9           MOV     A,R1
   2565            }
   \   0000A7   0E           INC     R6
   \   0000A8   EE           MOV     A,R6
   \   0000A9   70AD         JNZ     ??ZDSecMgrSetDefaultNV_0
   \   0000AB   0F           INC     R7
   \   0000AC   80AA         SJMP    ??ZDSecMgrSetDefaultNV_0
   2566          
   2567            pApsLinkKey = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \                     ??ZDSecMgrSetDefaultNV_1:
   \   0000AE                ; Setup parameters for call to function osal_mem_alloc
   \   0000AE   7A18         MOV     R2,#0x18
   \   0000B0   7B00         MOV     R3,#0x0
   \   0000B2   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   0000B5   8A..         MOV     ?V2,R2
   \   0000B7   8B..         MOV     ?V3,R3
   \   0000B9   85....       MOV     ?V0,?V2
   \   0000BC   85....       MOV     ?V1,?V3
   2568          
   2569            if (pApsLinkKey != NULL)
   \   0000BF   E5..         MOV     A,?V0
   \   0000C1   45..         ORL     A,?V1
   \   0000C3   604D         JZ      ??ZDSecMgrSetDefaultNV_2
   2570            {
   2571              osal_memset( pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   0000C5                ; Setup parameters for call to function osal_memset
   \   0000C5   7C18         MOV     R4,#0x18
   \   0000C7   7D00         MOV     R5,#0x0
   \   0000C9   7900         MOV     R1,#0x0
   \   0000CB   AA..         MOV     R2,?V0
   \   0000CD   AB..         MOV     R3,?V1
   \   0000CF   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2572          
   2573              for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   0000D2   7E00         MOV     R6,#0x0
   \   0000D4   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSetDefaultNV_3:
   \   0000D6   C3           CLR     C
   \   0000D7   EE           MOV     A,R6
   \   0000D8   9403         SUBB    A,#0x3
   \   0000DA   EF           MOV     A,R7
   \   0000DB   9400         SUBB    A,#0x0
   \   0000DD   502C         JNC     ??ZDSecMgrSetDefaultNV_4
   2574              {
   2575                // Clear the record
   2576                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   2577                              sizeof(APSME_LinkKeyData_t), pApsLinkKey);
   \   0000DF                ; Setup parameters for call to function osal_nv_write
   \   0000DF   78..         MOV     R0,#?V0
   \   0000E1   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000E4   75..18       MOV     ?V2,#0x18
   \   0000E7   75..00       MOV     ?V3,#0x0
   \   0000EA   78..         MOV     R0,#?V2
   \   0000EC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EF   7C00         MOV     R4,#0x0
   \   0000F1   7D00         MOV     R5,#0x0
   \   0000F3   EE           MOV     A,R6
   \   0000F4   2401         ADD     A,#0x1
   \   0000F6   FA           MOV     R2,A
   \   0000F7   EF           MOV     A,R7
   \   0000F8   3402         ADDC    A,#0x2
   \   0000FA   FB           MOV     R3,A
   \   0000FB   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000FE   7404         MOV     A,#0x4
   \   000100   12....       LCALL   ?DEALLOC_XSTACK8
   \   000103   E9           MOV     A,R1
   2578              }
   \   000104   0E           INC     R6
   \   000105   EE           MOV     A,R6
   \   000106   70CE         JNZ     ??ZDSecMgrSetDefaultNV_3
   \   000108   0F           INC     R7
   \   000109   80CB         SJMP    ??ZDSecMgrSetDefaultNV_3
   2579          
   2580              osal_mem_free(pApsLinkKey);
   \                     ??ZDSecMgrSetDefaultNV_4:
   \   00010B                ; Setup parameters for call to function osal_mem_free
   \   00010B   AA..         MOV     R2,?V0
   \   00010D   AB..         MOV     R3,?V1
   \   00010F   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   2581            }
   2582          }
   \                     ??ZDSecMgrSetDefaultNV_2:
   \   000112   7407         MOV     A,#0x7
   \   000114   12....       LCALL   ?DEALLOC_XSTACK8
   \   000117   7F04         MOV     R7,#0x4
   \   000119   02....       LJMP    ?BANKED_LEAVE_XDATA
   2583          
   2584          #if defined ( NV_RESTORE )
   2585          /*********************************************************************
   2586           * @fn      ZDSecMgrUpdateNV()
   2587           *
   2588           * @brief   Updates one entry of the APS link key table to NV
   2589           *
   2590           * @param   index - to the entry in security manager table
   2591           *
   2592           * @return  none
   2593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2594          static void ZDSecMgrUpdateNV( uint16 index )
   \                     ZDSecMgrUpdateNV:
   2595          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2596            nvDeviceListHdr_t hdr;
   2597          
   2598            if (ZDSecMgrEntries != NULL)
   \   00000E   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   E8           MOV     A,R0
   \   000017   49           ORL     A,R1
   \   000018   6062         JZ      ??ZDSecMgrUpdateNV_0
   2599            {
   2600              // Save off the record
   2601              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   2602                             (uint16)((sizeof(nvDeviceListHdr_t)) + (index * sizeof(ZDSecMgrEntry_t))),
   2603                             sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[index] );
   \   00001A                ; Setup parameters for call to function osal_nv_write
   \   00001A   EE           MOV     A,R6
   \   00001B   F8           MOV     R0,A
   \   00001C   EF           MOV     A,R7
   \   00001D   F9           MOV     R1,A
   \   00001E   E8           MOV     A,R0
   \   00001F   75F005       MOV     B,#0x5
   \   000022   A4           MUL     AB
   \   000023   C8           XCH     A,R0
   \   000024   AAF0         MOV     R2,B
   \   000026   75F000       MOV     B,#0x0
   \   000029   A4           MUL     AB
   \   00002A   2A           ADD     A,R2
   \   00002B   FA           MOV     R2,A
   \   00002C   75F005       MOV     B,#0x5
   \   00002F   E9           MOV     A,R1
   \   000030   A4           MUL     AB
   \   000031   2A           ADD     A,R2
   \   000032   F9           MOV     R1,A
   \   000033   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000036   E0           MOVX    A,@DPTR
   \   000037   28           ADD     A,R0
   \   000038   F5..         MOV     ?V0,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   39           ADDC    A,R1
   \   00003D   F5..         MOV     ?V1,A
   \   00003F   78..         MOV     R0,#?V0
   \   000041   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000044   75..05       MOV     ?V0,#0x5
   \   000047   75..00       MOV     ?V1,#0x0
   \   00004A   78..         MOV     R0,#?V0
   \   00004C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004F   EE           MOV     A,R6
   \   000050   F8           MOV     R0,A
   \   000051   EF           MOV     A,R7
   \   000052   F9           MOV     R1,A
   \   000053   E8           MOV     A,R0
   \   000054   75F005       MOV     B,#0x5
   \   000057   A4           MUL     AB
   \   000058   C8           XCH     A,R0
   \   000059   AAF0         MOV     R2,B
   \   00005B   75F000       MOV     B,#0x0
   \   00005E   A4           MUL     AB
   \   00005F   2A           ADD     A,R2
   \   000060   FA           MOV     R2,A
   \   000061   75F005       MOV     B,#0x5
   \   000064   E9           MOV     A,R1
   \   000065   A4           MUL     AB
   \   000066   2A           ADD     A,R2
   \   000067   F9           MOV     R1,A
   \   000068   E8           MOV     A,R0
   \   000069   2402         ADD     A,#0x2
   \   00006B   FC           MOV     R4,A
   \   00006C   E4           CLR     A
   \   00006D   39           ADDC    A,R1
   \   00006E   FD           MOV     R5,A
   \   00006F   7A4C         MOV     R2,#0x4c
   \   000071   7B00         MOV     R3,#0x0
   \   000073   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000076   7404         MOV     A,#0x4
   \   000078   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007B   E9           MOV     A,R1
   2604            }
   2605          
   2606            if (osal_nv_read(ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr) == ZSUCCESS)
   \                     ??ZDSecMgrUpdateNV_0:
   \   00007C                ; Setup parameters for call to function osal_nv_read
   \   00007C   A8..         MOV     R0,?XSP + 0
   \   00007E   A9..         MOV     R1,?XSP + 1
   \   000080   88..         MOV     ?V0,R0
   \   000082   89..         MOV     ?V1,R1
   \   000084   78..         MOV     R0,#?V0
   \   000086   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000089   75..02       MOV     ?V0,#0x2
   \   00008C   75..00       MOV     ?V1,#0x0
   \   00008F   78..         MOV     R0,#?V0
   \   000091   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000094   7C00         MOV     R4,#0x0
   \   000096   7D00         MOV     R5,#0x0
   \   000098   7A4C         MOV     R2,#0x4c
   \   00009A   7B00         MOV     R3,#0x0
   \   00009C   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00009F   7404         MOV     A,#0x4
   \   0000A1   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A4   E9           MOV     A,R1
   \   0000A5   6003         JZ      $+5
   \   0000A7   02....       LJMP    ??ZDSecMgrUpdateNV_1 & 0xFFFF
   2607            {
   2608              if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \   0000AA   EE           MOV     A,R6
   \   0000AB   F8           MOV     R0,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   F9           MOV     R1,A
   \   0000AE   E8           MOV     A,R0
   \   0000AF   75F005       MOV     B,#0x5
   \   0000B2   A4           MUL     AB
   \   0000B3   C8           XCH     A,R0
   \   0000B4   AAF0         MOV     R2,B
   \   0000B6   75F000       MOV     B,#0x0
   \   0000B9   A4           MUL     AB
   \   0000BA   2A           ADD     A,R2
   \   0000BB   FA           MOV     R2,A
   \   0000BC   75F005       MOV     B,#0x5
   \   0000BF   E9           MOV     A,R1
   \   0000C0   A4           MUL     AB
   \   0000C1   2A           ADD     A,R2
   \   0000C2   F9           MOV     R1,A
   \   0000C3   90....       MOV     DPTR,#ZDSecMgrEntries
   \   0000C6   E0           MOVX    A,@DPTR
   \   0000C7   28           ADD     A,R0
   \   0000C8   FA           MOV     R2,A
   \   0000C9   A3           INC     DPTR
   \   0000CA   E0           MOVX    A,@DPTR
   \   0000CB   39           ADDC    A,R1
   \   0000CC   8A82         MOV     DPL,R2
   \   0000CE   F583         MOV     DPH,A
   \   0000D0   E0           MOVX    A,@DPTR
   \   0000D1   64FE         XRL     A,#0xfe
   \   0000D3   7004         JNZ     ??ZDSecMgrUpdateNV_2
   \   0000D5   A3           INC     DPTR
   \   0000D6   E0           MOVX    A,@DPTR
   \   0000D7   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrUpdateNV_2:
   \   0000D9   7020         JNZ     ??ZDSecMgrUpdateNV_3
   2609              {
   2610                if (hdr.numRecs > 0)
   \   0000DB   85..82       MOV     DPL,?XSP + 0
   \   0000DE   85..83       MOV     DPH,?XSP + 1
   \   0000E1   E0           MOVX    A,@DPTR
   \   0000E2   F8           MOV     R0,A
   \   0000E3   A3           INC     DPTR
   \   0000E4   E0           MOVX    A,@DPTR
   \   0000E5   F9           MOV     R1,A
   \   0000E6   E8           MOV     A,R0
   \   0000E7   49           ORL     A,R1
   \   0000E8   6020         JZ      ??ZDSecMgrUpdateNV_4
   2611                {
   2612                  hdr.numRecs--;
   \   0000EA   85..82       MOV     DPL,?XSP + 0
   \   0000ED   85..83       MOV     DPH,?XSP + 1
   \   0000F0   E0           MOVX    A,@DPTR
   \   0000F1   24FF         ADD     A,#-0x1
   \   0000F3   F0           MOVX    @DPTR,A
   \   0000F4   A3           INC     DPTR
   \   0000F5   E0           MOVX    A,@DPTR
   \   0000F6   34FF         ADDC    A,#-0x1
   \   0000F8   F0           MOVX    @DPTR,A
   \   0000F9   800F         SJMP    ??ZDSecMgrUpdateNV_4
   2613                }
   2614              }
   2615              else
   2616              {
   2617                hdr.numRecs++;
   \                     ??ZDSecMgrUpdateNV_3:
   \   0000FB   85..82       MOV     DPL,?XSP + 0
   \   0000FE   85..83       MOV     DPH,?XSP + 1
   \   000101   E0           MOVX    A,@DPTR
   \   000102   2401         ADD     A,#0x1
   \   000104   F0           MOVX    @DPTR,A
   \   000105   A3           INC     DPTR
   \   000106   E0           MOVX    A,@DPTR
   \   000107   3400         ADDC    A,#0x0
   \   000109   F0           MOVX    @DPTR,A
   2618              }
   2619          
   2620              // Save off the header
   2621              osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \                     ??ZDSecMgrUpdateNV_4:
   \   00010A                ; Setup parameters for call to function osal_nv_write
   \   00010A   A8..         MOV     R0,?XSP + 0
   \   00010C   A9..         MOV     R1,?XSP + 1
   \   00010E   88..         MOV     ?V0,R0
   \   000110   89..         MOV     ?V1,R1
   \   000112   78..         MOV     R0,#?V0
   \   000114   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000117   75..02       MOV     ?V0,#0x2
   \   00011A   75..00       MOV     ?V1,#0x0
   \   00011D   78..         MOV     R0,#?V0
   \   00011F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000122   7C00         MOV     R4,#0x0
   \   000124   7D00         MOV     R5,#0x0
   \   000126   7A4C         MOV     R2,#0x4c
   \   000128   7B00         MOV     R3,#0x0
   \   00012A   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00012D   7404         MOV     A,#0x4
   \   00012F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000132   E9           MOV     A,R1
   2622            }
   2623          }
   \                     ??ZDSecMgrUpdateNV_1:
   \   000133   7402         MOV     A,#0x2
   \   000135   12....       LCALL   ?DEALLOC_XSTACK8
   \   000138   7F02         MOV     R7,#0x2
   \   00013A   02....       LJMP    ?BANKED_LEAVE_XDATA
   2624          #endif // NV_RESTORE
   2625          
   2626          /******************************************************************************
   2627           * @fn          ZDSecMgrAPSRemove
   2628           *
   2629           * @brief       Remove device from network.
   2630           *
   2631           * @param       nwkAddr - device's NWK address
   2632           * @param       extAddr - device's Extended address
   2633           * @param       parentAddr - parent's NWK address
   2634           *
   2635           * @return      ZStatus_t
   2636           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2637          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   2638          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0,R2
   \   00000C   8B..         MOV     ?V1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   \   000012   7414         MOV     A,#0x14
   \   000014   12....       LCALL   ?XSTACK_DISP0_8
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V2,A
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V3,A
   2639            ZDSecMgrDevice_t device;
   2640          
   2641            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   2642                 ( extAddr == NULL )              ||
   2643                 ( parentAddr == INVALID_NODE_ADDR ) )
   \   00001E   74FE         MOV     A,#-0x2
   \   000020   65..         XRL     A,?V0
   \   000022   7004         JNZ     ??ZDSecMgrAPSRemove_0
   \   000024   74FF         MOV     A,#-0x1
   \   000026   65..         XRL     A,?V1
   \                     ??ZDSecMgrAPSRemove_0:
   \   000028   6010         JZ      ??ZDSecMgrAPSRemove_1
   \   00002A   EE           MOV     A,R6
   \   00002B   4F           ORL     A,R7
   \   00002C   600C         JZ      ??ZDSecMgrAPSRemove_1
   \   00002E   74FE         MOV     A,#-0x2
   \   000030   65..         XRL     A,?V2
   \   000032   7004         JNZ     ??ZDSecMgrAPSRemove_2
   \   000034   74FF         MOV     A,#-0x1
   \   000036   65..         XRL     A,?V3
   \                     ??ZDSecMgrAPSRemove_2:
   \   000038   7004         JNZ     ??ZDSecMgrAPSRemove_3
   2644            {
   2645              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00003A   7901         MOV     R1,#0x1
   \   00003C   802C         SJMP    ??ZDSecMgrAPSRemove_4
   2646            }
   2647          
   2648            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_3:
   \   00003E   85..82       MOV     DPL,?XSP + 0
   \   000041   85..83       MOV     DPH,?XSP + 1
   \   000044   E5..         MOV     A,?V0
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E5..         MOV     A,?V1
   \   00004A   F0           MOVX    @DPTR,A
   2649            device.extAddr = extAddr;
   \   00004B   7402         MOV     A,#0x2
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   EE           MOV     A,R6
   \   000051   F0           MOVX    @DPTR,A
   \   000052   A3           INC     DPTR
   \   000053   EF           MOV     A,R7
   \   000054   F0           MOVX    @DPTR,A
   2650            device.parentAddr = parentAddr;
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E5..         MOV     A,?V2
   \   00005C   F0           MOVX    @DPTR,A
   \   00005D   A3           INC     DPTR
   \   00005E   E5..         MOV     A,?V3
   \   000060   F0           MOVX    @DPTR,A
   2651          
   2652            // remove device
   2653            ZDSecMgrDeviceRemove( &device );
   \   000061                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000061   AA..         MOV     R2,?XSP + 0
   \   000063   AB..         MOV     R3,?XSP + 1
   \   000065   12....       LCALL   `??ZDSecMgrDeviceRemove::?relay`; Banked call to: ZDSecMgrDeviceRemove
   2654          
   2655            return ( ZSuccess );
   \   000068   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_4:
   \   00006A   7408         MOV     A,#0x8
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006F   7F04         MOV     R7,#0x4
   \   000071   02....       LJMP    ?BANKED_LEAVE_XDATA
   2656          }
   2657          
   2658          /******************************************************************************
   2659           * @fn          APSME_TCLinkKeyInit
   2660           *
   2661           * @brief       Initialize the NV table for preconfigured TC link key
   2662           *
   2663           *              When zgUseDefaultTCL is set to TRUE, the default preconfig
   2664           *              Trust Center Link Key is written to NV. A single tclk is used
   2665           *              by all devices joining the network.
   2666           *
   2667           * @param       setDefault - TRUE to set default values
   2668           *
   2669           * @return      none
   2670           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2671          void APSME_TCLinkKeyInit(uint8 setDefault)
   \                     APSME_TCLinkKeyInit:
   2672          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   89..         MOV     ?V0,R1
   2673            uint8             i;
   2674            APSME_TCLinkKey_t tcLinkKey;
   2675            uint8             rtrn;
   2676          
   2677            // Initialize all NV items for preconfigured TCLK
   2678            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00000C   7E00         MOV     R6,#0x0
   \                     ??APSME_TCLinkKeyInit_0:
   \   00000E   EE           MOV     A,R6
   \   00000F   6003         JZ      $+5
   \   000011   02....       LJMP    ??APSME_TCLinkKeyInit_1 & 0xFFFF
   2679            {
   2680              // Making sure data is cleared for every key all the time
   2681              osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \   000014                ; Setup parameters for call to function osal_memset
   \   000014   7C20         MOV     R4,#0x20
   \   000016   7D00         MOV     R5,#0x0
   \   000018   7900         MOV     R1,#0x0
   \   00001A   AA..         MOV     R2,?XSP + 0
   \   00001C   AB..         MOV     R3,?XSP + 1
   \   00001E   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2682          
   2683              // Initialize first element of the table with the default TCLK
   2684              if((i == 0) && ( zgUseDefaultTCLK == TRUE ))
   \   000021   EE           MOV     A,R6
   \   000022   7038         JNZ     ??APSME_TCLinkKeyInit_2
   \   000024   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6401         XRL     A,#0x1
   \   00002A   7030         JNZ     ??APSME_TCLinkKeyInit_2
   2685              {
   2686                osal_memset( tcLinkKey.extAddr, 0xFF, Z_EXTADDR_LEN );
   \   00002C                ; Setup parameters for call to function osal_memset
   \   00002C   7C08         MOV     R4,#0x8
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   79FF         MOV     R1,#-0x1
   \   000032   AA..         MOV     R2,?XSP + 0
   \   000034   AB..         MOV     R3,?XSP + 1
   \   000036   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2687                osal_memcpy( tcLinkKey.key, defaultTCLinkKey, SEC_KEY_LEN);
   \   000039                ; Setup parameters for call to function osal_memcpy
   \   000039   75....       MOV     ?V4,#defaultTCLinkKey & 0xff
   \   00003C   75....       MOV     ?V5,#(defaultTCLinkKey >> 8) & 0xff
   \   00003F   75..80       MOV     ?V6,#-0x80
   \   000042   78..         MOV     R0,#?V4
   \   000044   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000047   7C10         MOV     R4,#0x10
   \   000049   7D00         MOV     R5,#0x0
   \   00004B   740B         MOV     A,#0xb
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AA82         MOV     R2,DPL
   \   000052   AB83         MOV     R3,DPH
   \   000054   12....       LCALL   `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000057   7403         MOV     A,#0x3
   \   000059   12....       LCALL   ?DEALLOC_XSTACK8
   2688              }
   2689          
   2690              // If the item doesn't exist in NV memory, create and initialize
   2691              // it with the default value passed in, either defaultTCLK or 0
   2692              rtrn = osal_nv_item_init( (ZCD_NV_TCLK_TABLE_START + i),
   2693                                         sizeof(APSME_TCLinkKey_t), &tcLinkKey);
   \                     ??APSME_TCLinkKeyInit_2:
   \   00005C                ; Setup parameters for call to function osal_nv_item_init
   \   00005C   A8..         MOV     R0,?XSP + 0
   \   00005E   A9..         MOV     R1,?XSP + 1
   \   000060   88..         MOV     ?V2,R0
   \   000062   89..         MOV     ?V3,R1
   \   000064   78..         MOV     R0,#?V2
   \   000066   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000069   7C20         MOV     R4,#0x20
   \   00006B   7D00         MOV     R5,#0x0
   \   00006D   EE           MOV     A,R6
   \   00006E   F8           MOV     R0,A
   \   00006F   7900         MOV     R1,#0x0
   \   000071   E8           MOV     A,R0
   \   000072   2401         ADD     A,#0x1
   \   000074   FA           MOV     R2,A
   \   000075   E9           MOV     A,R1
   \   000076   3401         ADDC    A,#0x1
   \   000078   FB           MOV     R3,A
   \   000079   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000081   E9           MOV     A,R1
   \   000082   FF           MOV     R7,A
   2694          
   2695              if (rtrn == SUCCESS)
   \   000083   EF           MOV     A,R7
   \   000084   6003         JZ      $+5
   \   000086   02....       LJMP    ??APSME_TCLinkKeyInit_3 & 0xFFFF
   2696              {
   2697                // set the Frame counters to 0 to existing keys in NV
   2698                osal_nv_read( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   2699                               sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000089                ; Setup parameters for call to function osal_nv_read
   \   000089   A8..         MOV     R0,?XSP + 0
   \   00008B   A9..         MOV     R1,?XSP + 1
   \   00008D   88..         MOV     ?V2,R0
   \   00008F   89..         MOV     ?V3,R1
   \   000091   78..         MOV     R0,#?V2
   \   000093   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000096   75..20       MOV     ?V2,#0x20
   \   000099   75..00       MOV     ?V3,#0x0
   \   00009C   78..         MOV     R0,#?V2
   \   00009E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000A1   7C00         MOV     R4,#0x0
   \   0000A3   7D00         MOV     R5,#0x0
   \   0000A5   EE           MOV     A,R6
   \   0000A6   F8           MOV     R0,A
   \   0000A7   7900         MOV     R1,#0x0
   \   0000A9   E8           MOV     A,R0
   \   0000AA   2401         ADD     A,#0x1
   \   0000AC   FA           MOV     R2,A
   \   0000AD   E9           MOV     A,R1
   \   0000AE   3401         ADDC    A,#0x1
   \   0000B0   FB           MOV     R3,A
   \   0000B1   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000B4   7404         MOV     A,#0x4
   \   0000B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000B9   E9           MOV     A,R1
   2700          
   2701          #if defined ( NV_RESTORE )
   2702                if (setDefault == TRUE)
   \   0000BA   7401         MOV     A,#0x1
   \   0000BC   65..         XRL     A,?V0
   \   0000BE   701A         JNZ     ??APSME_TCLinkKeyInit_4
   2703                {
   2704                  // clear the value stored in NV
   2705                  tcLinkKey.txFrmCntr = 0;
   \   0000C0   7A00         MOV     R2,#0x0
   \   0000C2   7B00         MOV     R3,#0x0
   \   0000C4   7C00         MOV     R4,#0x0
   \   0000C6   7D00         MOV     R5,#0x0
   \   0000C8   7418         MOV     A,#0x18
   \   0000CA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CD   EA           MOV     A,R2
   \   0000CE   F0           MOVX    @DPTR,A
   \   0000CF   A3           INC     DPTR
   \   0000D0   EB           MOV     A,R3
   \   0000D1   F0           MOVX    @DPTR,A
   \   0000D2   A3           INC     DPTR
   \   0000D3   EC           MOV     A,R4
   \   0000D4   F0           MOVX    @DPTR,A
   \   0000D5   A3           INC     DPTR
   \   0000D6   ED           MOV     A,R5
   \   0000D7   F0           MOVX    @DPTR,A
   \   0000D8   8012         SJMP    ??APSME_TCLinkKeyInit_5
   2706                }
   2707                else
   2708                {
   2709                  // increase the value stored in NV
   2710                  tcLinkKey.txFrmCntr += ( MAX_TCLK_FRAMECOUNTER_CHANGES + 1 );
   \                     ??APSME_TCLinkKeyInit_4:
   \   0000DA   90....       MOV     DPTR,#__Constant_b
   \   0000DD   78..         MOV     R0,#?V4
   \   0000DF   12....       LCALL   ?L_MOV_X
   \   0000E2   7418         MOV     A,#0x18
   \   0000E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E7   78..         MOV     R0,#?V4
   \   0000E9   12....       LCALL   ?L_ADD_TO_X
   2711                }
   2712          #else
   2713                // Clear the counters if NV_RESTORE is not enabled and this NV item
   2714                // already existed in the NV memory
   2715                tcLinkKey.txFrmCntr = 0;
   2716                tcLinkKey.rxFrmCntr = 0;
   2717          #endif  // NV_RESTORE
   2718          
   2719                osal_nv_write( ( ZCD_NV_TCLK_TABLE_START + i), 0,
   2720                                sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \                     ??APSME_TCLinkKeyInit_5:
   \   0000EC                ; Setup parameters for call to function osal_nv_write
   \   0000EC   A8..         MOV     R0,?XSP + 0
   \   0000EE   A9..         MOV     R1,?XSP + 1
   \   0000F0   88..         MOV     ?V2,R0
   \   0000F2   89..         MOV     ?V3,R1
   \   0000F4   78..         MOV     R0,#?V2
   \   0000F6   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F9   75..20       MOV     ?V2,#0x20
   \   0000FC   75..00       MOV     ?V3,#0x0
   \   0000FF   78..         MOV     R0,#?V2
   \   000101   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000104   7C00         MOV     R4,#0x0
   \   000106   7D00         MOV     R5,#0x0
   \   000108   EE           MOV     A,R6
   \   000109   F8           MOV     R0,A
   \   00010A   7900         MOV     R1,#0x0
   \   00010C   E8           MOV     A,R0
   \   00010D   2401         ADD     A,#0x1
   \   00010F   FA           MOV     R2,A
   \   000110   E9           MOV     A,R1
   \   000111   3401         ADDC    A,#0x1
   \   000113   FB           MOV     R3,A
   \   000114   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000117   7404         MOV     A,#0x4
   \   000119   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011C   E9           MOV     A,R1
   2721          
   2722                // set initial values for counters in RAM
   2723                TCLinkKeyFrmCntr[i].txFrmCntr = tcLinkKey.txFrmCntr;
   \   00011D   7418         MOV     A,#0x18
   \   00011F   12....       LCALL   ?XSTACK_DISP0_8
   \   000122   12....       LCALL   ?XLOAD_R0123
   \   000125   EE           MOV     A,R6
   \   000126   FC           MOV     R4,A
   \   000127   7D00         MOV     R5,#0x0
   \   000129   EC           MOV     A,R4
   \   00012A   75F009       MOV     B,#0x9
   \   00012D   A4           MUL     AB
   \   00012E   CC           XCH     A,R4
   \   00012F   85F0..       MOV     ?V1,B
   \   000132   75F000       MOV     B,#0x0
   \   000135   A4           MUL     AB
   \   000136   25..         ADD     A,?V1
   \   000138   F5..         MOV     ?V1,A
   \   00013A   75F009       MOV     B,#0x9
   \   00013D   ED           MOV     A,R5
   \   00013E   A4           MUL     AB
   \   00013F   25..         ADD     A,?V1
   \   000141   FD           MOV     R5,A
   \   000142   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   000144   2C           ADD     A,R4
   \   000145   F582         MOV     DPL,A
   \   000147   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   000149   3D           ADDC    A,R5
   \   00014A   F583         MOV     DPH,A
   \   00014C   12....       LCALL   ?XSTORE_R0123
   2724                TCLinkKeyFrmCntr[i].rxFrmCntr = tcLinkKey.rxFrmCntr;
   \   00014F   741C         MOV     A,#0x1c
   \   000151   12....       LCALL   ?XSTACK_DISP0_8
   \   000154   12....       LCALL   ?XLOAD_R0123
   \   000157   EE           MOV     A,R6
   \   000158   FC           MOV     R4,A
   \   000159   7D00         MOV     R5,#0x0
   \   00015B   EC           MOV     A,R4
   \   00015C   75F009       MOV     B,#0x9
   \   00015F   A4           MUL     AB
   \   000160   CC           XCH     A,R4
   \   000161   85F0..       MOV     ?V1,B
   \   000164   75F000       MOV     B,#0x0
   \   000167   A4           MUL     AB
   \   000168   25..         ADD     A,?V1
   \   00016A   F5..         MOV     ?V1,A
   \   00016C   75F009       MOV     B,#0x9
   \   00016F   ED           MOV     A,R5
   \   000170   A4           MUL     AB
   \   000171   25..         ADD     A,?V1
   \   000173   FD           MOV     R5,A
   \   000174   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   000176   2C           ADD     A,R4
   \   000177   F582         MOV     DPL,A
   \   000179   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   00017B   3D           ADDC    A,R5
   \   00017C   F583         MOV     DPH,A
   \   00017E   12....       LCALL   ?XSTORE_R0123
   2725              }
   2726            }
   \                     ??APSME_TCLinkKeyInit_3:
   \   000181   0E           INC     R6
   \   000182   02....       LJMP    ??APSME_TCLinkKeyInit_0 & 0xFFFF
   2727          
   2728            // clear copy of key in RAM
   2729            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyInit_1:
   \   000185                ; Setup parameters for call to function osal_memset
   \   000185   7C20         MOV     R4,#0x20
   \   000187   7D00         MOV     R5,#0x0
   \   000189   7900         MOV     R1,#0x0
   \   00018B   AA..         MOV     R2,?XSP + 0
   \   00018D   AB..         MOV     R3,?XSP + 1
   \   00018F   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2730          
   2731          }
   \   000192   7420         MOV     A,#0x20
   \   000194   12....       LCALL   ?DEALLOC_XSTACK8
   \   000197   7F08         MOV     R7,#0x8
   \   000199   02....       LJMP    ?BANKED_LEAVE_XDATA
   2732          
   2733          /******************************************************************************
   2734           * @fn          APSME_TCLinkKeySync
   2735           *
   2736           * @brief       Sync Trust Center LINK key data.
   2737           *
   2738           * @param       srcAddr - [in] srcAddr
   2739           * @param       si      - [in, out] SSP_Info_t
   2740           *
   2741           * @return      ZStatus_t
   2742           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2743          ZStatus_t APSME_TCLinkKeySync( uint16 srcAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeySync:
   2744          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000   74EA         MOV     A,#-0x16
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 22
   \   000005                ; Auto size: 32
   \   000005   74E0         MOV     A,#-0x20
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V12,R2
   \   00000C   8B..         MOV     ?V13,R3
   \   00000E   8C..         MOV     ?V2,R4
   \   000010   8D..         MOV     ?V3,R5
   2745            uint8 i, selectedId = ZDSECMGR_TC_DEVICE_MAX;
   \   000012   7F01         MOV     R7,#0x1
   2746            ZStatus_t status = ZSecNoKey;
   \   000014   7EA1         MOV     R6,#-0x5f
   2747            APSME_TCLinkKey_t tcLinkKey;
   2748            uint32 *tclkRxFrmCntr;
   2749            uint16 originatorAddr = APSME_TRUSTCENTER_NWKADDR;
   \   000016   75..00       MOV     ?V8,#0x0
   \   000019   75..00       MOV     ?V9,#0x0
   2750          
   2751            // Look up the IEEE address of the trust center if it's available
   2752            if ( AddrMgrExtAddrValid( si->extAddr ) == FALSE )
   \   00001C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00001C   E5..         MOV     A,?V2
   \   00001E   2406         ADD     A,#0x6
   \   000020   FA           MOV     R2,A
   \   000021   E4           CLR     A
   \   000022   35..         ADDC    A,?V3
   \   000024   FB           MOV     R3,A
   \   000025   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000028   E9           MOV     A,R1
   \   000029   7013         JNZ     ??APSME_TCLinkKeySync_0
   2753            {
   2754              APSME_LookupExtAddr( srcAddr, si->extAddr );
   \   00002B                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002B   E5..         MOV     A,?V2
   \   00002D   2406         ADD     A,#0x6
   \   00002F   FC           MOV     R4,A
   \   000030   E4           CLR     A
   \   000031   35..         ADDC    A,?V3
   \   000033   FD           MOV     R5,A
   \   000034   AA..         MOV     R2,?V12
   \   000036   AB..         MOV     R3,?V13
   \   000038   12....       LCALL   `??APSME_LookupExtAddr::?relay`; Banked call to: APSME_LookupExtAddr
   \   00003B   E9           MOV     A,R1
   \   00003C   801D         SJMP    ??APSME_TCLinkKeySync_1
   2755            }
   2756            else if ( osal_ExtAddrEqual( si->extAddr, _NIB.nwkCoordExtAddress ) )
   \                     ??APSME_TCLinkKeySync_0:
   \   00003E                ; Setup parameters for call to function sAddrExtCmp
   \   00003E   7C..         MOV     R4,#(_NIB + 25) & 0xff
   \   000040   7D..         MOV     R5,#((_NIB + 25) >> 8) & 0xff
   \   000042   E5..         MOV     A,?V2
   \   000044   2406         ADD     A,#0x6
   \   000046   FA           MOV     R2,A
   \   000047   E4           CLR     A
   \   000048   35..         ADDC    A,?V3
   \   00004A   FB           MOV     R3,A
   \   00004B   12....       LCALL   `??sAddrExtCmp::?relay`; Banked call to: sAddrExtCmp
   \   00004E   E9           MOV     A,R1
   \   00004F   600A         JZ      ??APSME_TCLinkKeySync_1
   2757            {
   2758              originatorAddr = _NIB.nwkCoordAddress;
   \   000051   90....       MOV     DPTR,#_NIB + 23
   \   000054   E0           MOVX    A,@DPTR
   \   000055   F5..         MOV     ?V8,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5..         MOV     ?V9,A
   2759              // in case originated not from our parent, use the default TC address
   2760            }
   2761          
   2762            // Look up the TC link key associated with the device
   2763            // or the default TC link key (extAddr is all FFs), whichever is found
   2764            for ( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \                     ??APSME_TCLinkKeySync_1:
   \   00005B   75..00       MOV     ?V0,#0x0
   \                     ??APSME_TCLinkKeySync_2:
   \   00005E   E5..         MOV     A,?V0
   \   000060   6003         JZ      $+5
   \   000062   02....       LJMP    ??APSME_TCLinkKeySync_3 & 0xFFFF
   2765            {
   2766              // Read entry i of the TC link key table from NV
   2767              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   2768                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000065                ; Setup parameters for call to function osal_nv_read
   \   000065   A8..         MOV     R0,?XSP + 0
   \   000067   A9..         MOV     R1,?XSP + 1
   \   000069   88..         MOV     ?V4,R0
   \   00006B   89..         MOV     ?V5,R1
   \   00006D   78..         MOV     R0,#?V4
   \   00006F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000072   75..20       MOV     ?V4,#0x20
   \   000075   75..00       MOV     ?V5,#0x0
   \   000078   78..         MOV     R0,#?V4
   \   00007A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00007D   7C00         MOV     R4,#0x0
   \   00007F   7D00         MOV     R5,#0x0
   \   000081   A8..         MOV     R0,?V0
   \   000083   7900         MOV     R1,#0x0
   \   000085   E8           MOV     A,R0
   \   000086   2401         ADD     A,#0x1
   \   000088   FA           MOV     R2,A
   \   000089   E9           MOV     A,R1
   \   00008A   3401         ADDC    A,#0x1
   \   00008C   FB           MOV     R3,A
   \   00008D   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000090   7404         MOV     A,#0x4
   \   000092   12....       LCALL   ?DEALLOC_XSTACK8
   \   000095   E9           MOV     A,R1
   2769          
   2770              // prefer exact match over default
   2771              if ( AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   000096                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000096   AC..         MOV     R4,?XSP + 0
   \   000098   AD..         MOV     R5,?XSP + 1
   \   00009A   E5..         MOV     A,?V2
   \   00009C   2406         ADD     A,#0x6
   \   00009E   FA           MOV     R2,A
   \   00009F   E4           CLR     A
   \   0000A0   35..         ADDC    A,?V3
   \   0000A2   FB           MOV     R3,A
   \   0000A3   12....       LCALL   `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   0000A6   E9           MOV     A,R1
   \   0000A7   6004         JZ      ??APSME_TCLinkKeySync_4
   2772              {
   2773                selectedId = i;
   \   0000A9   AF..         MOV     R7,?V0
   2774                // break from the loop
   2775                break;
   \   0000AB   8038         SJMP    ??APSME_TCLinkKeySync_3
   2776              }
   2777              else if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeySync_4:
   \   0000AD                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   0000AD   AA..         MOV     R2,?XSP + 0
   \   0000AF   AB..         MOV     R3,?XSP + 1
   \   0000B1   12....       LCALL   `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   0000B4   E9           MOV     A,R1
   \   0000B5   6029         JZ      ??APSME_TCLinkKeySync_5
   2778              {
   2779                if ( ( originatorAddr != APSME_TRUSTCENTER_NWKADDR ) && ( si->keyID == SEC_KEYID_TRANSPORT )
   2780                     && (i == 0) && ( zgUseDefaultTCLK == TRUE ) )
   \   0000B7   E5..         MOV     A,?V8
   \   0000B9   45..         ORL     A,?V9
   \   0000BB   601C         JZ      ??APSME_TCLinkKeySync_6
   \   0000BD   E5..         MOV     A,?V2
   \   0000BF   240E         ADD     A,#0xe
   \   0000C1   F582         MOV     DPL,A
   \   0000C3   E4           CLR     A
   \   0000C4   35..         ADDC    A,?V3
   \   0000C6   F583         MOV     DPH,A
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   6402         XRL     A,#0x2
   \   0000CB   700C         JNZ     ??APSME_TCLinkKeySync_6
   \   0000CD   E5..         MOV     A,?V0
   \   0000CF   7008         JNZ     ??APSME_TCLinkKeySync_6
   \   0000D1   90....       MOV     DPTR,#zgUseDefaultTCLK
   \   0000D4   E0           MOVX    A,@DPTR
   \   0000D5   6401         XRL     A,#0x1
   \   0000D7   6007         JZ      ??APSME_TCLinkKeySync_5
   2781                {
   2782                  //if a Key is received directly from an unusual TC,
   2783                  // don't use the first element of the table initialized with the default TCLK
   2784                  continue;
   2785                }
   2786                if ( selectedId == ZDSECMGR_TC_DEVICE_MAX )
   \                     ??APSME_TCLinkKeySync_6:
   \   0000D9   7401         MOV     A,#0x1
   \   0000DB   6F           XRL     A,R7
   \   0000DC   7002         JNZ     ??APSME_TCLinkKeySync_5
   2787                {
   2788                  selectedId = i;
   \   0000DE   AF..         MOV     R7,?V0
   2789                }
   2790              }
   2791            }
   \                     ??APSME_TCLinkKeySync_5:
   \   0000E0   05..         INC     ?V0
   \   0000E2   02....       LJMP    ??APSME_TCLinkKeySync_2 & 0xFFFF
   2792          
   2793            if ( selectedId < ZDSECMGR_TC_DEVICE_MAX )
   \                     ??APSME_TCLinkKeySync_3:
   \   0000E5   EF           MOV     A,R7
   \   0000E6   6003         JZ      $+5
   \   0000E8   02....       LJMP    ??APSME_TCLinkKeySync_7 & 0xFFFF
   2794            {
   2795               // Only for UNIQUE keys, verify that the incoming frame counter is valid
   2796              if ( zgApsLinkKeyType == ZG_UNIQUE_LINK_KEY )
   \   0000EB   90....       MOV     DPTR,#zgApsLinkKeyType
   \   0000EE   E0           MOVX    A,@DPTR
   \   0000EF   6003         JZ      $+5
   \   0000F1   02....       LJMP    ??APSME_TCLinkKeySync_8 & 0xFFFF
   2797              {
   2798                tclkRxFrmCntr = &TCLinkKeyFrmCntr[selectedId].rxFrmCntr;
   \   0000F4   EF           MOV     A,R7
   \   0000F5   F8           MOV     R0,A
   \   0000F6   7900         MOV     R1,#0x0
   \   0000F8   E8           MOV     A,R0
   \   0000F9   75F009       MOV     B,#0x9
   \   0000FC   A4           MUL     AB
   \   0000FD   C8           XCH     A,R0
   \   0000FE   AAF0         MOV     R2,B
   \   000100   75F000       MOV     B,#0x0
   \   000103   A4           MUL     AB
   \   000104   2A           ADD     A,R2
   \   000105   FA           MOV     R2,A
   \   000106   75F009       MOV     B,#0x9
   \   000109   E9           MOV     A,R1
   \   00010A   A4           MUL     AB
   \   00010B   2A           ADD     A,R2
   \   00010C   F9           MOV     R1,A
   \   00010D   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   00010F   28           ADD     A,R0
   \   000110   F8           MOV     R0,A
   \   000111   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   000113   39           ADDC    A,R1
   \   000114   F9           MOV     R1,A
   \   000115   88..         MOV     ?V10,R0
   \   000117   89..         MOV     ?V11,R1
   2799          
   2800                if ( si->frmCntr >= *tclkRxFrmCntr )
   \   000119   85..82       MOV     DPL,?V10
   \   00011C   85..83       MOV     DPH,?V11
   \   00011F   78..         MOV     R0,#?V4
   \   000121   12....       LCALL   ?L_MOV_X
   \   000124   E5..         MOV     A,?V2
   \   000126   2412         ADD     A,#0x12
   \   000128   F582         MOV     DPL,A
   \   00012A   E4           CLR     A
   \   00012B   35..         ADDC    A,?V3
   \   00012D   F583         MOV     DPH,A
   \   00012F   78..         MOV     R0,#?V4
   \   000131   12....       LCALL   ?UL_GT_X
   \   000134   4051         JC      ??APSME_TCLinkKeySync_9
   2801                {
   2802                  // set the keyNvId to use
   2803                  si->keyNvId = (ZCD_NV_TCLK_TABLE_START + selectedId);
   \   000136   EF           MOV     A,R7
   \   000137   F8           MOV     R0,A
   \   000138   7900         MOV     R1,#0x0
   \   00013A   E8           MOV     A,R0
   \   00013B   2401         ADD     A,#0x1
   \   00013D   F8           MOV     R0,A
   \   00013E   E9           MOV     A,R1
   \   00013F   3401         ADDC    A,#0x1
   \   000141   F9           MOV     R1,A
   \   000142   E5..         MOV     A,?V2
   \   000144   240F         ADD     A,#0xf
   \   000146   F582         MOV     DPL,A
   \   000148   E4           CLR     A
   \   000149   35..         ADDC    A,?V3
   \   00014B   F583         MOV     DPH,A
   \   00014D   E8           MOV     A,R0
   \   00014E   F0           MOVX    @DPTR,A
   \   00014F   A3           INC     DPTR
   \   000150   E9           MOV     A,R1
   \   000151   F0           MOVX    @DPTR,A
   2804          
   2805                  // update the rx frame counter
   2806                  *tclkRxFrmCntr = si->frmCntr + 1;
   \   000152   E5..         MOV     A,?V2
   \   000154   2412         ADD     A,#0x12
   \   000156   F582         MOV     DPL,A
   \   000158   E4           CLR     A
   \   000159   35..         ADDC    A,?V3
   \   00015B   F583         MOV     DPH,A
   \   00015D   78..         MOV     R0,#?V4
   \   00015F   12....       LCALL   ?L_MOV_X
   \   000162   90....       MOV     DPTR,#__Constant_1
   \   000165   78..         MOV     R0,#?V4
   \   000167   12....       LCALL   ?L_ADD_X
   \   00016A   AA..         MOV     R2,?V4
   \   00016C   AB..         MOV     R3,?V5
   \   00016E   AC..         MOV     R4,?V6
   \   000170   AD..         MOV     R5,?V7
   \   000172   85..82       MOV     DPL,?V10
   \   000175   85..83       MOV     DPH,?V11
   \   000178   EA           MOV     A,R2
   \   000179   F0           MOVX    @DPTR,A
   \   00017A   A3           INC     DPTR
   \   00017B   EB           MOV     A,R3
   \   00017C   F0           MOVX    @DPTR,A
   \   00017D   A3           INC     DPTR
   \   00017E   EC           MOV     A,R4
   \   00017F   F0           MOVX    @DPTR,A
   \   000180   A3           INC     DPTR
   \   000181   ED           MOV     A,R5
   \   000182   F0           MOVX    @DPTR,A
   2807          
   2808                  status = ZSuccess;
   \   000183   7E00         MOV     R6,#0x0
   \   000185   8022         SJMP    ??APSME_TCLinkKeySync_7
   2809                }
   2810                else
   2811                {
   2812                  status = ZSecOldFrmCount;
   \                     ??APSME_TCLinkKeySync_9:
   \   000187   7EA2         MOV     R6,#-0x5e
   \   000189   801E         SJMP    ??APSME_TCLinkKeySync_7
   2813                }
   2814              }
   2815              else
   2816              {
   2817                // set the keyNvId to use
   2818                si->keyNvId = (ZCD_NV_TCLK_TABLE_START + selectedId);
   \                     ??APSME_TCLinkKeySync_8:
   \   00018B   EF           MOV     A,R7
   \   00018C   F8           MOV     R0,A
   \   00018D   7900         MOV     R1,#0x0
   \   00018F   E8           MOV     A,R0
   \   000190   2401         ADD     A,#0x1
   \   000192   F8           MOV     R0,A
   \   000193   E9           MOV     A,R1
   \   000194   3401         ADDC    A,#0x1
   \   000196   F9           MOV     R1,A
   \   000197   E5..         MOV     A,?V2
   \   000199   240F         ADD     A,#0xf
   \   00019B   F582         MOV     DPL,A
   \   00019D   E4           CLR     A
   \   00019E   35..         ADDC    A,?V3
   \   0001A0   F583         MOV     DPH,A
   \   0001A2   E8           MOV     A,R0
   \   0001A3   F0           MOVX    @DPTR,A
   \   0001A4   A3           INC     DPTR
   \   0001A5   E9           MOV     A,R1
   \   0001A6   F0           MOVX    @DPTR,A
   2819          
   2820                status = ZSuccess;
   \   0001A7   7E00         MOV     R6,#0x0
   2821              }
   2822            }
   2823          
   2824            // clear copy of key in RAM
   2825            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeySync_7:
   \   0001A9                ; Setup parameters for call to function osal_memset
   \   0001A9   7C20         MOV     R4,#0x20
   \   0001AB   7D00         MOV     R5,#0x0
   \   0001AD   7900         MOV     R1,#0x0
   \   0001AF   AA..         MOV     R2,?XSP + 0
   \   0001B1   AB..         MOV     R3,?XSP + 1
   \   0001B3   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2826          
   2827            return status;
   \   0001B6   EE           MOV     A,R6
   \   0001B7   F9           MOV     R1,A
   \   0001B8   7420         MOV     A,#0x20
   \   0001BA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001BD   7F0E         MOV     R7,#0xe
   \   0001BF   02....       LJMP    ?BANKED_LEAVE_XDATA
   2828          }
   2829          
   2830          /******************************************************************************
   2831           * @fn          APSME_TCLinkKeyLoad
   2832           *
   2833           * @brief       Load Trust Center LINK key data.
   2834           *
   2835           * @param       dstAddr - [in] dstAddr
   2836           * @param       si      - [in, out] SSP_Info_t
   2837           *
   2838           * @return      ZStatus_t
   2839           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2840          ZStatus_t APSME_TCLinkKeyLoad( uint16 dstAddr, SSP_Info_t* si )
   \                     APSME_TCLinkKeyLoad:
   2841          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000                REQUIRE ?V8
   \   000000                REQUIRE ?V9
   \   000000                REQUIRE ?V10
   \   000000                REQUIRE ?V11
   \   000000                REQUIRE ?V12
   \   000000                REQUIRE ?V13
   \   000000                REQUIRE ?V14
   \   000000                REQUIRE ?V15
   \   000000   74E8         MOV     A,#-0x18
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 24
   \   000005                ; Auto size: 45
   \   000005   74D3         MOV     A,#-0x2d
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V14,R2
   \   00000C   8B..         MOV     ?V15,R3
   \   00000E   8C..         MOV     ?V10,R4
   \   000010   8D..         MOV     ?V11,R5
   2842            uint8 i;
   2843            ZStatus_t status = ZSecNoKey;
   \   000012   7EA1         MOV     R6,#-0x5f
   2844            APSME_TCLinkKey_t tcLinkKey;
   2845            AddrMgrEntry_t addrEntry;
   2846            uint32 *tclkTxFrmCntr;
   2847            uint8 extAddrFound;
   2848            uint8 defaultTCLKIdx = ZDSECMGR_TC_DEVICE_MAX;
   \   000014   75..01       MOV     ?V8,#0x1
   2849          
   2850            // Look up the ami of the srcAddr if available
   2851            addrEntry.user    = ADDRMGR_USER_DEFAULT;
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   7400         MOV     A,#0x0
   \   00001F   F0           MOVX    @DPTR,A
   2852            addrEntry.nwkAddr = dstAddr;
   \   000020   7401         MOV     A,#0x1
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   E5..         MOV     A,?V14
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   E5..         MOV     A,?V15
   \   00002B   F0           MOVX    @DPTR,A
   2853          
   2854            extAddrFound = AddrMgrExtAddrValid( si->extAddr );
   \   00002C                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00002C   E5..         MOV     A,?V10
   \   00002E   2406         ADD     A,#0x6
   \   000030   FA           MOV     R2,A
   \   000031   E4           CLR     A
   \   000032   35..         ADDC    A,?V11
   \   000034   FB           MOV     R3,A
   \   000035   12....       LCALL   `??AddrMgrExtAddrValid::?relay`; Banked call to: AddrMgrExtAddrValid
   \   000038   E9           MOV     A,R1
   \   000039   F5..         MOV     ?V9,A
   2855          
   2856            // Look up the TC link key associated with the device
   2857            // or the master TC link key (ami = 0xFFFF), whichever is found
   2858            for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   00003B   7F00         MOV     R7,#0x0
   \                     ??APSME_TCLinkKeyLoad_0:
   \   00003D   EF           MOV     A,R7
   \   00003E   706C         JNZ     ??APSME_TCLinkKeyLoad_1
   2859            {
   2860              // Read entry i of the TC link key table from NV
   2861              osal_nv_read( (ZCD_NV_TCLK_TABLE_START + i), 0,
   2862                           sizeof(APSME_TCLinkKey_t), &tcLinkKey );
   \   000040                ; Setup parameters for call to function osal_nv_read
   \   000040   740D         MOV     A,#0xd
   \   000042   12....       LCALL   ?XSTACK_DISP100_8
   \   000045   88..         MOV     ?V0,R0
   \   000047   89..         MOV     ?V1,R1
   \   000049   78..         MOV     R0,#?V0
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   75..20       MOV     ?V0,#0x20
   \   000051   75..00       MOV     ?V1,#0x0
   \   000054   78..         MOV     R0,#?V0
   \   000056   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000059   7C00         MOV     R4,#0x0
   \   00005B   7D00         MOV     R5,#0x0
   \   00005D   EF           MOV     A,R7
   \   00005E   F8           MOV     R0,A
   \   00005F   7900         MOV     R1,#0x0
   \   000061   E8           MOV     A,R0
   \   000062   2401         ADD     A,#0x1
   \   000064   FA           MOV     R2,A
   \   000065   E9           MOV     A,R1
   \   000066   3401         ADDC    A,#0x1
   \   000068   FB           MOV     R3,A
   \   000069   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00006C   7404         MOV     A,#0x4
   \   00006E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000071   E9           MOV     A,R1
   2863          
   2864              if( extAddrFound && AddrMgrExtAddrEqual(si->extAddr, tcLinkKey.extAddr) )
   \   000072   E5..         MOV     A,?V9
   \   000074   6018         JZ      ??APSME_TCLinkKeyLoad_2
   \   000076                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000076   740D         MOV     A,#0xd
   \   000078   12....       LCALL   ?XSTACK_DISP102_8
   \   00007B   E5..         MOV     A,?V10
   \   00007D   2406         ADD     A,#0x6
   \   00007F   FA           MOV     R2,A
   \   000080   E4           CLR     A
   \   000081   35..         ADDC    A,?V11
   \   000083   FB           MOV     R3,A
   \   000084   12....       LCALL   `??AddrMgrExtAddrEqual::?relay`; Banked call to: AddrMgrExtAddrEqual
   \   000087   E9           MOV     A,R1
   \   000088   6004         JZ      ??APSME_TCLinkKeyLoad_2
   2865              {
   2866                status = ZSuccess;
   \   00008A   7E00         MOV     R6,#0x0
   2867          
   2868                break; // break from the loop
   \   00008C   801E         SJMP    ??APSME_TCLinkKeyLoad_1
   2869              }
   2870          
   2871              if ( APSME_IsDefaultTCLK(tcLinkKey.extAddr) )
   \                     ??APSME_TCLinkKeyLoad_2:
   \   00008E                ; Setup parameters for call to function APSME_IsDefaultTCLK
   \   00008E   740D         MOV     A,#0xd
   \   000090   12....       LCALL   ?XSTACK_DISP101_8
   \   000093   12....       LCALL   `??APSME_IsDefaultTCLK::?relay`; Banked call to: APSME_IsDefaultTCLK
   \   000096   E9           MOV     A,R1
   \   000097   6010         JZ      ??APSME_TCLinkKeyLoad_3
   2872              {
   2873                if ( !extAddrFound && ( !APSME_IsDistributedSecurity() ) )
   \   000099   E5..         MOV     A,?V9
   \   00009B   700A         JNZ     ??APSME_TCLinkKeyLoad_4
   \   00009D                ; Setup parameters for call to function APSME_IsDistributedSecurity
   \   00009D   12....       LCALL   `??APSME_IsDistributedSecurity::?relay`; Banked call to: APSME_IsDistributedSecurity
   \   0000A0   E9           MOV     A,R1
   \   0000A1   7004         JNZ     ??APSME_TCLinkKeyLoad_4
   2874                {
   2875                  status = ZSuccess;
   \   0000A3   7E00         MOV     R6,#0x0
   2876          
   2877                  break; // break from the loop
   \   0000A5   8005         SJMP    ??APSME_TCLinkKeyLoad_1
   2878                }
   2879          
   2880                // Remember the last default TCLK index
   2881                defaultTCLKIdx = i;
   \                     ??APSME_TCLinkKeyLoad_4:
   \   0000A7   8F..         MOV     ?V8,R7
   2882              }
   2883            }
   \                     ??APSME_TCLinkKeyLoad_3:
   \   0000A9   0F           INC     R7
   \   0000AA   8091         SJMP    ??APSME_TCLinkKeyLoad_0
   2884          
   2885            if ( (status != ZSuccess) && (defaultTCLKIdx < ZDSECMGR_TC_DEVICE_MAX) )
   \                     ??APSME_TCLinkKeyLoad_1:
   \   0000AC   EE           MOV     A,R6
   \   0000AD   6008         JZ      ??APSME_TCLinkKeyLoad_5
   \   0000AF   E5..         MOV     A,?V8
   \   0000B1   7004         JNZ     ??APSME_TCLinkKeyLoad_5
   2886            {
   2887              // Exact match was not found; use the last default TC Link Key
   2888              i = defaultTCLKIdx;
   \   0000B3   AF..         MOV     R7,?V8
   2889              status = ZSuccess;
   \   0000B5   7E00         MOV     R6,#0x0
   2890            }
   2891          
   2892            if ( status == ZSuccess )
   \                     ??APSME_TCLinkKeyLoad_5:
   \   0000B7   EE           MOV     A,R6
   \   0000B8   6003         JZ      $+5
   \   0000BA   02....       LJMP    ??APSME_TCLinkKeyLoad_6 & 0xFFFF
   2893            {
   2894              tclkTxFrmCntr = &TCLinkKeyFrmCntr[i].txFrmCntr;
   \   0000BD   EF           MOV     A,R7
   \   0000BE   F8           MOV     R0,A
   \   0000BF   7900         MOV     R1,#0x0
   \   0000C1   E8           MOV     A,R0
   \   0000C2   75F009       MOV     B,#0x9
   \   0000C5   A4           MUL     AB
   \   0000C6   C8           XCH     A,R0
   \   0000C7   AAF0         MOV     R2,B
   \   0000C9   75F000       MOV     B,#0x0
   \   0000CC   A4           MUL     AB
   \   0000CD   2A           ADD     A,R2
   \   0000CE   FA           MOV     R2,A
   \   0000CF   75F009       MOV     B,#0x9
   \   0000D2   E9           MOV     A,R1
   \   0000D3   A4           MUL     AB
   \   0000D4   2A           ADD     A,R2
   \   0000D5   F9           MOV     R1,A
   \   0000D6   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   0000D8   28           ADD     A,R0
   \   0000D9   F8           MOV     R0,A
   \   0000DA   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000DC   39           ADDC    A,R1
   \   0000DD   F9           MOV     R1,A
   \   0000DE   88..         MOV     ?V12,R0
   \   0000E0   89..         MOV     ?V13,R1
   2895          
   2896              // set the keyNvId to use
   2897              si->keyNvId = (ZCD_NV_TCLK_TABLE_START + i);
   \   0000E2   EF           MOV     A,R7
   \   0000E3   F8           MOV     R0,A
   \   0000E4   7900         MOV     R1,#0x0
   \   0000E6   E8           MOV     A,R0
   \   0000E7   2401         ADD     A,#0x1
   \   0000E9   F8           MOV     R0,A
   \   0000EA   E9           MOV     A,R1
   \   0000EB   3401         ADDC    A,#0x1
   \   0000ED   F9           MOV     R1,A
   \   0000EE   E5..         MOV     A,?V10
   \   0000F0   240F         ADD     A,#0xf
   \   0000F2   F582         MOV     DPL,A
   \   0000F4   E4           CLR     A
   \   0000F5   35..         ADDC    A,?V11
   \   0000F7   F583         MOV     DPH,A
   \   0000F9   E8           MOV     A,R0
   \   0000FA   F0           MOVX    @DPTR,A
   \   0000FB   A3           INC     DPTR
   \   0000FC   E9           MOV     A,R1
   \   0000FD   F0           MOVX    @DPTR,A
   2898          
   2899              // update link key related fields
   2900              si->keyID   = SEC_KEYID_LINK;
   \   0000FE   E5..         MOV     A,?V10
   \   000100   240E         ADD     A,#0xe
   \   000102   F582         MOV     DPL,A
   \   000104   E4           CLR     A
   \   000105   35..         ADDC    A,?V11
   \   000107   F583         MOV     DPH,A
   \   000109   7400         MOV     A,#0x0
   \   00010B   F0           MOVX    @DPTR,A
   2901              si->frmCntr = *tclkTxFrmCntr;
   \   00010C   85..82       MOV     DPL,?V12
   \   00010F   85..83       MOV     DPH,?V13
   \   000112   12....       LCALL   ?XLOAD_R0123
   \   000115   E5..         MOV     A,?V10
   \   000117   2412         ADD     A,#0x12
   \   000119   F582         MOV     DPL,A
   \   00011B   E4           CLR     A
   \   00011C   35..         ADDC    A,?V11
   \   00011E   F583         MOV     DPH,A
   \   000120   12....       LCALL   ?XSTORE_R0123
   2902          
   2903              // update outgoing frame counter
   2904              (*tclkTxFrmCntr)++;
   \   000123   90....       MOV     DPTR,#__Constant_1
   \   000126   78..         MOV     R0,#?V0
   \   000128   12....       LCALL   ?L_MOV_X
   \   00012B   85..82       MOV     DPL,?V12
   \   00012E   85..83       MOV     DPH,?V13
   \   000131   78..         MOV     R0,#?V0
   \   000133   12....       LCALL   ?L_ADD_TO_X
   2905          
   2906          #if defined ( NV_RESTORE )
   2907              // write periodically to NV
   2908              if ( !(*tclkTxFrmCntr % MAX_TCLK_FRAMECOUNTER_CHANGES) )
   \   000136   85..82       MOV     DPL,?V12
   \   000139   85..83       MOV     DPH,?V13
   \   00013C   78..         MOV     R0,#?V4
   \   00013E   12....       LCALL   ?L_MOV_X
   \   000141   90....       MOV     DPTR,#__Constant_a
   \   000144   78..         MOV     R0,#?V0
   \   000146   12....       LCALL   ?L_MOV_X
   \   000149   78..         MOV     R0,#?V4
   \   00014B   79..         MOV     R1,#?V0
   \   00014D   12....       LCALL   ?UL_DIV_MOD
   \   000150   E5..         MOV     A,?V0
   \   000152   45..         ORL     A,?V1
   \   000154   45..         ORL     A,?V2
   \   000156   45..         ORL     A,?V3
   \   000158   7033         JNZ     ??APSME_TCLinkKeyLoad_6
   2909              {
   2910                // set the flag to write key to NV
   2911                TCLinkKeyFrmCntr[i].pendingFlag = TRUE;
   \   00015A   EF           MOV     A,R7
   \   00015B   F8           MOV     R0,A
   \   00015C   7900         MOV     R1,#0x0
   \   00015E   E8           MOV     A,R0
   \   00015F   75F009       MOV     B,#0x9
   \   000162   A4           MUL     AB
   \   000163   C8           XCH     A,R0
   \   000164   AAF0         MOV     R2,B
   \   000166   75F000       MOV     B,#0x0
   \   000169   A4           MUL     AB
   \   00016A   2A           ADD     A,R2
   \   00016B   FA           MOV     R2,A
   \   00016C   75F009       MOV     B,#0x9
   \   00016F   E9           MOV     A,R1
   \   000170   A4           MUL     AB
   \   000171   2A           ADD     A,R2
   \   000172   F9           MOV     R1,A
   \   000173   74..         MOV     A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   000175   28           ADD     A,R0
   \   000176   F582         MOV     DPL,A
   \   000178   74..         MOV     A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00017A   39           ADDC    A,R1
   \   00017B   F583         MOV     DPH,A
   \   00017D   7401         MOV     A,#0x1
   \   00017F   F0           MOVX    @DPTR,A
   2912          
   2913                // Notify the ZDApp that the frame counter has changed.
   2914                osal_set_event( ZDAppTaskID, ZDO_TCLK_FRAMECOUNTER_CHANGE );
   \   000180                ; Setup parameters for call to function osal_set_event
   \   000180   7A00         MOV     R2,#0x0
   \   000182   7B04         MOV     R3,#0x4
   \   000184   90....       MOV     DPTR,#ZDAppTaskID
   \   000187   E0           MOVX    A,@DPTR
   \   000188   F9           MOV     R1,A
   \   000189   12....       LCALL   `??osal_set_event::?relay`; Banked call to: osal_set_event
   \   00018C   E9           MOV     A,R1
   2915              }
   2916          #endif
   2917            }
   2918          
   2919            // If no TC link key found, remove the device from the address manager
   2920            if ( (status != ZSuccess) && (AddrMgrEntryLookupNwk(&addrEntry) == TRUE) )
   \                     ??APSME_TCLinkKeyLoad_6:
   \   00018D   EE           MOV     A,R6
   \   00018E   6014         JZ      ??APSME_TCLinkKeyLoad_7
   \   000190                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000190   AA..         MOV     R2,?XSP + 0
   \   000192   AB..         MOV     R3,?XSP + 1
   \   000194   12....       LCALL   `??AddrMgrEntryLookupNwk::?relay`; Banked call to: AddrMgrEntryLookupNwk
   \   000197   E9           MOV     A,R1
   \   000198   6401         XRL     A,#0x1
   \   00019A   7008         JNZ     ??APSME_TCLinkKeyLoad_7
   2921            {
   2922              AddrMgrEntryRelease( &addrEntry );
   \   00019C                ; Setup parameters for call to function AddrMgrEntryRelease
   \   00019C   AA..         MOV     R2,?XSP + 0
   \   00019E   AB..         MOV     R3,?XSP + 1
   \   0001A0   12....       LCALL   `??AddrMgrEntryRelease::?relay`; Banked call to: AddrMgrEntryRelease
   \   0001A3   E9           MOV     A,R1
   2923            }
   2924          
   2925              // clear copy of key in RAM
   2926            osal_memset( &tcLinkKey, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??APSME_TCLinkKeyLoad_7:
   \   0001A4                ; Setup parameters for call to function osal_memset
   \   0001A4   7C20         MOV     R4,#0x20
   \   0001A6   7D00         MOV     R5,#0x0
   \   0001A8   7900         MOV     R1,#0x0
   \   0001AA   740D         MOV     A,#0xd
   \   0001AC   12....       LCALL   ?XSTACK_DISP101_8
   \   0001AF   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2927          
   2928            return status;
   \   0001B2   EE           MOV     A,R6
   \   0001B3   F9           MOV     R1,A
   \   0001B4   742D         MOV     A,#0x2d
   \   0001B6   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001B9   7F10         MOV     R7,#0x10
   \   0001BB   02....       LJMP    ?BANKED_LEAVE_XDATA
   2929          }
   2930          
   2931          /******************************************************************************
   2932           * @fn          APSME_IsDefaultTCLK
   2933           *
   2934           * @brief       Return TRUE or FALSE based on the extended address.  If the
   2935           *              input ext address is all FFs, it means the trust center link
   2936           *              assoiciated with the address is the default trust center link key
   2937           *
   2938           * @param       extAddr - [in] extended address
   2939           *
   2940           * @return      uint8 TRUE/FALSE
   2941           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2942          uint8 APSME_IsDefaultTCLK( uint8 *extAddr )
   \                     APSME_IsDefaultTCLK:
   2943          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2944            return osal_isbufset( extAddr, 0xFF, Z_EXTADDR_LEN );
   \   000009                ; Setup parameters for call to function osal_isbufset
   \   000009   7C08         MOV     R4,#0x8
   \   00000B   79FF         MOV     R1,#-0x1
   \   00000D   EE           MOV     A,R6
   \   00000E   FA           MOV     R2,A
   \   00000F   EF           MOV     A,R7
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   `??osal_isbufset::?relay`; Banked call to: osal_isbufset
   \   000014   7F01         MOV     R7,#0x1
   \   000016   02....       LJMP    ?BANKED_LEAVE_XDATA
   2945          }
   2946          
   2947          /******************************************************************************
   2948           * @fn          ZDSecMgrNwkKeyInit
   2949           *
   2950           * @brief       Initialize the NV items for
   2951           *                  ZCD_NV_NWKKEY,
   2952           *                  ZCD_NV_NWK_ACTIVE_KEY_INFO and
   2953           *                  ZCD_NV_NWK_ALTERN_KEY_INFO
   2954           *
   2955           * @param       setDefault
   2956           *
   2957           * @return      none
   2958           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2959          void ZDSecMgrNwkKeyInit(uint8 setDefault)
   \                     ZDSecMgrNwkKeyInit:
   2960          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FF           MOV     R7,A
   2961            uint8 status;
   2962            nwkKeyDesc nwkKey;
   2963          
   2964            // Initialize NV items for NWK key, this structure contains the frame counter
   2965            // and is only used when NV_RESTORE is enabled
   2966            nwkActiveKeyItems keyItems;
   2967          
   2968            osal_memset( &keyItems, 0, sizeof( nwkActiveKeyItems ) );
   \   00000C                ; Setup parameters for call to function osal_memset
   \   00000C   7C15         MOV     R4,#0x15
   \   00000E   7D00         MOV     R5,#0x0
   \   000010   7900         MOV     R1,#0x0
   \   000012   7411         MOV     A,#0x11
   \   000014   12....       LCALL   ?XSTACK_DISP101_8
   \   000017   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2969          
   2970            status = osal_nv_item_init( ZCD_NV_NWKKEY, sizeof(nwkActiveKeyItems), (void *)&keyItems );
   \   00001A                ; Setup parameters for call to function osal_nv_item_init
   \   00001A   7411         MOV     A,#0x11
   \   00001C   12....       LCALL   ?XSTACK_DISP100_8
   \   00001F   88..         MOV     ?V0,R0
   \   000021   89..         MOV     ?V1,R1
   \   000023   78..         MOV     R0,#?V0
   \   000025   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000028   7C15         MOV     R4,#0x15
   \   00002A   7D00         MOV     R5,#0x0
   \   00002C   7A82         MOV     R2,#-0x7e
   \   00002E   7B00         MOV     R3,#0x0
   \   000030   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?DEALLOC_XSTACK8
   \   000038   E9           MOV     A,R1
   \   000039   FE           MOV     R6,A
   2971          
   2972          #if defined ( NV_RESTORE )
   2973            // reset the values of NV items if NV_RESTORE is not enabled
   2974            if ((status == SUCCESS) && (setDefault == TRUE))
   \   00003A   EE           MOV     A,R6
   \   00003B   702F         JNZ     ??ZDSecMgrNwkKeyInit_0
   \   00003D   7401         MOV     A,#0x1
   \   00003F   6F           XRL     A,R7
   \   000040   702A         JNZ     ??ZDSecMgrNwkKeyInit_0
   2975            {
   2976              // clear NV data to default values
   2977              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   \   000042                ; Setup parameters for call to function osal_nv_write
   \   000042   7411         MOV     A,#0x11
   \   000044   12....       LCALL   ?XSTACK_DISP100_8
   \   000047   88..         MOV     ?V0,R0
   \   000049   89..         MOV     ?V1,R1
   \   00004B   78..         MOV     R0,#?V0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   75..15       MOV     ?V0,#0x15
   \   000053   75..00       MOV     ?V1,#0x0
   \   000056   78..         MOV     R0,#?V0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   7C00         MOV     R4,#0x0
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7A82         MOV     R2,#-0x7e
   \   000061   7B00         MOV     R3,#0x0
   \   000063   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000066   7404         MOV     A,#0x4
   \   000068   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006B   E9           MOV     A,R1
   2978            }
   2979          #else
   2980            (void)setDefault;   // to eliminate compiler warning
   2981          
   2982            // reset the values of NV items if NV_RESTORE is not enabled
   2983            if (status == SUCCESS)
   2984            {
   2985              osal_nv_write( ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems );
   2986            }
   2987          #endif // defined (NV_RESTORE)
   2988          
   2989            // Initialize NV items for NWK Active and Alternate keys. These items are used
   2990            // all the time, independently of NV_RESTORE being set or not
   2991            osal_memset( &nwkKey, 0x00, sizeof(nwkKey) );
   \                     ??ZDSecMgrNwkKeyInit_0:
   \   00006C                ; Setup parameters for call to function osal_memset
   \   00006C   7C11         MOV     R4,#0x11
   \   00006E   7D00         MOV     R5,#0x0
   \   000070   7900         MOV     R1,#0x0
   \   000072   AA..         MOV     R2,?XSP + 0
   \   000074   AB..         MOV     R3,?XSP + 1
   \   000076   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   2992          
   2993            status = osal_nv_item_init( ZCD_NV_NWK_ACTIVE_KEY_INFO, sizeof(nwkKey), &nwkKey);
   \   000079                ; Setup parameters for call to function osal_nv_item_init
   \   000079   A8..         MOV     R0,?XSP + 0
   \   00007B   A9..         MOV     R1,?XSP + 1
   \   00007D   88..         MOV     ?V0,R0
   \   00007F   89..         MOV     ?V1,R1
   \   000081   78..         MOV     R0,#?V0
   \   000083   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000086   7C11         MOV     R4,#0x11
   \   000088   7D00         MOV     R5,#0x0
   \   00008A   7A3A         MOV     R2,#0x3a
   \   00008C   7B00         MOV     R3,#0x0
   \   00008E   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   000091   7402         MOV     A,#0x2
   \   000093   12....       LCALL   ?DEALLOC_XSTACK8
   \   000096   E9           MOV     A,R1
   \   000097   FE           MOV     R6,A
   2994          
   2995          #if defined ( NV_RESTORE )
   2996            // reset the values of NV items if NV_RESTORE is not enabled
   2997            if ((status == SUCCESS) && (setDefault == TRUE))
   \   000098   EE           MOV     A,R6
   \   000099   702E         JNZ     ??ZDSecMgrNwkKeyInit_1
   \   00009B   7401         MOV     A,#0x1
   \   00009D   6F           XRL     A,R7
   \   00009E   7029         JNZ     ??ZDSecMgrNwkKeyInit_1
   2998            {
   2999              // clear NV data to default values
   3000              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000A0                ; Setup parameters for call to function osal_nv_write
   \   0000A0   A8..         MOV     R0,?XSP + 0
   \   0000A2   A9..         MOV     R1,?XSP + 1
   \   0000A4   88..         MOV     ?V0,R0
   \   0000A6   89..         MOV     ?V1,R1
   \   0000A8   78..         MOV     R0,#?V0
   \   0000AA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000AD   75..11       MOV     ?V0,#0x11
   \   0000B0   75..00       MOV     ?V1,#0x0
   \   0000B3   78..         MOV     R0,#?V0
   \   0000B5   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000B8   7C00         MOV     R4,#0x0
   \   0000BA   7D00         MOV     R5,#0x0
   \   0000BC   7A3A         MOV     R2,#0x3a
   \   0000BE   7B00         MOV     R3,#0x0
   \   0000C0   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   0000C3   7404         MOV     A,#0x4
   \   0000C5   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C8   E9           MOV     A,R1
   3001            }
   3002          #else
   3003            // reset the values of NV items if NV_RESTORE is not enabled
   3004            if (status == SUCCESS)
   3005            {
   3006              osal_nv_write( ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   3007            }
   3008          #endif // defined (NV_RESTORE)
   3009          
   3010            status = osal_nv_item_init( ZCD_NV_NWK_ALTERN_KEY_INFO, sizeof(nwkKey), &nwkKey );
   \                     ??ZDSecMgrNwkKeyInit_1:
   \   0000C9                ; Setup parameters for call to function osal_nv_item_init
   \   0000C9   A8..         MOV     R0,?XSP + 0
   \   0000CB   A9..         MOV     R1,?XSP + 1
   \   0000CD   88..         MOV     ?V0,R0
   \   0000CF   89..         MOV     ?V1,R1
   \   0000D1   78..         MOV     R0,#?V0
   \   0000D3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000D6   7C11         MOV     R4,#0x11
   \   0000D8   7D00         MOV     R5,#0x0
   \   0000DA   7A3B         MOV     R2,#0x3b
   \   0000DC   7B00         MOV     R3,#0x0
   \   0000DE   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   0000E1   7402         MOV     A,#0x2
   \   0000E3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000E6   E9           MOV     A,R1
   \   0000E7   FE           MOV     R6,A
   3011          
   3012          #if defined ( NV_RESTORE )
   3013            // reset the values of NV items if NV_RESTORE is not enabled
   3014            if ((status == SUCCESS) && (setDefault == TRUE))
   \   0000E8   EE           MOV     A,R6
   \   0000E9   702E         JNZ     ??ZDSecMgrNwkKeyInit_2
   \   0000EB   7401         MOV     A,#0x1
   \   0000ED   6F           XRL     A,R7
   \   0000EE   7029         JNZ     ??ZDSecMgrNwkKeyInit_2
   3015            {
   3016              // clear NV data to default values
   3017              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   \   0000F0                ; Setup parameters for call to function osal_nv_write
   \   0000F0   A8..         MOV     R0,?XSP + 0
   \   0000F2   A9..         MOV     R1,?XSP + 1
   \   0000F4   88..         MOV     ?V0,R0
   \   0000F6   89..         MOV     ?V1,R1
   \   0000F8   78..         MOV     R0,#?V0
   \   0000FA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FD   75..11       MOV     ?V0,#0x11
   \   000100   75..00       MOV     ?V1,#0x0
   \   000103   78..         MOV     R0,#?V0
   \   000105   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000108   7C00         MOV     R4,#0x0
   \   00010A   7D00         MOV     R5,#0x0
   \   00010C   7A3B         MOV     R2,#0x3b
   \   00010E   7B00         MOV     R3,#0x0
   \   000110   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000113   7404         MOV     A,#0x4
   \   000115   12....       LCALL   ?DEALLOC_XSTACK8
   \   000118   E9           MOV     A,R1
   3018            }
   3019          #else
   3020            // reset the values of NV items if NV_RESTORE is not enabled
   3021            if (status == SUCCESS)
   3022            {
   3023              osal_nv_write( ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKey), &nwkKey );
   3024            }
   3025          #endif // defined (NV_RESTORE)
   3026          
   3027          }
   \                     ??ZDSecMgrNwkKeyInit_2:
   \   000119   7426         MOV     A,#0x26
   \   00011B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011E   7F02         MOV     R7,#0x2
   \   000120   02....       LJMP    ?BANKED_LEAVE_XDATA
   3028          
   3029          /*********************************************************************
   3030           * @fn          ZDSecMgrReadKeyFromNv
   3031           *
   3032           * @brief       Looks for a specific key in NV based on Index value
   3033           *
   3034           * @param   keyNvId - Index of key to look in NV
   3035           *                    valid values are:
   3036           *                    ZCD_NV_NWK_ACTIVE_KEY_INFO
   3037           *                    ZCD_NV_NWK_ALTERN_KEY_INFO
   3038           *                    ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3039           *                    ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3040           *                    ZCD_NV_PRECFGKEY
   3041           *
   3042           * @param  *keyinfo - Data is read into this buffer.
   3043           *
   3044           * @return  SUCCESS if NV data was copied to the keyinfo parameter .
   3045           *          Otherwise, NV_OPER_FAILED for failure.
   3046           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3047          ZStatus_t ZDSecMgrReadKeyFromNv(uint16 keyNvId, void *keyinfo)
   \                     ZDSecMgrReadKeyFromNv:
   3048          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0,R4
   \   00000B   8D..         MOV     ?V1,R5
   3049            if ((keyNvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
   3050                (keyNvId == ZCD_NV_NWK_ALTERN_KEY_INFO))
   \   00000D   743A         MOV     A,#0x3a
   \   00000F   6E           XRL     A,R6
   \   000010   7003         JNZ     ??ZDSecMgrReadKeyFromNv_0
   \   000012   7400         MOV     A,#0x0
   \   000014   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_0:
   \   000015   600A         JZ      ??ZDSecMgrReadKeyFromNv_1
   \   000017   743B         MOV     A,#0x3b
   \   000019   6E           XRL     A,R6
   \   00001A   7003         JNZ     ??ZDSecMgrReadKeyFromNv_2
   \   00001C   7400         MOV     A,#0x0
   \   00001E   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_2:
   \   00001F   7023         JNZ     ??ZDSecMgrReadKeyFromNv_3
   3051            {
   3052              // get NWK active or alternate key from NV
   3053              return (osal_nv_read(keyNvId,
   3054                                   osal_offsetof(nwkKeyDesc, key),
   3055                                   SEC_KEY_LEN,
   3056                                   keyinfo));
   \                     ??ZDSecMgrReadKeyFromNv_1:
   \   000021                ; Setup parameters for call to function osal_nv_read
   \   000021   78..         MOV     R0,#?V0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   75..10       MOV     ?V2,#0x10
   \   000029   75..00       MOV     ?V3,#0x0
   \   00002C   78..         MOV     R0,#?V2
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7C01         MOV     R4,#0x1
   \   000033   7D00         MOV     R5,#0x0
   \   000035   EE           MOV     A,R6
   \   000036   FA           MOV     R2,A
   \   000037   EF           MOV     A,R7
   \   000038   FB           MOV     R3,A
   \   000039   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000041   02....       LJMP    ??ZDSecMgrReadKeyFromNv_4 & 0xFFFF
   3057            }
   3058            else if ((keyNvId >= ZCD_NV_TCLK_TABLE_START) &&
   3059                     (keyNvId < (ZCD_NV_TCLK_TABLE_START + ZDSECMGR_TC_DEVICE_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_3:
   \   000044   C3           CLR     C
   \   000045   EE           MOV     A,R6
   \   000046   9401         SUBB    A,#0x1
   \   000048   EF           MOV     A,R7
   \   000049   9401         SUBB    A,#0x1
   \   00004B   402B         JC      ??ZDSecMgrReadKeyFromNv_5
   \   00004D   C3           CLR     C
   \   00004E   EE           MOV     A,R6
   \   00004F   9402         SUBB    A,#0x2
   \   000051   EF           MOV     A,R7
   \   000052   9401         SUBB    A,#0x1
   \   000054   5022         JNC     ??ZDSecMgrReadKeyFromNv_5
   3060            {
   3061              // Read entry keyNvId of the TC link key table from NV. keyNvId should be
   3062              // ZCD_NV_TCLK_TABLE_START + <offset_in_table>
   3063              return (osal_nv_read(keyNvId,
   3064                                   osal_offsetof(APSME_TCLinkKey_t, key),
   3065                                   SEC_KEY_LEN,
   3066                                   keyinfo));
   \   000056                ; Setup parameters for call to function osal_nv_read
   \   000056   78..         MOV     R0,#?V0
   \   000058   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005B   75..10       MOV     ?V2,#0x10
   \   00005E   75..00       MOV     ?V3,#0x0
   \   000061   78..         MOV     R0,#?V2
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000066   7C08         MOV     R4,#0x8
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   EE           MOV     A,R6
   \   00006B   FA           MOV     R2,A
   \   00006C   EF           MOV     A,R7
   \   00006D   FB           MOV     R3,A
   \   00006E   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000071   7404         MOV     A,#0x4
   \   000073   12....       LCALL   ?DEALLOC_XSTACK8
   \   000076   8062         SJMP    ??ZDSecMgrReadKeyFromNv_4
   3067            }
   3068            else if ((keyNvId >= ZCD_NV_APS_LINK_KEY_DATA_START) &&
   3069                     (keyNvId < (ZCD_NV_APS_LINK_KEY_DATA_START + ZDSECMGR_ENTRY_MAX)))
   \                     ??ZDSecMgrReadKeyFromNv_5:
   \   000078   C3           CLR     C
   \   000079   EE           MOV     A,R6
   \   00007A   9401         SUBB    A,#0x1
   \   00007C   EF           MOV     A,R7
   \   00007D   9402         SUBB    A,#0x2
   \   00007F   402B         JC      ??ZDSecMgrReadKeyFromNv_6
   \   000081   C3           CLR     C
   \   000082   EE           MOV     A,R6
   \   000083   9404         SUBB    A,#0x4
   \   000085   EF           MOV     A,R7
   \   000086   9402         SUBB    A,#0x2
   \   000088   5022         JNC     ??ZDSecMgrReadKeyFromNv_6
   3070            {
   3071              // Read entry keyNvId of the APS link key table from NV. keyNvId should be
   3072              // ZCD_NV_APS_LINK_KEY_DATA_START + <offset_in_table>
   3073              return (osal_nv_read(keyNvId,
   3074                                   osal_offsetof(APSME_LinkKeyData_t, key),
   3075                                   SEC_KEY_LEN,
   3076                                   keyinfo));
   \   00008A                ; Setup parameters for call to function osal_nv_read
   \   00008A   78..         MOV     R0,#?V0
   \   00008C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00008F   75..10       MOV     ?V2,#0x10
   \   000092   75..00       MOV     ?V3,#0x0
   \   000095   78..         MOV     R0,#?V2
   \   000097   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00009A   7C00         MOV     R4,#0x0
   \   00009C   7D00         MOV     R5,#0x0
   \   00009E   EE           MOV     A,R6
   \   00009F   FA           MOV     R2,A
   \   0000A0   EF           MOV     A,R7
   \   0000A1   FB           MOV     R3,A
   \   0000A2   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000A5   7404         MOV     A,#0x4
   \   0000A7   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AA   802E         SJMP    ??ZDSecMgrReadKeyFromNv_4
   3077            }
   3078            else if (keyNvId == ZCD_NV_PRECFGKEY)
   \                     ??ZDSecMgrReadKeyFromNv_6:
   \   0000AC   7462         MOV     A,#0x62
   \   0000AE   6E           XRL     A,R6
   \   0000AF   7003         JNZ     ??ZDSecMgrReadKeyFromNv_7
   \   0000B1   7400         MOV     A,#0x0
   \   0000B3   6F           XRL     A,R7
   \                     ??ZDSecMgrReadKeyFromNv_7:
   \   0000B4   7022         JNZ     ??ZDSecMgrReadKeyFromNv_8
   3079            {
   3080              // Read entry keyNvId of the Preconfig key from NV.
   3081              return (osal_nv_read(keyNvId,
   3082                                   0,
   3083                                   SEC_KEY_LEN,
   3084                                   keyinfo));
   \   0000B6                ; Setup parameters for call to function osal_nv_read
   \   0000B6   78..         MOV     R0,#?V0
   \   0000B8   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000BB   75..10       MOV     ?V2,#0x10
   \   0000BE   75..00       MOV     ?V3,#0x0
   \   0000C1   78..         MOV     R0,#?V2
   \   0000C3   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000C6   7C00         MOV     R4,#0x0
   \   0000C8   7D00         MOV     R5,#0x0
   \   0000CA   EE           MOV     A,R6
   \   0000CB   FA           MOV     R2,A
   \   0000CC   EF           MOV     A,R7
   \   0000CD   FB           MOV     R3,A
   \   0000CE   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   0000D1   7404         MOV     A,#0x4
   \   0000D3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000D6   8002         SJMP    ??ZDSecMgrReadKeyFromNv_4
   3085            }
   3086          
   3087            return NV_OPER_FAILED;
   \                     ??ZDSecMgrReadKeyFromNv_8:
   \   0000D8   790A         MOV     R1,#0xa
   \                     ??ZDSecMgrReadKeyFromNv_4:
   \   0000DA   7F04         MOV     R7,#0x4
   \   0000DC   02....       LJMP    ?BANKED_LEAVE_XDATA
   3088          }
   3089          
   3090          /******************************************************************************
   3091           * @fn          ZDSecMgrApsLinkKeyInit
   3092           *
   3093           * @brief       Initialize the NV table for Application link keys
   3094           *
   3095           * @param       none
   3096           *
   3097           * @return      none
   3098           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3099          void ZDSecMgrApsLinkKeyInit(void)
   \                     ZDSecMgrApsLinkKeyInit:
   3100          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 24
   \   000005   74E8         MOV     A,#-0x18
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3101            APSME_LinkKeyData_t pApsLinkKey;
   3102            uint8 i;
   3103            uint8 status;
   3104          
   3105            // Initialize all NV items for APS link key, if not exist already.
   3106            osal_memset( &pApsLinkKey, 0x00, sizeof(APSME_LinkKeyData_t) );
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C18         MOV     R4,#0x18
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   AA..         MOV     R2,?XSP + 0
   \   000012   AB..         MOV     R3,?XSP + 1
   \   000014   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3107          
   3108            for( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000017   7E00         MOV     R6,#0x0
   \                     ??ZDSecMgrApsLinkKeyInit_0:
   \   000019   EE           MOV     A,R6
   \   00001A   C3           CLR     C
   \   00001B   9403         SUBB    A,#0x3
   \   00001D   502A         JNC     ??ZDSecMgrApsLinkKeyInit_1
   3109            {
   3110              status = osal_nv_item_init( (ZCD_NV_APS_LINK_KEY_DATA_START + i),
   3111                                         sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   \   00001F                ; Setup parameters for call to function osal_nv_item_init
   \   00001F   A8..         MOV     R0,?XSP + 0
   \   000021   A9..         MOV     R1,?XSP + 1
   \   000023   88..         MOV     ?V0,R0
   \   000025   89..         MOV     ?V1,R1
   \   000027   78..         MOV     R0,#?V0
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002C   7C18         MOV     R4,#0x18
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   EE           MOV     A,R6
   \   000031   F8           MOV     R0,A
   \   000032   7900         MOV     R1,#0x0
   \   000034   E8           MOV     A,R0
   \   000035   2401         ADD     A,#0x1
   \   000037   FA           MOV     R2,A
   \   000038   E9           MOV     A,R1
   \   000039   3402         ADDC    A,#0x2
   \   00003B   FB           MOV     R3,A
   \   00003C   12....       LCALL   `??osal_nv_item_init::?relay`; Banked call to: osal_nv_item_init
   \   00003F   7402         MOV     A,#0x2
   \   000041   12....       LCALL   ?DEALLOC_XSTACK8
   \   000044   E9           MOV     A,R1
   \   000045   FF           MOV     R7,A
   3112          
   3113          #if defined ( NV_RESTORE )
   3114              (void)status;   // to eliminate compiler warning
   3115          #else
   3116              // reset the values of NV items if NV_RESTORE is not enabled
   3117              if (status == SUCCESS)
   3118              {
   3119                osal_nv_write( (ZCD_NV_APS_LINK_KEY_DATA_START + i), 0,
   3120                              sizeof(APSME_LinkKeyData_t), &pApsLinkKey );
   3121          
   3122              }
   3123          #endif // defined (NV_RESTORE)
   3124            }
   \   000046   0E           INC     R6
   \   000047   80D0         SJMP    ??ZDSecMgrApsLinkKeyInit_0
   3125          }
   \                     ??ZDSecMgrApsLinkKeyInit_1:
   \   000049   7418         MOV     A,#0x18
   \   00004B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004E   7F02         MOV     R7,#0x2
   \   000050   02....       LJMP    ?BANKED_LEAVE_XDATA
   3126          
   3127          /******************************************************************************
   3128           * @fn          ZDSecMgrInitNVKeyTables
   3129           *
   3130           * @brief       Initialize the NV table for All keys: NWK, Master, TCLK and APS
   3131           *
   3132           * @param       setDefault - TRUE to set default values
   3133           *
   3134           * @return      none
   3135           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3136          void ZDSecMgrInitNVKeyTables(uint8 setDefault)
   \                     ZDSecMgrInitNVKeyTables:
   3137          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
   3138            ZDSecMgrNwkKeyInit(setDefault);
   \   000007                ; Setup parameters for call to function ZDSecMgrNwkKeyInit
   \   000007   EE           MOV     A,R6
   \   000008   F9           MOV     R1,A
   \   000009   12....       LCALL   `??ZDSecMgrNwkKeyInit::?relay`; Banked call to: ZDSecMgrNwkKeyInit
   3139            ZDSecMgrApsLinkKeyInit();
   \   00000C                ; Setup parameters for call to function ZDSecMgrApsLinkKeyInit
   \   00000C   12....       LCALL   `??ZDSecMgrApsLinkKeyInit::?relay`; Banked call to: ZDSecMgrApsLinkKeyInit
   3140            APSME_TCLinkKeyInit(setDefault);
   \   00000F                ; Setup parameters for call to function APSME_TCLinkKeyInit
   \   00000F   EE           MOV     A,R6
   \   000010   F9           MOV     R1,A
   \   000011   12....       LCALL   `??APSME_TCLinkKeyInit::?relay`; Banked call to: APSME_TCLinkKeyInit
   3141          }
   \   000014   7F01         MOV     R7,#0x1
   \   000016   02....       LJMP    ?BANKED_LEAVE_XDATA
   3142          
   3143          /******************************************************************************
   3144           * @fn          ZDSecMgrSaveApsLinkKey
   3145           *
   3146           * @brief       Save APS Link Key to NV. It will loop through all the keys
   3147           *              to see which one to save.
   3148           *
   3149           * @param       none
   3150           *
   3151           * @return      none
   3152           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3153          void ZDSecMgrSaveApsLinkKey(void)
   \                     ZDSecMgrSaveApsLinkKey:
   3154          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3155            APSME_LinkKeyData_t *pKeyData = NULL;
   \   000005   75..00       MOV     ?V0,#0x0
   \   000008   75..00       MOV     ?V1,#0x0
   3156            int i;
   3157          
   3158            pKeyData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A18         MOV     R2,#0x18
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   85....       MOV     ?V0,?V2
   \   000019   85....       MOV     ?V1,?V3
   3159          
   3160            if (pKeyData != NULL)
   \   00001C   E5..         MOV     A,?V0
   \   00001E   45..         ORL     A,?V1
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_0 & 0xFFFF
   3161            {
   3162              // checks all pending flags to know which one to save
   3163              for (i = 0; i < ZDSECMGR_ENTRY_MAX; i++)
   \   000025   7E00         MOV     R6,#0x0
   \   000027   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSaveApsLinkKey_1:
   \   000029   C3           CLR     C
   \   00002A   EE           MOV     A,R6
   \   00002B   9403         SUBB    A,#0x3
   \   00002D   EF           MOV     A,R7
   \   00002E   9400         SUBB    A,#0x0
   \   000030   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000032   65D0         XRL     A,PSW
   \   000034   33           RLC     A
   \   000035   4003         JC      $+5
   \   000037   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_2 & 0xFFFF
   3164              {
   3165                if (ApsLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   00003A   EE           MOV     A,R6
   \   00003B   F8           MOV     R0,A
   \   00003C   EF           MOV     A,R7
   \   00003D   F9           MOV     R1,A
   \   00003E   E8           MOV     A,R0
   \   00003F   75F009       MOV     B,#0x9
   \   000042   A4           MUL     AB
   \   000043   C8           XCH     A,R0
   \   000044   AAF0         MOV     R2,B
   \   000046   75F000       MOV     B,#0x0
   \   000049   A4           MUL     AB
   \   00004A   2A           ADD     A,R2
   \   00004B   FA           MOV     R2,A
   \   00004C   75F009       MOV     B,#0x9
   \   00004F   E9           MOV     A,R1
   \   000050   A4           MUL     AB
   \   000051   2A           ADD     A,R2
   \   000052   F9           MOV     R1,A
   \   000053   74..         MOV     A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000055   28           ADD     A,R0
   \   000056   F582         MOV     DPL,A
   \   000058   74..         MOV     A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00005A   39           ADDC    A,R1
   \   00005B   F583         MOV     DPH,A
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   6401         XRL     A,#0x1
   \   000060   6003         JZ      $+5
   \   000062   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_3 & 0xFFFF
   3166                {
   3167                  // retrieve key from NV
   3168                  if (osal_nv_read(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3169                                   sizeof(APSME_LinkKeyData_t), pKeyData) == SUCCESS)
   \   000065                ; Setup parameters for call to function osal_nv_read
   \   000065   78..         MOV     R0,#?V0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   75..18       MOV     ?V2,#0x18
   \   00006D   75..00       MOV     ?V3,#0x0
   \   000070   78..         MOV     R0,#?V2
   \   000072   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000075   7C00         MOV     R4,#0x0
   \   000077   7D00         MOV     R5,#0x0
   \   000079   EE           MOV     A,R6
   \   00007A   2401         ADD     A,#0x1
   \   00007C   FA           MOV     R2,A
   \   00007D   EF           MOV     A,R7
   \   00007E   3402         ADDC    A,#0x2
   \   000080   FB           MOV     R3,A
   \   000081   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   000084   7404         MOV     A,#0x4
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
   \   000089   E9           MOV     A,R1
   \   00008A   6003         JZ      $+5
   \   00008C   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_3 & 0xFFFF
   3170                  {
   3171                    pKeyData->txFrmCntr = ApsLinkKeyFrmCntr[i].txFrmCntr;
   \   00008F   EE           MOV     A,R6
   \   000090   F8           MOV     R0,A
   \   000091   EF           MOV     A,R7
   \   000092   F9           MOV     R1,A
   \   000093   E8           MOV     A,R0
   \   000094   75F009       MOV     B,#0x9
   \   000097   A4           MUL     AB
   \   000098   C8           XCH     A,R0
   \   000099   AAF0         MOV     R2,B
   \   00009B   75F000       MOV     B,#0x0
   \   00009E   A4           MUL     AB
   \   00009F   2A           ADD     A,R2
   \   0000A0   FA           MOV     R2,A
   \   0000A1   75F009       MOV     B,#0x9
   \   0000A4   E9           MOV     A,R1
   \   0000A5   A4           MUL     AB
   \   0000A6   2A           ADD     A,R2
   \   0000A7   F9           MOV     R1,A
   \   0000A8   74..         MOV     A,#ApsLinkKeyFrmCntr & 0xff
   \   0000AA   28           ADD     A,R0
   \   0000AB   F582         MOV     DPL,A
   \   0000AD   74..         MOV     A,#(ApsLinkKeyFrmCntr >> 8) & 0xff
   \   0000AF   39           ADDC    A,R1
   \   0000B0   F583         MOV     DPH,A
   \   0000B2   12....       LCALL   ?XLOAD_R0123
   \   0000B5   E5..         MOV     A,?V0
   \   0000B7   2410         ADD     A,#0x10
   \   0000B9   F582         MOV     DPL,A
   \   0000BB   E4           CLR     A
   \   0000BC   35..         ADDC    A,?V1
   \   0000BE   F583         MOV     DPH,A
   \   0000C0   12....       LCALL   ?XSTORE_R0123
   3172                    pKeyData->rxFrmCntr = ApsLinkKeyFrmCntr[i].rxFrmCntr;
   \   0000C3   EE           MOV     A,R6
   \   0000C4   F8           MOV     R0,A
   \   0000C5   EF           MOV     A,R7
   \   0000C6   F9           MOV     R1,A
   \   0000C7   E8           MOV     A,R0
   \   0000C8   75F009       MOV     B,#0x9
   \   0000CB   A4           MUL     AB
   \   0000CC   C8           XCH     A,R0
   \   0000CD   AAF0         MOV     R2,B
   \   0000CF   75F000       MOV     B,#0x0
   \   0000D2   A4           MUL     AB
   \   0000D3   2A           ADD     A,R2
   \   0000D4   FA           MOV     R2,A
   \   0000D5   75F009       MOV     B,#0x9
   \   0000D8   E9           MOV     A,R1
   \   0000D9   A4           MUL     AB
   \   0000DA   2A           ADD     A,R2
   \   0000DB   F9           MOV     R1,A
   \   0000DC   74..         MOV     A,#(ApsLinkKeyFrmCntr + 4) & 0xff
   \   0000DE   28           ADD     A,R0
   \   0000DF   F582         MOV     DPL,A
   \   0000E1   74..         MOV     A,#((ApsLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000E3   39           ADDC    A,R1
   \   0000E4   F583         MOV     DPH,A
   \   0000E6   12....       LCALL   ?XLOAD_R0123
   \   0000E9   E5..         MOV     A,?V0
   \   0000EB   2414         ADD     A,#0x14
   \   0000ED   F582         MOV     DPL,A
   \   0000EF   E4           CLR     A
   \   0000F0   35..         ADDC    A,?V1
   \   0000F2   F583         MOV     DPH,A
   \   0000F4   12....       LCALL   ?XSTORE_R0123
   3173          
   3174                    // Write the APS link key back to the NV
   3175                    osal_nv_write(ZCD_NV_APS_LINK_KEY_DATA_START + i, 0,
   3176                                  sizeof(APSME_LinkKeyData_t), pKeyData);
   \   0000F7                ; Setup parameters for call to function osal_nv_write
   \   0000F7   78..         MOV     R0,#?V0
   \   0000F9   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FC   75..18       MOV     ?V2,#0x18
   \   0000FF   75..00       MOV     ?V3,#0x0
   \   000102   78..         MOV     R0,#?V2
   \   000104   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000107   7C00         MOV     R4,#0x0
   \   000109   7D00         MOV     R5,#0x0
   \   00010B   EE           MOV     A,R6
   \   00010C   2401         ADD     A,#0x1
   \   00010E   FA           MOV     R2,A
   \   00010F   EF           MOV     A,R7
   \   000110   3402         ADDC    A,#0x2
   \   000112   FB           MOV     R3,A
   \   000113   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000116   7404         MOV     A,#0x4
   \   000118   12....       LCALL   ?DEALLOC_XSTACK8
   \   00011B   E9           MOV     A,R1
   3177          
   3178                    // clear the pending write flag
   3179                    ApsLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   00011C   EE           MOV     A,R6
   \   00011D   F8           MOV     R0,A
   \   00011E   EF           MOV     A,R7
   \   00011F   F9           MOV     R1,A
   \   000120   E8           MOV     A,R0
   \   000121   75F009       MOV     B,#0x9
   \   000124   A4           MUL     AB
   \   000125   C8           XCH     A,R0
   \   000126   AAF0         MOV     R2,B
   \   000128   75F000       MOV     B,#0x0
   \   00012B   A4           MUL     AB
   \   00012C   2A           ADD     A,R2
   \   00012D   FA           MOV     R2,A
   \   00012E   75F009       MOV     B,#0x9
   \   000131   E9           MOV     A,R1
   \   000132   A4           MUL     AB
   \   000133   2A           ADD     A,R2
   \   000134   F9           MOV     R1,A
   \   000135   74..         MOV     A,#(ApsLinkKeyFrmCntr + 8) & 0xff
   \   000137   28           ADD     A,R0
   \   000138   F582         MOV     DPL,A
   \   00013A   74..         MOV     A,#((ApsLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   00013C   39           ADDC    A,R1
   \   00013D   F583         MOV     DPH,A
   \   00013F   7400         MOV     A,#0x0
   \   000141   F0           MOVX    @DPTR,A
   3180                  }
   3181                }
   3182              }
   \                     ??ZDSecMgrSaveApsLinkKey_3:
   \   000142   0E           INC     R6
   \   000143   EE           MOV     A,R6
   \   000144   7001         JNZ     ??ZDSecMgrSaveApsLinkKey_4
   \   000146   0F           INC     R7
   \                     ??ZDSecMgrSaveApsLinkKey_4:
   \   000147   02....       LJMP    ??ZDSecMgrSaveApsLinkKey_1 & 0xFFFF
   3183          
   3184              // clear copy of key in RAM
   3185              osal_memset( pKeyData, 0x00, sizeof(APSME_LinkKeyData_t) );
   \                     ??ZDSecMgrSaveApsLinkKey_2:
   \   00014A                ; Setup parameters for call to function osal_memset
   \   00014A   7C18         MOV     R4,#0x18
   \   00014C   7D00         MOV     R5,#0x0
   \   00014E   7900         MOV     R1,#0x0
   \   000150   AA..         MOV     R2,?V0
   \   000152   AB..         MOV     R3,?V1
   \   000154   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3186          
   3187              osal_mem_free(pKeyData);
   \   000157                ; Setup parameters for call to function osal_mem_free
   \   000157   AA..         MOV     R2,?V0
   \   000159   AB..         MOV     R3,?V1
   \   00015B   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3188            }
   3189          }
   \                     ??ZDSecMgrSaveApsLinkKey_0:
   \   00015E   7F04         MOV     R7,#0x4
   \   000160   02....       LJMP    ?BANKED_LEAVE_XDATA
   3190          
   3191          /******************************************************************************
   3192           * @fn          ZDSecMgrSaveTCLinkKey
   3193           *
   3194           * @brief       Save TC Link Key to NV. It will loop through all the keys
   3195           *              to see which one to save.
   3196           *
   3197           * @param       none
   3198           *
   3199           * @return      none
   3200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3201          void ZDSecMgrSaveTCLinkKey(void)
   \                     ZDSecMgrSaveTCLinkKey:
   3202          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   3203            APSME_TCLinkKey_t *pKeyData = NULL;
   \   000005   75..00       MOV     ?V0,#0x0
   \   000008   75..00       MOV     ?V1,#0x0
   3204            uint16 i;
   3205          
   3206            pKeyData = (APSME_TCLinkKey_t *)osal_mem_alloc(sizeof(APSME_TCLinkKey_t));
   \   00000B                ; Setup parameters for call to function osal_mem_alloc
   \   00000B   7A20         MOV     R2,#0x20
   \   00000D   7B00         MOV     R3,#0x0
   \   00000F   12....       LCALL   `??osal_mem_alloc::?relay`; Banked call to: osal_mem_alloc
   \   000012   8A..         MOV     ?V2,R2
   \   000014   8B..         MOV     ?V3,R3
   \   000016   85....       MOV     ?V0,?V2
   \   000019   85....       MOV     ?V1,?V3
   3207          
   3208            if (pKeyData != NULL)
   \   00001C   E5..         MOV     A,?V0
   \   00001E   45..         ORL     A,?V1
   \   000020   7003         JNZ     $+5
   \   000022   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_0 & 0xFFFF
   3209            {
   3210              for( i = 0; i < ZDSECMGR_TC_DEVICE_MAX; i++ )
   \   000025   7E00         MOV     R6,#0x0
   \   000027   7F00         MOV     R7,#0x0
   \                     ??ZDSecMgrSaveTCLinkKey_1:
   \   000029   EE           MOV     A,R6
   \   00002A   4F           ORL     A,R7
   \   00002B   6003         JZ      $+5
   \   00002D   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_2 & 0xFFFF
   3211              {
   3212                if (TCLinkKeyFrmCntr[i].pendingFlag == TRUE)
   \   000030   EE           MOV     A,R6
   \   000031   F8           MOV     R0,A
   \   000032   EF           MOV     A,R7
   \   000033   F9           MOV     R1,A
   \   000034   E8           MOV     A,R0
   \   000035   75F009       MOV     B,#0x9
   \   000038   A4           MUL     AB
   \   000039   C8           XCH     A,R0
   \   00003A   AAF0         MOV     R2,B
   \   00003C   75F000       MOV     B,#0x0
   \   00003F   A4           MUL     AB
   \   000040   2A           ADD     A,R2
   \   000041   FA           MOV     R2,A
   \   000042   75F009       MOV     B,#0x9
   \   000045   E9           MOV     A,R1
   \   000046   A4           MUL     AB
   \   000047   2A           ADD     A,R2
   \   000048   F9           MOV     R1,A
   \   000049   74..         MOV     A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   00004B   28           ADD     A,R0
   \   00004C   F582         MOV     DPL,A
   \   00004E   74..         MOV     A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   000050   39           ADDC    A,R1
   \   000051   F583         MOV     DPH,A
   \   000053   E0           MOVX    A,@DPTR
   \   000054   6401         XRL     A,#0x1
   \   000056   6003         JZ      $+5
   \   000058   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_3 & 0xFFFF
   3213                {
   3214                  if (osal_nv_read(ZCD_NV_TCLK_TABLE_START + i, 0,
   3215                                   sizeof(APSME_TCLinkKey_t), pKeyData) == SUCCESS)
   \   00005B                ; Setup parameters for call to function osal_nv_read
   \   00005B   78..         MOV     R0,#?V0
   \   00005D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000060   75..20       MOV     ?V2,#0x20
   \   000063   75..00       MOV     ?V3,#0x0
   \   000066   78..         MOV     R0,#?V2
   \   000068   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006B   7C00         MOV     R4,#0x0
   \   00006D   7D00         MOV     R5,#0x0
   \   00006F   EE           MOV     A,R6
   \   000070   2401         ADD     A,#0x1
   \   000072   FA           MOV     R2,A
   \   000073   EF           MOV     A,R7
   \   000074   3401         ADDC    A,#0x1
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   `??osal_nv_read::?relay`; Banked call to: osal_nv_read
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00007F   E9           MOV     A,R1
   \   000080   6003         JZ      $+5
   \   000082   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_3 & 0xFFFF
   3216                  {
   3217                    pKeyData->txFrmCntr = TCLinkKeyFrmCntr[i].txFrmCntr;
   \   000085   EE           MOV     A,R6
   \   000086   F8           MOV     R0,A
   \   000087   EF           MOV     A,R7
   \   000088   F9           MOV     R1,A
   \   000089   E8           MOV     A,R0
   \   00008A   75F009       MOV     B,#0x9
   \   00008D   A4           MUL     AB
   \   00008E   C8           XCH     A,R0
   \   00008F   AAF0         MOV     R2,B
   \   000091   75F000       MOV     B,#0x0
   \   000094   A4           MUL     AB
   \   000095   2A           ADD     A,R2
   \   000096   FA           MOV     R2,A
   \   000097   75F009       MOV     B,#0x9
   \   00009A   E9           MOV     A,R1
   \   00009B   A4           MUL     AB
   \   00009C   2A           ADD     A,R2
   \   00009D   F9           MOV     R1,A
   \   00009E   74..         MOV     A,#TCLinkKeyFrmCntr & 0xff
   \   0000A0   28           ADD     A,R0
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   74..         MOV     A,#(TCLinkKeyFrmCntr >> 8) & 0xff
   \   0000A5   39           ADDC    A,R1
   \   0000A6   F583         MOV     DPH,A
   \   0000A8   12....       LCALL   ?XLOAD_R0123
   \   0000AB   E5..         MOV     A,?V0
   \   0000AD   2418         ADD     A,#0x18
   \   0000AF   F582         MOV     DPL,A
   \   0000B1   E4           CLR     A
   \   0000B2   35..         ADDC    A,?V1
   \   0000B4   F583         MOV     DPH,A
   \   0000B6   12....       LCALL   ?XSTORE_R0123
   3218                    pKeyData->rxFrmCntr = TCLinkKeyFrmCntr[i].rxFrmCntr;
   \   0000B9   EE           MOV     A,R6
   \   0000BA   F8           MOV     R0,A
   \   0000BB   EF           MOV     A,R7
   \   0000BC   F9           MOV     R1,A
   \   0000BD   E8           MOV     A,R0
   \   0000BE   75F009       MOV     B,#0x9
   \   0000C1   A4           MUL     AB
   \   0000C2   C8           XCH     A,R0
   \   0000C3   AAF0         MOV     R2,B
   \   0000C5   75F000       MOV     B,#0x0
   \   0000C8   A4           MUL     AB
   \   0000C9   2A           ADD     A,R2
   \   0000CA   FA           MOV     R2,A
   \   0000CB   75F009       MOV     B,#0x9
   \   0000CE   E9           MOV     A,R1
   \   0000CF   A4           MUL     AB
   \   0000D0   2A           ADD     A,R2
   \   0000D1   F9           MOV     R1,A
   \   0000D2   74..         MOV     A,#(TCLinkKeyFrmCntr + 4) & 0xff
   \   0000D4   28           ADD     A,R0
   \   0000D5   F582         MOV     DPL,A
   \   0000D7   74..         MOV     A,#((TCLinkKeyFrmCntr + 4) >> 8) & 0xff
   \   0000D9   39           ADDC    A,R1
   \   0000DA   F583         MOV     DPH,A
   \   0000DC   12....       LCALL   ?XLOAD_R0123
   \   0000DF   E5..         MOV     A,?V0
   \   0000E1   241C         ADD     A,#0x1c
   \   0000E3   F582         MOV     DPL,A
   \   0000E5   E4           CLR     A
   \   0000E6   35..         ADDC    A,?V1
   \   0000E8   F583         MOV     DPH,A
   \   0000EA   12....       LCALL   ?XSTORE_R0123
   3219          
   3220                    // Write the TC link key back to the NV
   3221                    osal_nv_write(ZCD_NV_TCLK_TABLE_START + i, 0,
   3222                                  sizeof(APSME_TCLinkKey_t), pKeyData);
   \   0000ED                ; Setup parameters for call to function osal_nv_write
   \   0000ED   78..         MOV     R0,#?V0
   \   0000EF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000F2   75..20       MOV     ?V2,#0x20
   \   0000F5   75..00       MOV     ?V3,#0x0
   \   0000F8   78..         MOV     R0,#?V2
   \   0000FA   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FD   7C00         MOV     R4,#0x0
   \   0000FF   7D00         MOV     R5,#0x0
   \   000101   EE           MOV     A,R6
   \   000102   2401         ADD     A,#0x1
   \   000104   FA           MOV     R2,A
   \   000105   EF           MOV     A,R7
   \   000106   3401         ADDC    A,#0x1
   \   000108   FB           MOV     R3,A
   \   000109   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00010C   7404         MOV     A,#0x4
   \   00010E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000111   E9           MOV     A,R1
   3223          
   3224                    // clear the pending write flag
   3225                    TCLinkKeyFrmCntr[i].pendingFlag = FALSE;
   \   000112   EE           MOV     A,R6
   \   000113   F8           MOV     R0,A
   \   000114   EF           MOV     A,R7
   \   000115   F9           MOV     R1,A
   \   000116   E8           MOV     A,R0
   \   000117   75F009       MOV     B,#0x9
   \   00011A   A4           MUL     AB
   \   00011B   C8           XCH     A,R0
   \   00011C   AAF0         MOV     R2,B
   \   00011E   75F000       MOV     B,#0x0
   \   000121   A4           MUL     AB
   \   000122   2A           ADD     A,R2
   \   000123   FA           MOV     R2,A
   \   000124   75F009       MOV     B,#0x9
   \   000127   E9           MOV     A,R1
   \   000128   A4           MUL     AB
   \   000129   2A           ADD     A,R2
   \   00012A   F9           MOV     R1,A
   \   00012B   74..         MOV     A,#(TCLinkKeyFrmCntr + 8) & 0xff
   \   00012D   28           ADD     A,R0
   \   00012E   F582         MOV     DPL,A
   \   000130   74..         MOV     A,#((TCLinkKeyFrmCntr + 8) >> 8) & 0xff
   \   000132   39           ADDC    A,R1
   \   000133   F583         MOV     DPH,A
   \   000135   7400         MOV     A,#0x0
   \   000137   F0           MOVX    @DPTR,A
   3226                  }
   3227                }
   3228              }
   \                     ??ZDSecMgrSaveTCLinkKey_3:
   \   000138   0E           INC     R6
   \   000139   EE           MOV     A,R6
   \   00013A   7001         JNZ     ??ZDSecMgrSaveTCLinkKey_4
   \   00013C   0F           INC     R7
   \                     ??ZDSecMgrSaveTCLinkKey_4:
   \   00013D   02....       LJMP    ??ZDSecMgrSaveTCLinkKey_1 & 0xFFFF
   3229                // clear copy of key in RAM
   3230              osal_memset( pKeyData, 0x00, sizeof(APSME_TCLinkKey_t) );
   \                     ??ZDSecMgrSaveTCLinkKey_2:
   \   000140                ; Setup parameters for call to function osal_memset
   \   000140   7C20         MOV     R4,#0x20
   \   000142   7D00         MOV     R5,#0x0
   \   000144   7900         MOV     R1,#0x0
   \   000146   AA..         MOV     R2,?V0
   \   000148   AB..         MOV     R3,?V1
   \   00014A   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3231          
   3232              osal_mem_free(pKeyData);
   \   00014D                ; Setup parameters for call to function osal_mem_free
   \   00014D   AA..         MOV     R2,?V0
   \   00014F   AB..         MOV     R3,?V1
   \   000151   12....       LCALL   `??osal_mem_free::?relay`; Banked call to: osal_mem_free
   3233            }
   3234          }
   \                     ??ZDSecMgrSaveTCLinkKey_0:
   \   000154   7F04         MOV     R7,#0x4
   \   000156   02....       LJMP    ?BANKED_LEAVE_XDATA
   3235          
   3236          /******************************************************************************
   3237           * @fn          ZDSecMgrUpdateTCAddress
   3238           *
   3239           * @brief       Update Trust Center address and save to NV.
   3240           *
   3241           * @param       extAddr - [in] extended address or NULL if no TC protected
   3242           *
   3243           * @return      none
   3244           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3245          void ZDSecMgrUpdateTCAddress( uint8 *extAddr )
   \                     ZDSecMgrUpdateTCAddress:
   3246          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   3247            uint8 noTCAddress[Z_EXTADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
   \   00000E   90....       MOV     DPTR,#`?<Constant {255, 255, 255, 255, 255, 255, 255,`
   \   000011   AC..         MOV     R4,?XSP + 0
   \   000013   AD..         MOV     R5,?XSP + 1
   \   000015   7408         MOV     A,#0x8
   \   000017   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   3248            APSME_SetRequest( apsTrustCenterAddress, 0, ( extAddr != NULL) ? extAddr : noTCAddress );
   \   00001A   EE           MOV     A,R6
   \   00001B   4F           ORL     A,R7
   \   00001C   6006         JZ      ??ZDSecMgrUpdateTCAddress_0
   \   00001E   EE           MOV     A,R6
   \   00001F   FC           MOV     R4,A
   \   000020   EF           MOV     A,R7
   \   000021   FD           MOV     R5,A
   \   000022   800C         SJMP    ??ZDSecMgrUpdateTCAddress_1
   \                     ??ZDSecMgrUpdateTCAddress_0:
   \   000024   A8..         MOV     R0,?XSP + 0
   \   000026   A9..         MOV     R1,?XSP + 1
   \   000028   88..         MOV     ?V0,R0
   \   00002A   89..         MOV     ?V1,R1
   \   00002C   AC..         MOV     R4,?V0
   \   00002E   AD..         MOV     R5,?V1
   \                     ??ZDSecMgrUpdateTCAddress_1:
   \   000030                ; Setup parameters for call to function APSME_SetRequest
   \   000030   7A00         MOV     R2,#0x0
   \   000032   7B00         MOV     R3,#0x0
   \   000034   79AB         MOV     R1,#-0x55
   \   000036   12....       LCALL   `??APSME_SetRequest::?relay`; Banked call to: APSME_SetRequest
   \   000039   E9           MOV     A,R1
   3249          #if defined ( NV_RESTORE )
   3250            osal_nv_write( ZCD_NV_TRUSTCENTER_ADDR, 0, Z_EXTADDR_LEN, zgApsTrustCenterAddr );
   \   00003A                ; Setup parameters for call to function osal_nv_write
   \   00003A   75....       MOV     ?V0,#zgApsTrustCenterAddr & 0xff
   \   00003D   75....       MOV     ?V1,#(zgApsTrustCenterAddr >> 8) & 0xff
   \   000040   78..         MOV     R0,#?V0
   \   000042   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000045   75..08       MOV     ?V0,#0x8
   \   000048   75..00       MOV     ?V1,#0x0
   \   00004B   78..         MOV     R0,#?V0
   \   00004D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000050   7C00         MOV     R4,#0x0
   \   000052   7D00         MOV     R5,#0x0
   \   000054   7A71         MOV     R2,#0x71
   \   000056   7B00         MOV     R3,#0x0
   \   000058   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00005B   7404         MOV     A,#0x4
   \   00005D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000060   E9           MOV     A,R1
   3251          #endif
   3252          }
   \   000061   7408         MOV     A,#0x8
   \   000063   12....       LCALL   ?DEALLOC_XSTACK8
   \   000066   7F02         MOV     R7,#0x2
   \   000068   02....       LJMP    ?BANKED_LEAVE_XDATA
   3253          
   3254          #if defined ( ZBA_FALLBACK_NWKKEY )
   3255          /******************************************************************************
   3256           * @fn          ZDSecMgrFallbackNwkKey
   3257           *
   3258           * @brief       Use the ZBA fallback network key.
   3259           *
   3260           * @param       none
   3261           *
   3262           * @return      none
   3263           */
   3264          void ZDSecMgrFallbackNwkKey( void )
   3265          {
   3266            if ( !_NIB.nwkKeyLoaded )
   3267            {
   3268              uint8 fallbackKey[SEC_KEY_LEN];
   3269          
   3270              ZDSecMgrReadKeyFromNv( ZCD_NV_PRECFGKEY, fallbackKey );
   3271              SSP_UpdateNwkKey( fallbackKey, 0);
   3272              SSP_SwitchNwkKey( 0 );
   3273          
   3274              // clear local copy of key
   3275              osal_memset( fallbackKey, 0x00, SEC_KEY_LEN );
   3276          
   3277              // handle next step in authentication process
   3278              ZDSecMgrAuthNwkKey();
   3279            }
   3280          }
   3281          #endif // defined ( ZBA_FALLBACK_NWKKEY )
   3282          
   3283          #if defined ( NV_RESTORE )
   3284          /******************************************************************************
   3285           * @fn          ZDSecMgrClearNVKeyValues
   3286           *
   3287           * @brief       If NV_RESTORE is enabled and the status of the network needs
   3288           *              default values this fuction clears ZCD_NV_NWKKEY,
   3289           *              ZCD_NV_NWK_ACTIVE_KEY_INFO and ZCD_NV_NWK_ALTERN_KEY_INFO link
   3290           *
   3291           * @param       none
   3292           *
   3293           * @return      none
   3294           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3295          void ZDSecMgrClearNVKeyValues(void)
   \                     ZDSecMgrClearNVKeyValues:
   3296          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 38
   \   000005   74DA         MOV     A,#-0x26
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3297            nwkActiveKeyItems keyItems;
   3298            nwkKeyDesc nwkKey;
   3299          
   3300            osal_memset(&keyItems, 0x00, sizeof(nwkActiveKeyItems));
   \   00000A                ; Setup parameters for call to function osal_memset
   \   00000A   7C15         MOV     R4,#0x15
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7900         MOV     R1,#0x0
   \   000010   7411         MOV     A,#0x11
   \   000012   12....       LCALL   ?XSTACK_DISP101_8
   \   000015   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3301          
   3302            osal_nv_write(ZCD_NV_NWKKEY, 0, sizeof(nwkActiveKeyItems), &keyItems);
   \   000018                ; Setup parameters for call to function osal_nv_write
   \   000018   7411         MOV     A,#0x11
   \   00001A   12....       LCALL   ?XSTACK_DISP100_8
   \   00001D   88..         MOV     ?V0,R0
   \   00001F   89..         MOV     ?V1,R1
   \   000021   78..         MOV     R0,#?V0
   \   000023   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000026   75..15       MOV     ?V0,#0x15
   \   000029   75..00       MOV     ?V1,#0x0
   \   00002C   78..         MOV     R0,#?V0
   \   00002E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000031   7C00         MOV     R4,#0x0
   \   000033   7D00         MOV     R5,#0x0
   \   000035   7A82         MOV     R2,#-0x7e
   \   000037   7B00         MOV     R3,#0x0
   \   000039   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000041   E9           MOV     A,R1
   3303          
   3304            // Initialize NV items for NWK Active and Alternate keys.
   3305            osal_memset( &nwkKey, 0x00, sizeof(nwkKeyDesc) );
   \   000042                ; Setup parameters for call to function osal_memset
   \   000042   7C11         MOV     R4,#0x11
   \   000044   7D00         MOV     R5,#0x0
   \   000046   7900         MOV     R1,#0x0
   \   000048   AA..         MOV     R2,?XSP + 0
   \   00004A   AB..         MOV     R3,?XSP + 1
   \   00004C   12....       LCALL   `??osal_memset::?relay`; Banked call to: osal_memset
   3306          
   3307            osal_nv_write(ZCD_NV_NWK_ACTIVE_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   \   00004F                ; Setup parameters for call to function osal_nv_write
   \   00004F   A8..         MOV     R0,?XSP + 0
   \   000051   A9..         MOV     R1,?XSP + 1
   \   000053   88..         MOV     ?V0,R0
   \   000055   89..         MOV     ?V1,R1
   \   000057   78..         MOV     R0,#?V0
   \   000059   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005C   75..11       MOV     ?V0,#0x11
   \   00005F   75..00       MOV     ?V1,#0x0
   \   000062   78..         MOV     R0,#?V0
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000067   7C00         MOV     R4,#0x0
   \   000069   7D00         MOV     R5,#0x0
   \   00006B   7A3A         MOV     R2,#0x3a
   \   00006D   7B00         MOV     R3,#0x0
   \   00006F   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   000072   7404         MOV     A,#0x4
   \   000074   12....       LCALL   ?DEALLOC_XSTACK8
   \   000077   E9           MOV     A,R1
   3308          
   3309            osal_nv_write(ZCD_NV_NWK_ALTERN_KEY_INFO, 0, sizeof(nwkKeyDesc), &nwkKey);
   \   000078                ; Setup parameters for call to function osal_nv_write
   \   000078   A8..         MOV     R0,?XSP + 0
   \   00007A   A9..         MOV     R1,?XSP + 1
   \   00007C   88..         MOV     ?V0,R0
   \   00007E   89..         MOV     ?V1,R1
   \   000080   78..         MOV     R0,#?V0
   \   000082   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000085   75..11       MOV     ?V0,#0x11
   \   000088   75..00       MOV     ?V1,#0x0
   \   00008B   78..         MOV     R0,#?V0
   \   00008D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000090   7C00         MOV     R4,#0x0
   \   000092   7D00         MOV     R5,#0x0
   \   000094   7A3B         MOV     R2,#0x3b
   \   000096   7B00         MOV     R3,#0x0
   \   000098   12....       LCALL   `??osal_nv_write::?relay`; Banked call to: osal_nv_write
   \   00009B   7404         MOV     A,#0x4
   \   00009D   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A0   E9           MOV     A,R1
   3310          }
   \   0000A1   7426         MOV     A,#0x26
   \   0000A3   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000A6   7F02         MOV     R7,#0x2
   \   0000A8   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrStore::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrExtAddrLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddrClear::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrClear

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookup::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMI::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExt::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupExtGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExtGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryLookupAMIGetIndex::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMIGetIndex

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryFree::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrEntryNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyReq::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSendNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemoveByExtAddr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemoveByExtAddr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidateRM::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceValidate::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoin::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinDirect::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceJoinFwd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrDeviceNew::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAssocDeviceAuth::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrConfig::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoining::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrPermitJoiningTimeout::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNewDeviceEvent::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCExtAddrCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTCDataLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrTransportKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRemoveDeviceInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchKeyInd::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSwitchNwkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRequestAppKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAppKeyTypeSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyTypeSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeySet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationSet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAuthenticationCheck::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_LinkKeyNVIdGet::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyNVIdGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsLinkKeyValid::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsLinkKeyValid

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_KeyFwdToChild::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAddLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrWriteNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrWriteNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrRestoreFromNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSetDefaultNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateNV::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrAPSRemove::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeySync::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeySync

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_TCLinkKeyLoad::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_TCLinkKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??APSME_IsDefaultTCLK::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_IsDefaultTCLK

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrNwkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNwkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrReadKeyFromNv::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrReadKeyFromNv

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrApsLinkKeyInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrApsLinkKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrInitNVKeyTables::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNVKeyTables

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveApsLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveApsLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrSaveTCLinkKey::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSaveTCLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrUpdateTCAddress::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateTCAddress

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??ZDSecMgrClearNVKeyValues::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrClearNVKeyValues

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {255, 255, 255, 255, 255, 255, 255,`:
   \   000000   FF           DB 255
   \   000001   FF           DB 255
   \   000002   FF           DB 255
   \   000003   FF           DB 255
   \   000004   FF           DB 255
   \   000005   FF           DB 255
   \   000006   FF           DB 255
   \   000007   FF           DB 255

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_3e9:
   \   000000   E9030000     DD 1001

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_b:
   \   000000   0B000000     DD 11

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_a:
   \   000000   0A000000     DD 10
   3311          #endif // defined ( NV_RESTORE )
   3312          
   3313          /******************************************************************************
   3314          ******************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     78   APSME_IsDefaultTCLK
        0      9   -> osal_isbufset
      0     37   APSME_IsLinkKeyValid
        0     33   -> APSME_LinkKeyNVIdGet
        0     33   -> osal_mem_alloc
        0     33   -> osal_mem_free
        0     36   -> osal_memcmp
        0     33   -> osal_memset
        0     37   -> osal_nv_read
      0      9   APSME_KeyFwdToChild
        0      9   -> AssocGetWithExt
        0      9   -> ZDSecMgrAssocDeviceAuth
      0     46   APSME_LinkKeyNVIdGet
        0     13   -> ZDSecMgrEntryLookupExt
      0     45   APSME_LinkKeySet
        0     25   -> ZDSecMgrEntryLookupExtGetIndex
        0     23   -> osal_mem_alloc
        0     23   -> osal_mem_free
        0     26   -> osal_memcpy
        0     23   -> osal_memset
        0     27   -> osal_nv_read
        0     27   -> osal_nv_write
      0     61   APSME_TCLinkKeyInit
        0     51   -> osal_memcpy
        0     48   -> osal_memset
        0     50   -> osal_nv_item_init
        0     52   -> osal_nv_read
        0     52   -> osal_nv_write
      0     73   APSME_TCLinkKeyLoad
        0     69   -> APSME_IsDefaultTCLK
        0     69   -> APSME_IsDistributedSecurity
        0     69   -> AddrMgrEntryLookupNwk
        0     69   -> AddrMgrEntryRelease
        0     69   -> AddrMgrExtAddrEqual
        0     69   -> AddrMgrExtAddrValid
        0     69   -> osal_memset
        0     73   -> osal_nv_read
        0     69   -> osal_set_event
      0     58   APSME_TCLinkKeySync
        0     54   -> APSME_IsDefaultTCLK
        0     54   -> APSME_LookupExtAddr
        0     54   -> AddrMgrExtAddrEqual
        0     54   -> AddrMgrExtAddrValid
        0     54   -> osal_memset
        0     58   -> osal_nv_read
        0     54   -> sAddrExtCmp
      0     22   ZDSecMgrAPSRemove
        0     20   -> ZDSecMgrDeviceRemove
      0     22   ZDSecMgrAddLinkKey
        0     18   -> APSME_LinkKeySet
        0     20   -> ZDSecMgrAddrStore
        0     18   -> ZDSecMgrEntryLookupAMI
        0     18   -> ZDSecMgrEntryNew
        0     18   -> ZDSecMgrWriteNV
      0     59   ZDSecMgrAddrClear
        0     24   -> AddrMgrEntryRelease
        0     24   -> ZDSecMgrExtAddrLookup
      0     57   ZDSecMgrAddrStore
        0     26   -> AddrMgrEntryUpdate
        0     26   -> AddrMgrExtAddrSet
      1     71   ZDSecMgrAppKeyGet
        0     14   -> SSP_GetTrueRand
      0     66   ZDSecMgrAppKeyReq
        0     49   -> APSME_LookupExtAddr
        0     49   -> APSME_LookupNwkAddr
        0     49   -> APSME_TransportKeyReq
        0     57   -> ZDSecMgrAppKeyGet
        0     49   -> osal_memset
      2      0   ZDSecMgrAppKeyTypeSet
      0     45   ZDSecMgrApsLinkKeyInit
        0     34   -> osal_memset
        0     36   -> osal_nv_item_init
      2     35   ZDSecMgrAssocDeviceAuth
      2     25   ZDSecMgrAuthNwkKey
        2      0   -> osal_set_event
      0      0   ZDSecMgrAuthenticationCheck
      1     12   ZDSecMgrAuthenticationSet
        0     12   -> ZDSecMgrEntryLookupExt
      0     52   ZDSecMgrClearNVKeyValues
        0     48   -> osal_memset
        0     52   -> osal_nv_write
      2      9   ZDSecMgrConfig
        2      0   -> APSME_SecurityRM_CD
        2      0   -> SSP_Init
      0     49   ZDSecMgrDeviceJoin
        0     29   -> ZDSecMgrAddrClear
        0     31   -> ZDSecMgrAddrStore
        0     29   -> ZDSecMgrDeviceRemove
        0     29   -> ZDSecMgrDeviceValidate
        0     29   -> ZDSecMgrSendNwkKey
        0     32   -> osal_memcpy
      0     18   ZDSecMgrDeviceJoinDirect
        0      9   -> AssocGetWithShort
        0      9   -> ZDSecMgrAssocDeviceAuth
        0      9   -> ZDSecMgrDeviceJoin
      0     20   ZDSecMgrDeviceJoinFwd
        0     20   -> APSME_UpdateDeviceReq
        0     20   -> AssocGetWithShort
        0     20   -> ZDSecMgrAssocDeviceAuth
      0     44   ZDSecMgrDeviceNew
        0      9   -> ZDSecMgrDeviceJoinDirect
      0     51   ZDSecMgrDeviceRemove
        0     22   -> APSME_RemoveDeviceReq
        0     22   -> AssocGetWithExt
        0     22   -> NLME_GetShortAddr
        0     22   -> NLME_LeaveReq
      0     11   ZDSecMgrDeviceRemoveByExtAddr
        0     11   -> ZDSecMgrEntryFree
        0     11   -> ZDSecMgrEntryLookupExt
      0     38   ZDSecMgrDeviceValidate
        0      9   -> ZDSecMgrDeviceValidateRM
      2      9   ZDSecMgrDeviceValidateRM
      0     31   ZDSecMgrEntryFree
        0     16   -> ZDSecMgrEntryLookupAMIGetIndex
        0     16   -> ZDSecMgrUpdateNV
        0     16   -> osal_mem_alloc
        0     16   -> osal_mem_free
        0     16   -> osal_memset
        0     20   -> osal_nv_write
      0      9   ZDSecMgrEntryInit
        0      9   -> ZDSecMgrRestoreFromNV
        0      9   -> osal_mem_alloc
      0     25   ZDSecMgrEntryLookup
        0     25   -> AddrMgrEntryLookupNwk
      0     27   ZDSecMgrEntryLookupAMI
      0     25   ZDSecMgrEntryLookupAMIGetIndex
      0     26   ZDSecMgrEntryLookupExt
        0     13   -> ZDSecMgrEntryLookupAMI
        0     13   -> ZDSecMgrExtAddrLookup
      0     41   ZDSecMgrEntryLookupExtGetIndex
        0     16   -> ZDSecMgrExtAddrLookup
      0     27   ZDSecMgrEntryNew
      0     48   ZDSecMgrExtAddrLookup
        0     24   -> AddrMgrEntryLookupExt
        0     24   -> AddrMgrExtAddrSet
      0     28   ZDSecMgrExtAddrStore
        0     26   -> AddrMgrEntryUpdate
        0     26   -> AddrMgrExtAddrSet
      0      9   ZDSecMgrInit
        0      9   -> ZDSecMgrConfig
      0     16   ZDSecMgrInitNV
        0     14   -> osal_nv_item_init
        0     16   -> osal_nv_write
      0      9   ZDSecMgrInitNVKeyTables
        0      9   -> APSME_TCLinkKeyInit
        0      9   -> ZDSecMgrApsLinkKeyInit
        0      9   -> ZDSecMgrNwkKeyInit
      1     35   ZDSecMgrNewDeviceEvent
        0     35   -> AddrMgrEntryGet
        0     35   -> AssocGetWithShort
        0     35   -> AssocRemove
        0     35   -> NLME_GetShortAddr
        0     35   -> ZDSecMgrAddrClear
        0     35   -> ZDSecMgrAssocDeviceAuth
        0     35   -> ZDSecMgrDeviceNew
      0     61   ZDSecMgrNwkKeyInit
        0     48   -> osal_memset
        0     50   -> osal_nv_item_init
        0     52   -> osal_nv_write
      2      0   ZDSecMgrPermitJoining
      2      0   ZDSecMgrPermitJoiningTimeout
      0     41   ZDSecMgrReadKeyFromNv
        0     16   -> osal_nv_read
      0     17   ZDSecMgrRemoveDeviceInd
        0     17   -> APSME_LookupNwkAddr
        0     17   -> NLME_GetShortAddr
        0     17   -> ZDSecMgrDeviceRemove
      0     13   ZDSecMgrRequestAppKey
        0     13   -> APSME_RequestKeyReq
      0      9   ZDSecMgrRequestKeyInd
        0      9   -> ZDSecMgrAppKeyReq
      0     31   ZDSecMgrRestoreFromNV
        0     18   -> osal_mem_alloc
        0     18   -> osal_mem_free
        0     18   -> osal_memset
        0     22   -> osal_nv_read
        0     22   -> osal_nv_write
      0     16   ZDSecMgrSaveApsLinkKey
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free
        0     12   -> osal_memset
        0     16   -> osal_nv_read
        0     16   -> osal_nv_write
      0     16   ZDSecMgrSaveTCLinkKey
        0     12   -> osal_mem_alloc
        0     12   -> osal_mem_free
        0     12   -> osal_memset
        0     16   -> osal_nv_read
        0     16   -> osal_nv_write
      1     75   ZDSecMgrSendNwkKey
        0     42   -> APSME_TransportKeyReq
        0     42   -> NLME_GetShortAddr
        0     46   -> NLME_ReadNwkKeyInfo
        0     42   -> osal_memset
      0     23   ZDSecMgrSetDefaultNV
        0     19   -> osal_mem_alloc
        0     19   -> osal_mem_free
        0     19   -> osal_memset
        0     23   -> osal_nv_write
      0      9   ZDSecMgrSwitchKeyInd
        0      9   -> SSP_SwitchNwkKey
        0      9   -> ZDApp_NVUpdate
      1     14   ZDSecMgrSwitchNwkKey
        0     14   -> APSME_SwitchKeyReq
        0     14   -> SSP_SwitchNwkKey
        0     14   -> ZDApp_NVUpdate
      0     52   ZDSecMgrTCDataLoad
        0     25   -> APSME_IsDistributedSecurity
        0     25   -> AddrMgrEntryLookupExt
        0     27   -> ZDSecMgrAddrStore
        0     25   -> sAddrExtCpy
      0     17   ZDSecMgrTCExtAddrCheck
        0     17   -> APSME_GetRequest
        0     17   -> sAddrExtCmp
      0     25   ZDSecMgrTransportKeyInd
        0     25   -> SSP_SwitchNwkKey
        0     25   -> SSP_UpdateNwkKey
        0     25   -> ZDSecMgrAuthNwkKey
        0     25   -> ZDSecMgrReadKeyFromNv
        0     25   -> ZDSecMgrTCDataLoad
        0     25   -> ZDSecMgrUpdateTCAddress
        0     25   -> osal_isbufset
        0     25   -> osal_memset
      0     17   ZDSecMgrUpdateDeviceInd
        0     17   -> ZDSecMgrDeviceJoin
      0     32   ZDSecMgrUpdateNV
        0     16   -> osal_nv_read
        0     16   -> osal_nv_write
      1     25   ZDSecMgrUpdateNwkKey
        0     25   -> APSME_TransportKeyReq
        0     25   -> SSP_UpdateNwkKey
        0     25   -> ZDApp_NVUpdate
      0     47   ZDSecMgrUpdateTCAddress
        0     18   -> APSME_SetRequest
        0     22   -> osal_nv_write
      0     34   ZDSecMgrWriteNV
        0     16   -> osal_nv_write


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant {255, 255, 255, 255, 255, 255, 255,
       1  ?<Initializer for ZDSecMgrAppKeyType>
      25  APSME_IsDefaultTCLK
       6  APSME_IsDefaultTCLK::?relay
     204  APSME_IsLinkKeyValid
       6  APSME_IsLinkKeyValid::?relay
      76  APSME_KeyFwdToChild
       6  APSME_KeyFwdToChild::?relay
      95  APSME_LinkKeyNVIdGet
       6  APSME_LinkKeyNVIdGet::?relay
     488  APSME_LinkKeySet
       6  APSME_LinkKeySet::?relay
     412  APSME_TCLinkKeyInit
       6  APSME_TCLinkKeyInit::?relay
     446  APSME_TCLinkKeyLoad
       6  APSME_TCLinkKeyLoad::?relay
     450  APSME_TCLinkKeySync
       6  APSME_TCLinkKeySync::?relay
      27  ApsLinkKeyFrmCntr
       9  TCLinkKeyFrmCntr
      32  TrustCenterLinkKey
     116  ZDSecMgrAPSRemove
       6  ZDSecMgrAPSRemove::?relay
     172  ZDSecMgrAddLinkKey
       6  ZDSecMgrAddLinkKey::?relay
      89  ZDSecMgrAddrClear
       6  ZDSecMgrAddrClear::?relay
     141  ZDSecMgrAddrStore
       6  ZDSecMgrAddrStore::?relay
      79  ZDSecMgrAppKeyGet
       6  ZDSecMgrAppKeyGet::?relay
     322  ZDSecMgrAppKeyReq
       6  ZDSecMgrAppKeyReq::?relay
       1  ZDSecMgrAppKeyType
      34  ZDSecMgrAppKeyTypeSet
       6  ZDSecMgrAppKeyTypeSet::?relay
      83  ZDSecMgrApsLinkKeyInit
       6  ZDSecMgrApsLinkKeyInit::?relay
      28  ZDSecMgrAssocDeviceAuth
       6  ZDSecMgrAssocDeviceAuth::?relay
      32  ZDSecMgrAuthNwkKey
       6  ZDSecMgrAuthNwkKey::?relay
       5  ZDSecMgrAuthenticationCheck
       6  ZDSecMgrAuthenticationCheck::?relay
      71  ZDSecMgrAuthenticationSet
       6  ZDSecMgrAuthenticationSet::?relay
     171  ZDSecMgrClearNVKeyValues
       6  ZDSecMgrClearNVKeyValues::?relay
      17  ZDSecMgrConfig
       6  ZDSecMgrConfig::?relay
     284  ZDSecMgrDeviceJoin
       6  ZDSecMgrDeviceJoin::?relay
      45  ZDSecMgrDeviceJoinDirect
       6  ZDSecMgrDeviceJoinDirect::?relay
     259  ZDSecMgrDeviceJoinFwd
       6  ZDSecMgrDeviceJoinFwd::?relay
      26  ZDSecMgrDeviceNew
       6  ZDSecMgrDeviceNew::?relay
     312  ZDSecMgrDeviceRemove
       6  ZDSecMgrDeviceRemove::?relay
      58  ZDSecMgrDeviceRemoveByExtAddr
       6  ZDSecMgrDeviceRemoveByExtAddr::?relay
      39  ZDSecMgrDeviceValidate
       6  ZDSecMgrDeviceValidate::?relay
      21  ZDSecMgrDeviceValidateRM
       6  ZDSecMgrDeviceValidateRM::?relay
       2  ZDSecMgrEntries
     185  ZDSecMgrEntryFree
       6  ZDSecMgrEntryFree::?relay
     173  ZDSecMgrEntryInit
       6  ZDSecMgrEntryInit::?relay
     218  ZDSecMgrEntryLookup
       6  ZDSecMgrEntryLookup::?relay
     164  ZDSecMgrEntryLookupAMI
       6  ZDSecMgrEntryLookupAMI::?relay
     110  ZDSecMgrEntryLookupAMIGetIndex
       6  ZDSecMgrEntryLookupAMIGetIndex::?relay
      79  ZDSecMgrEntryLookupExt
       6  ZDSecMgrEntryLookupExt::?relay
     224  ZDSecMgrEntryLookupExtGetIndex
       6  ZDSecMgrEntryLookupExtGetIndex::?relay
     208  ZDSecMgrEntryNew
       6  ZDSecMgrEntryNew::?relay
     117  ZDSecMgrExtAddrLookup
       6  ZDSecMgrExtAddrLookup::?relay
     141  ZDSecMgrExtAddrStore
       6  ZDSecMgrExtAddrStore::?relay
      27  ZDSecMgrInit
       6  ZDSecMgrInit::?relay
     138  ZDSecMgrInitNV
       6  ZDSecMgrInitNV::?relay
      25  ZDSecMgrInitNVKeyTables
       6  ZDSecMgrInitNVKeyTables::?relay
     268  ZDSecMgrNewDeviceEvent
       6  ZDSecMgrNewDeviceEvent::?relay
     291  ZDSecMgrNwkKeyInit
       6  ZDSecMgrNwkKeyInit::?relay
      49  ZDSecMgrPermitJoining
       6  ZDSecMgrPermitJoining::?relay
       1  ZDSecMgrPermitJoiningEnabled
       1  ZDSecMgrPermitJoiningTimed
      31  ZDSecMgrPermitJoiningTimeout
       6  ZDSecMgrPermitJoiningTimeout::?relay
     223  ZDSecMgrReadKeyFromNv
       6  ZDSecMgrReadKeyFromNv::?relay
      95  ZDSecMgrRemoveDeviceInd
       6  ZDSecMgrRemoveDeviceInd::?relay
      63  ZDSecMgrRequestAppKey
       6  ZDSecMgrRequestAppKey::?relay
      47  ZDSecMgrRequestKeyInd
       6  ZDSecMgrRequestKeyInd::?relay
     728  ZDSecMgrRestoreFromNV
       6  ZDSecMgrRestoreFromNV::?relay
     355  ZDSecMgrSaveApsLinkKey
       6  ZDSecMgrSaveApsLinkKey::?relay
     345  ZDSecMgrSaveTCLinkKey
       6  ZDSecMgrSaveTCLinkKey::?relay
     336  ZDSecMgrSendNwkKey
       6  ZDSecMgrSendNwkKey::?relay
     284  ZDSecMgrSetDefaultNV
       6  ZDSecMgrSetDefaultNV::?relay
      30  ZDSecMgrSwitchKeyInd
       6  ZDSecMgrSwitchKeyInd::?relay
      77  ZDSecMgrSwitchNwkKey
       6  ZDSecMgrSwitchNwkKey::?relay
       1  ZDSecMgrTCAuthenticated
      97  ZDSecMgrTCDataLoad
       6  ZDSecMgrTCDataLoad::?relay
       8  ZDSecMgrTCExtAddr
      49  ZDSecMgrTCExtAddrCheck
       6  ZDSecMgrTCExtAddrCheck::?relay
     254  ZDSecMgrTransportKeyInd
       6  ZDSecMgrTransportKeyInd::?relay
     163  ZDSecMgrUpdateDeviceInd
       6  ZDSecMgrUpdateDeviceInd::?relay
     317  ZDSecMgrUpdateNV
       6  ZDSecMgrUpdateNV::?relay
     137  ZDSecMgrUpdateNwkKey
       6  ZDSecMgrUpdateNwkKey::?relay
     107  ZDSecMgrUpdateTCAddress
       6  ZDSecMgrUpdateTCAddress::?relay
     275  ZDSecMgrWriteNV
       6  ZDSecMgrWriteNV::?relay
       4  __Constant_1
       4  __Constant_3e9
       4  __Constant_a
       4  __Constant_b

 
 11 030 bytes in segment BANKED_CODE
    396 bytes in segment BANK_RELAYS
      1 byte  in segment XDATA_I
      1 byte  in segment XDATA_ID
     24 bytes in segment XDATA_ROM_C
     81 bytes in segment XDATA_Z
 
 11 427 bytes of CODE  memory
      8 bytes of CONST memory (+ 16 bytes shared)
     82 bytes of XDATA memory

Errors: none
Warnings: none
