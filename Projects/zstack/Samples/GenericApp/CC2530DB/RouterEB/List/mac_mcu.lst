###############################################################################
#
# IAR C/C++ Compiler V9.30.1.3056 for 8051                21/Apr/2017  17:48:42
# Copyright 2004-2015 IAR Systems AB.
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf04\single_chip\mac_mcu.c
#    Command line       =  
#        -f "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x04000000 -DZDAPP_CONFIG_PAN_ID=0x0085
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=5
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -DCHANNEL_CNT=0x01 "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Components\mac\low_level\srf04\single_chip\mac_mcu.c" -D
#        ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -D xNV_RESTORE -D NV_INIT -D OPEN_FCS -D
#        PANID_INCREASE -lC "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB\List" -lA
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB\Obj" -e
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        --core=plain --dptr=16,1 --data_model=large --code_model=banked
#        --calling_convention=xdata_reentrant --place_constants=data_rom
#        --nr_virtual_regs 16 -I "C:\Texas Instruments\Z-Stack Mesh
#        1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh
#        1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\" -I "C:\Texas
#        Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\Source\" -I
#        "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\Application\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack
#        Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -On --require_prototypes
#    List file          =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB\List\mac_mcu.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh
#        1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh
#        1.0.0\Projects\zstack\Samples\GenericApp\CC2530DB\RouterEB\Obj\mac_mcu.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack Mesh 1.0.0_chaokw_20160317\Z-Stack Mesh 1.0.0_chaokw_20160316\Z-Stack Mesh 1.0.0_LCDOK\Z-Stack Mesh 1.0.0\Components\mac\low_level\srf04\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2014-07-11 13:41:40 -0700 (Fri, 11 Jul 2014) $
      4            Revision:       $Revision: 39397 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2014 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_defs.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x94
   \   unsigned char volatile __sfr T2CTRL
   \                     T2CTRL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9e
   \   unsigned char volatile __sfr CLKCONSTA
   \                     CLKCONSTA:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2MOVF1
   \                     T2MOVF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa6
   \   unsigned char volatile __sfr T2MOVF2
   \                     T2MOVF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2IRQM
   \                     T2IRQM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa9
   \   unsigned char volatile __sfr IP0
   \                     IP0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb9
   \   unsigned char volatile __sfr IP1
   \                     IP1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbc
   \   unsigned char volatile __sfr RNDL
   \                     RNDL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr RNDH
   \                     RNDH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbf
   \   unsigned char volatile __sfr RFERRF
   \                     RFERRF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2MSEL
   \                     T2MSEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIRQF0
   \                     RFIRQF0:
   \   000000                DS 1
     48          
     49          /* low-level specific */
     50          #include "mac_rx.h"
     51          #include "mac_tx.h"
     52          #include "mac_backoff_timer.h"
     53          #include "mac_csp_tx.h"
     54          #include "mac_rx_onoff.h"
     55          #include "mac_low_level.h"
     56          
     57          /* target specific */
     58          #include "mac_mcu.h"
     59          #include "mac_radio_defs.h"
     60          
     61          /* debug */
     62          #include "mac_assert.h"
     63          
     64          /* high level */
     65          #include "mac_pib.h"
     66          
     67          /* ------------------------------------------------------------------------------------------------
     68           *                                           Defines
     69           * ------------------------------------------------------------------------------------------------
     70           */
     71          
     72          /* for optimized indexing of uint32's */
     73          #if HAL_MCU_LITTLE_ENDIAN()
     74          #define UINT32_NDX0   0
     75          #define UINT32_NDX1   1
     76          #define UINT32_NDX2   2
     77          #define UINT32_NDX3   3
     78          #else
     79          #define UINT32_NDX0   3
     80          #define UINT32_NDX1   2
     81          #define UINT32_NDX2   1
     82          #define UINT32_NDX3   0
     83          #endif
     84          
     85          /* ------------------------------------------------------------------------------------------------
     86           *                                        Local Variables
     87           * ------------------------------------------------------------------------------------------------
     88           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     89          uint8       macChipVersion = 0;
   \                     macChipVersion:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     90          static int8 maxRssi;
   \                     maxRssi:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     91          static uint32 prevAccumulatedOverflowCount = 0;
   \                     prevAccumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     92          static bool updateRolloverflag = FALSE;
   \                     updateRolloverflag:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          static uint32 prevoverflowCount = 0;
   \                     prevoverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
     94          
     95          
     96          /*
     97           *  This number is used to calculate the precision count for OSAL timer update. In Beacon mode,
     98           *  the overflow count may be initialized to zero or to a constant. The "skip" in overflow count
     99           *  needs to be accounted for in this variable.
    100           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    101          static uint32 accumulatedOverflowCount = 0;
   \                     accumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    102          
    103          /* Function pointer for the random seed callback */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    104          static macRNGFcn_t pRandomSeedCB = NULL;
   \                     pRandomSeedCB:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    105          /* ------------------------------------------------------------------------------------------------
    106           *                                       Local Prototypes
    107           * ------------------------------------------------------------------------------------------------
    108           */
    109          static void mcuRecordMaxRssiIsr(void);
    110          static uint32 macMcuOverflowGetCompare(void);
    111          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn);
    112          
    113          /**************************************************************************************************
    114           * @fn          MAC_SetRandomSeedCB
    115           *
    116           * @brief       Set the function pointer for the random seed callback.
    117           *
    118           * @param       pCBFcn - function pointer of the random seed callback
    119           *
    120           * @return      none
    121           **************************************************************************************************
    122           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    123          void MAC_SetRandomSeedCB(macRNGFcn_t pCBFcn)
   \                     MAC_SetRandomSeedCB:
    124          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    125            pRandomSeedCB = pCBFcn;
   \   000004   90....       MOV     DPTR,#pRandomSeedCB
   \   000007   EA           MOV     A,R2
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   EB           MOV     A,R3
   \   00000B   F0           MOVX    @DPTR,A
    126          }
   \   00000C   D083         POP     DPH
   \   00000E   D082         POP     DPL
   \   000010   02....       LJMP    ?BRET
    127          
    128          /**************************************************************************************************
    129           * @fn          macMcuInit
    130           *
    131           * @brief       Initialize the MCU.
    132           *
    133           * @param       none
    134           *
    135           * @return      none
    136           **************************************************************************************************
    137           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    138          MAC_INTERNAL_API void macMcuInit(void)
   \                     macMcuInit:
    139          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    140            halIntState_t  s;
    141          
    142            /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
    143             * too many false frames are received if the reset value is used. Make it more likely to detect
    144             * sync by removing the requirement that both symbols in the SFD must have a correlation value
    145             * above the correlation threshold, and make sync word detection less likely by raising the
    146             * correlation threshold.
    147             */
    148            MDMCTRL1 = CORR_THR;
   \   000005   9061A9       MOV     DPTR,#0x61a9
   \   000008   7414         MOV     A,#0x14
   \   00000A   F0           MOVX    @DPTR,A
    149          
    150          #ifdef FEATURE_CC253X_LOW_POWER_RX
    151            /* Reduce RX power consumption current to 20mA at the cost of some sensitivity
    152             * Note: This feature can be applied to CC2530 and CC2533 only.
    153             */
    154            RXCTRL = 0x00;
    155            FSCTRL = 0x50;
    156          #else
    157            /* tuning adjustments for optimal radio performance; details available in datasheet */
    158            RXCTRL = 0x3F;
   \   00000B   9061AB       MOV     DPTR,#0x61ab
   \   00000E   743F         MOV     A,#0x3f
   \   000010   F0           MOVX    @DPTR,A
    159            
    160            /* Adjust current in synthesizer; details available in datasheet. */
    161            FSCTRL = 0x55;
   \   000011   9061AC       MOV     DPTR,#0x61ac
   \   000014   7455         MOV     A,#0x55
   \   000016   F0           MOVX    @DPTR,A
    162          #endif /* #ifdef FEATURE_CC253X_LOW_POWER_RX */ 
    163          
    164          #if !(defined HAL_PA_LNA || defined HAL_PA_LNA_CC2590 || \
    165                defined HAL_PA_LNA_SE2431L || defined HAL_PA_LNA_CC2592)
    166            /* Raises the CCA threshold from about -108 dBm to about -80 dBm input level.
    167             */
    168            CCACTRL0 = CCA_THR;
   \   000017   906196       MOV     DPTR,#0x6196
   \   00001A   74FC         MOV     A,#-0x4
   \   00001C   F0           MOVX    @DPTR,A
    169          #endif
    170          
    171            /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
    172             * details available in datasheet.
    173             */
    174            MDMCTRL0 = 0x85;
   \   00001D   9061A8       MOV     DPTR,#0x61a8
   \   000020   7485         MOV     A,#-0x7b
   \   000022   F0           MOVX    @DPTR,A
    175          
    176            /* In order to make a single library build, CC2533 specific accesses need to
    177             * be detected by reading the Chip ID
    178             */
    179            if ((*(uint8 *)(P_INFOPAGE+0x03) == 0x95) || (*(uint8 *)(P_INFOPAGE+0x03) == 0x34))
   \   000023   907803       MOV     DPTR,#0x7803
   \   000026   E0           MOVX    A,@DPTR
   \   000027   6495         XRL     A,#0x95
   \   000029   6008         JZ      ??macMcuInit_0
   \   00002B   907803       MOV     DPTR,#0x7803
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6434         XRL     A,#0x34
   \   000031   700C         JNZ     ??macMcuInit_1
    180            {
    181              /* In case the device is a 2533, just update the IVCTRL regoster which is 2533 specific */
    182              #define IVCTRL          XREG( 0x6265 )
    183              IVCTRL = 0xF;
   \                     ??macMcuInit_0:
   \   000033   906265       MOV     DPTR,#0x6265
   \   000036   740F         MOV     A,#0xf
   \   000038   F0           MOVX    @DPTR,A
    184              CCACTRL0 = CCA_THR_CC2533; 
   \   000039   906196       MOV     DPTR,#0x6196
   \   00003C   74F8         MOV     A,#-0x8
   \   00003E   F0           MOVX    @DPTR,A
    185            }
    186          
    187            /* Adjust current in VCO; details available in datasheet. */
    188          #ifdef FEATURE_VCO_ALTERNATE_SETTING
    189            FSCAL1 = 0x80;
    190          #else
    191            FSCAL1 = 0x00;
   \                     ??macMcuInit_1:
   \   00003F   9061AE       MOV     DPTR,#0x61ae
   \   000042   7400         MOV     A,#0x0
   \   000044   F0           MOVX    @DPTR,A
    192          #endif
    193          
    194            /* Adjust target value for AGC control loop; details available in datasheet. */
    195            AGCCTRL1 = 0x15;
   \   000045   9061B2       MOV     DPTR,#0x61b2
   \   000048   7415         MOV     A,#0x15
   \   00004A   F0           MOVX    @DPTR,A
    196          
    197            /* Disable source address matching an autopend for now */
    198            SRCMATCH = 0;
   \   00004B   906182       MOV     DPTR,#0x6182
   \   00004E   7400         MOV     A,#0x0
   \   000050   F0           MOVX    @DPTR,A
    199          
    200            /* Tune ADC performance, details available in datasheet. */
    201            ADCTEST0 = 0x10;
   \   000051   9061B5       MOV     DPTR,#0x61b5
   \   000054   7410         MOV     A,#0x10
   \   000056   F0           MOVX    @DPTR,A
    202            ADCTEST1 = 0x0E;
   \   000057   9061B6       MOV     DPTR,#0x61b6
   \   00005A   740E         MOV     A,#0xe
   \   00005C   F0           MOVX    @DPTR,A
    203            ADCTEST2 = 0x03;
   \   00005D   9061B7       MOV     DPTR,#0x61b7
   \   000060   7403         MOV     A,#0x3
   \   000062   F0           MOVX    @DPTR,A
    204          
    205            /* Sets TX anti-aliasing filter to appropriate bandwidth.
    206             * Reduces spurious emissions close to signal.
    207             */
    208            TXFILTCFG = TXFILTCFG_RESET_VALUE;
   \   000063   9061FA       MOV     DPTR,#0x61fa
   \   000066   7409         MOV     A,#0x9
   \   000068   F0           MOVX    @DPTR,A
    209          
    210            /* disable the CSPT register compare function */
    211            CSPT = 0xFF;
   \   000069   9061E5       MOV     DPTR,#0x61e5
   \   00006C   74FF         MOV     A,#-0x1
   \   00006E   F0           MOVX    @DPTR,A
    212          
    213            /* enable general RF interrupts */
    214            IEN2 |= RFIE;
   \   00006F   439A01       ORL     0x9a,#0x1
    215          
    216            /* enable general REERR interrupts */
    217            IEN0 |= RFERRIE;
   \   000072   D2A8         SETB    0xa8.0
    218          
    219            /* set RF interrupts one notch above lowest priority (four levels available) */
    220            IP0 |=  IP_RFERR_RF_DMA_BV;
   \   000074   43A901       ORL     0xa9,#0x1
    221            IP1 &= ~IP_RFERR_RF_DMA_BV;
   \   000077   53B9FE       ANL     0xb9,#0xfe
    222          
    223            /* set T2 interrupts one notch above lowest priority (four levels available)
    224             * This effectively turned off nested interrupt between T2 and RF.
    225             */
    226            IP0 |=  IP_RXTX0_T2_BV;
   \   00007A   43A904       ORL     0xa9,#0x4
    227            IP1 &= ~IP_RXTX0_T2_BV;
   \   00007D   53B9FB       ANL     0xb9,#0xfb
    228          
    229            /* read chip version */
    230            macChipVersion = CHVER;
   \   000080   906249       MOV     DPTR,#0x6249
   \   000083   E0           MOVX    A,@DPTR
   \   000084   90....       MOV     DPTR,#macChipVersion
   \   000087   F0           MOVX    @DPTR,A
    231          
    232            /*-------------------------------------------------------------------------------
    233             *  Initialize MAC timer.
    234             */
    235          
    236            /* set timer rollover */
    237            HAL_ENTER_CRITICAL_SECTION(s);
   \   000088   A2AF         MOV     C,0xa8.7
   \   00008A   E4           CLR     A
   \   00008B   33           RLC     A
   \   00008C   FE           MOV     R6,A
   \   00008D   C2AF         CLR     0xa8.7
    238            MAC_MCU_T2_ACCESS_PERIOD_VALUE();
   \   00008F   75C302       MOV     0xc3,#0x2
    239            T2M0 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
   \   000092   75A200       MOV     0xa2,#0x0
    240            T2M1 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
   \   000095   75A328       MOV     0xa3,#0x28
    241            HAL_EXIT_CRITICAL_SECTION(s);
   \   000098   EE           MOV     A,R6
   \   000099   FF           MOV     R7,A
   \   00009A   EE           MOV     A,R6
   \   00009B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00009D   92AF         MOV     0xa8.7,C
    242          
    243            /* start timer */
    244            MAC_RADIO_TIMER_WAKE_UP();
   \                     ??macMcuInit_2:
   \   00009F   E59E         MOV     A,0x9e
   \   0000A1   70FC         JNZ     ??macMcuInit_2
   \   0000A3   439403       ORL     0x94,#0x3
   \                     ??macMcuInit_3:
   \   0000A6   E594         MOV     A,0x94
   \   0000A8   A2E2         MOV     C,0xE0 /* A   */.2
   \   0000AA   50FA         JNC     ??macMcuInit_3
    245          
    246            /* Enable latch mode and T2 SYNC start. OSAL timer is based on MAC timer.
    247             * The SYNC start msut be on when POWER_SAVING is on for this design to work.
    248             */
    249            T2CTRL |= (LATCH_MODE | TIMER2_SYNC);
   \   0000AC   43940A       ORL     0x94,#0xa
    250          
    251            /* enable timer interrupts */
    252            T2IE = 1;
   \   0000AF   D2BA         SETB    0xb8.2
    253          
    254           /*----------------------------------------------------------------------------------------------
    255            *  Initialize random seed value.
    256            */
    257          
    258            /*
    259             *  Set radio for infinite reception.  Once radio reaches this state,
    260             *  it will stay in receive mode regardless RF activity.
    261             */
    262            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
   \   0000B1   906189       MOV     DPTR,#0x6189
   \   0000B4   7448         MOV     A,#0x48
   \   0000B6   F0           MOVX    @DPTR,A
    263          
    264            /* turn on the receiver */
    265            macRxOn();
   \   0000B7                ; Setup parameters for call to function macRxOn
   \   0000B7   12....       LCALL   `??macRxOn::?relay`  ; Banked call to: macRxOn
    266          
    267            /*
    268             *  Wait for radio to reach infinite reception state by checking RSSI valid flag.
    269             *  Once it does, the least significant bit of ADTSTH should be pretty random.
    270             */
    271            while (!(RSSISTAT & 0x01));
   \                     ??macMcuInit_4:
   \   0000BA   906199       MOV     DPTR,#0x6199
   \   0000BD   E0           MOVX    A,@DPTR
   \   0000BE   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000C0   50F8         JNC     ??macMcuInit_4
    272          
    273            /* put 16 random bits into the seed value */
    274            {
    275              uint16 rndSeed;
    276              uint8  i;
    277              rndSeed = 0;
   \   0000C2   7800         MOV     R0,#0x0
   \   0000C4   7900         MOV     R1,#0x0
    278          
    279              for(i=0; i<16; i++)
   \   0000C6   7C00         MOV     R4,#0x0
   \                     ??macMcuInit_5:
   \   0000C8   EC           MOV     A,R4
   \   0000C9   C3           CLR     C
   \   0000CA   9410         SUBB    A,#0x10
   \   0000CC   501A         JNC     ??macMcuInit_6
    280              {
    281                /* use most random bit of analog to digital receive conversion to populate the random seed */
    282                rndSeed = (rndSeed << 1) | (RFRND & 0x01);
   \   0000CE   E8           MOV     A,R0
   \   0000CF   28           ADD     A,R0
   \   0000D0   F8           MOV     R0,A
   \   0000D1   E9           MOV     A,R1
   \   0000D2   33           RLC     A
   \   0000D3   F9           MOV     R1,A
   \   0000D4   9061A7       MOV     DPTR,#0x61a7
   \   0000D7   E0           MOVX    A,@DPTR
   \   0000D8   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000DA   E4           CLR     A
   \   0000DB   33           RLC     A
   \   0000DC   FA           MOV     R2,A
   \   0000DD   7B00         MOV     R3,#0x0
   \   0000DF   E8           MOV     A,R0
   \   0000E0   4A           ORL     A,R2
   \   0000E1   F8           MOV     R0,A
   \   0000E2   E9           MOV     A,R1
   \   0000E3   4B           ORL     A,R3
   \   0000E4   F9           MOV     R1,A
    283              }
   \   0000E5   0C           INC     R4
   \   0000E6   80E0         SJMP    ??macMcuInit_5
    284          
    285              /*
    286               *  The seed value must not be zero or 0x0380 (0x8003 in the polynomial).  If it is, the psuedo
    287               *  random sequence won’t be random.  There is an extremely small chance this seed could randomly
    288               *  be zero or 0x0380.  The following check makes sure this does not happen.
    289               */
    290              if (rndSeed == 0x0000 || rndSeed == 0x0380)
   \                     ??macMcuInit_6:
   \   0000E8   E8           MOV     A,R0
   \   0000E9   49           ORL     A,R1
   \   0000EA   600A         JZ      ??macMcuInit_7
   \   0000EC   7480         MOV     A,#-0x80
   \   0000EE   68           XRL     A,R0
   \   0000EF   7003         JNZ     ??macMcuInit_8
   \   0000F1   7403         MOV     A,#0x3
   \   0000F3   69           XRL     A,R1
   \                     ??macMcuInit_8:
   \   0000F4   7004         JNZ     ??macMcuInit_9
    291              {
    292                rndSeed = 0xBABE; /* completely arbitrary "random" value */
   \                     ??macMcuInit_7:
   \   0000F6   78BE         MOV     R0,#-0x42
   \   0000F8   79BA         MOV     R1,#-0x46
    293              }
    294          
    295              /*
    296               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    297               *  of RNDL to RNDH before writing new the value to RNDL.
    298               */
    299              RNDL = rndSeed & 0xFF;
   \                     ??macMcuInit_9:
   \   0000FA   E8           MOV     A,R0
   \   0000FB   F5BC         MOV     0xbc,A
    300              RNDL = rndSeed >> 8;
   \   0000FD   E4           CLR     A
   \   0000FE   C9           XCH     A,R1
   \   0000FF   F8           MOV     R0,A
   \   000100   E8           MOV     A,R0
   \   000101   F5BC         MOV     0xbc,A
    301            }
    302          
    303            /* Read MAC_RANDOM_SEED_LEN X 8 random bits and store them in the proprietary PIB array
    304             * for future use in random key generation for CBKE key establishment.
    305             */
    306            for (uint8 i = 0; i < MAC_RANDOM_SEED_LEN; i++)
   \   000103   7A00         MOV     R2,#0x0
   \                     ??macMcuInit_10:
   \   000105   EA           MOV     A,R2
   \   000106   C3           CLR     C
   \   000107   9420         SUBB    A,#0x20
   \   000109   5032         JNC     ??macMcuInit_11
    307            {
    308              uint8 rndByte = 0;
   \   00010B   7800         MOV     R0,#0x0
    309          
    310              for (uint8 j = 0; j < 8; j++)
   \   00010D   7900         MOV     R1,#0x0
   \                     ??macMcuInit_12:
   \   00010F   E9           MOV     A,R1
   \   000110   C3           CLR     C
   \   000111   9408         SUBB    A,#0x8
   \   000113   5011         JNC     ??macMcuInit_13
    311              {
    312                /* use most random bit of analog to digital receive conversion to populate the random seed */
    313                rndByte = (rndByte << 1) | (RFRND & 0x01);
   \   000115   9061A7       MOV     DPTR,#0x61a7
   \   000118   E0           MOVX    A,@DPTR
   \   000119   A2E0         MOV     C,0xE0 /* A   */.0
   \   00011B   E4           CLR     A
   \   00011C   33           RLC     A
   \   00011D   FB           MOV     R3,A
   \   00011E   E8           MOV     A,R0
   \   00011F   C3           CLR     C
   \   000120   33           RLC     A
   \   000121   4B           ORL     A,R3
   \   000122   F8           MOV     R0,A
    314              }
   \   000123   09           INC     R1
   \   000124   80E9         SJMP    ??macMcuInit_12
    315          
    316              pMacPib->randomSeed[i] = rndByte;
   \                     ??macMcuInit_13:
   \   000126   E8           MOV     A,R0
   \   000127   C0E0         PUSH    A
   \   000129   EA           MOV     A,R2
   \   00012A   F8           MOV     R0,A
   \   00012B   7900         MOV     R1,#0x0
   \   00012D   74..         MOV     A,#(macPib + 94) & 0xff
   \   00012F   28           ADD     A,R0
   \   000130   F582         MOV     DPL,A
   \   000132   74..         MOV     A,#((macPib + 94) >> 8) & 0xff
   \   000134   39           ADDC    A,R1
   \   000135   F583         MOV     DPH,A
   \   000137   D0E0         POP     A
   \   000139   F0           MOVX    @DPTR,A
    317            }
   \   00013A   0A           INC     R2
   \   00013B   80C8         SJMP    ??macMcuInit_10
    318          
    319            if (pRandomSeedCB)
   \                     ??macMcuInit_11:
   \   00013D   90....       MOV     DPTR,#pRandomSeedCB
   \   000140   E0           MOVX    A,@DPTR
   \   000141   F8           MOV     R0,A
   \   000142   A3           INC     DPTR
   \   000143   E0           MOVX    A,@DPTR
   \   000144   F9           MOV     R1,A
   \   000145   E8           MOV     A,R0
   \   000146   49           ORL     A,R1
   \   000147   6012         JZ      ??macMcuInit_14
    320            {
    321              pRandomSeedCB(pMacPib->randomSeed);
   \   000149                ; Setup parameters for indirect call
   \   000149   7A..         MOV     R2,#(macPib + 94) & 0xff
   \   00014B   7B..         MOV     R3,#((macPib + 94) >> 8) & 0xff
   \   00014D   90....       MOV     DPTR,#pRandomSeedCB
   \   000150   E0           MOVX    A,@DPTR
   \   000151   F8           MOV     R0,A
   \   000152   A3           INC     DPTR
   \   000153   E0           MOVX    A,@DPTR
   \   000154   F583         MOV     DPH,A
   \   000156   8882         MOV     DPL,R0
   \   000158   12....       LCALL   ?CALL_IND
    322            }
    323          
    324            /* turn off the receiver */
    325            macRxOff();
   \                     ??macMcuInit_14:
   \   00015B                ; Setup parameters for call to function macRxOff
   \   00015B   12....       LCALL   `??macRxOff::?relay` ; Banked call to: macRxOff
    326          
    327            /* take receiver out of infinite reception mode; set back to normal operation */
    328            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
   \   00015E   906189       MOV     DPTR,#0x6189
   \   000161   7440         MOV     A,#0x40
   \   000163   F0           MOVX    @DPTR,A
    329          
    330            /* Turn on autoack */
    331            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   000164   906189       MOV     DPTR,#0x6189
   \   000167   E0           MOVX    A,@DPTR
   \   000168   D2E5         SETB    0xE0 /* A   */.5
   \   00016A   F0           MOVX    @DPTR,A
    332          
    333            /* Initialize SRCEXTPENDEN and SRCSHORTPENDEN to zeros */
    334            MAC_RADIO_SRC_MATCH_INIT_EXTPENDEN();
   \   00016B   906164       MOV     DPTR,#0x6164
   \   00016E   7400         MOV     A,#0x0
   \   000170   F0           MOVX    @DPTR,A
   \   000171   906165       MOV     DPTR,#0x6165
   \   000174   7400         MOV     A,#0x0
   \   000176   F0           MOVX    @DPTR,A
   \   000177   906166       MOV     DPTR,#0x6166
   \   00017A   7400         MOV     A,#0x0
   \   00017C   F0           MOVX    @DPTR,A
    335            MAC_RADIO_SRC_MATCH_INIT_SHORTPENDEN();
   \   00017D   906167       MOV     DPTR,#0x6167
   \   000180   7400         MOV     A,#0x0
   \   000182   F0           MOVX    @DPTR,A
   \   000183   906168       MOV     DPTR,#0x6168
   \   000186   7400         MOV     A,#0x0
   \   000188   F0           MOVX    @DPTR,A
   \   000189   906169       MOV     DPTR,#0x6169
   \   00018C   7400         MOV     A,#0x0
   \   00018E   F0           MOVX    @DPTR,A
    336          }
   \   00018F   7F01         MOV     R7,#0x1
   \   000191   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000194                REQUIRE IEN2
   \   000194                REQUIRE _A_IEN0
   \   000194                REQUIRE IP0
   \   000194                REQUIRE IP1
   \   000194                REQUIRE T2MSEL
   \   000194                REQUIRE T2M0
   \   000194                REQUIRE T2M1
   \   000194                REQUIRE CLKCONSTA
   \   000194                REQUIRE T2CTRL
   \   000194                REQUIRE _A_IEN1
   \   000194                REQUIRE RNDL
    337          
    338          
    339          /**************************************************************************************************
    340           * @fn          macMcuRandomByte
    341           *
    342           * @brief       Returns a random byte using a special hardware feature that generates new
    343           *              random values based on the truly random seed set earlier.
    344           *
    345           * @param       none
    346           *
    347           * @return      a random byte
    348           **************************************************************************************************
    349           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    350          MAC_INTERNAL_API uint8 macMcuRandomByte(void)
   \                     macMcuRandomByte:
    351          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    352            /* clock the random generator to get a new random value */
    353            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   E5B4         MOV     A,0xb4
   \   000002   54F3         ANL     A,#0xf3
   \   000004   4404         ORL     A,#0x4
   \   000006   F5B4         MOV     0xb4,A
    354          
    355            /* return new randomized value from hardware */
    356            return(RNDH);
   \   000008   E5BD         MOV     A,0xbd
   \   00000A   F9           MOV     R1,A
   \   00000B   02....       LJMP    ?BRET
   \   00000E                REQUIRE ADCCON1
   \   00000E                REQUIRE RNDH
    357          }
    358          
    359          
    360          /**************************************************************************************************
    361           * @fn          macMcuRandomWord
    362           *
    363           * @brief       Returns a random word using a special hardware feature that generates new
    364           *              random values based on the truly random seed set earlier.
    365           *
    366           * @param       none
    367           *
    368           * @return      a random word
    369           **************************************************************************************************
    370           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    371          MAC_INTERNAL_API uint16 macMcuRandomWord(void)
   \                     macMcuRandomWord:
    372          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    373            uint16 random_word;
    374          
    375            /* clock the random generator to get a new random value */
    376            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   E5B4         MOV     A,0xb4
   \   000002   54F3         ANL     A,#0xf3
   \   000004   4404         ORL     A,#0x4
   \   000006   F5B4         MOV     0xb4,A
    377          
    378            /* read random word */
    379            random_word  = (RNDH << 8);
   \   000008   A9BD         MOV     R1,0xbd
   \   00000A   E9           MOV     A,R1
   \   00000B   F9           MOV     R1,A
   \   00000C   E4           CLR     A
   \   00000D   F8           MOV     R0,A
   \   00000E   E8           MOV     A,R0
   \   00000F   FA           MOV     R2,A
   \   000010   E9           MOV     A,R1
   \   000011   FB           MOV     R3,A
    380            random_word +=  RNDL;
   \   000012   E5BC         MOV     A,0xbc
   \   000014   F8           MOV     R0,A
   \   000015   7900         MOV     R1,#0x0
   \   000017   EA           MOV     A,R2
   \   000018   28           ADD     A,R0
   \   000019   FA           MOV     R2,A
   \   00001A   EB           MOV     A,R3
   \   00001B   39           ADDC    A,R1
   \   00001C   FB           MOV     R3,A
    381          
    382            /* return new randomized value from hardware */
    383            return(random_word);
   \   00001D   02....       LJMP    ?BRET
   \   000020                REQUIRE ADCCON1
   \   000020                REQUIRE RNDH
   \   000020                REQUIRE RNDL
    384          }
    385          
    386          
    387          /**************************************************************************************************
    388           * @fn          macMcuTimerForceDelay
    389           *
    390           * @brief       Delay the timer by the requested number of ticks.
    391           *
    392           * @param       none
    393           *
    394           * @return      none
    395           **************************************************************************************************
    396           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    397          MAC_INTERNAL_API void macMcuTimerForceDelay(uint16 x)
   \                     macMcuTimerForceDelay:
    398          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    399            halIntState_t  s;
    400          
    401            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A2AF         MOV     C,0xa8.7
   \   000002   E4           CLR     A
   \   000003   33           RLC     A
   \   000004   FC           MOV     R4,A
   \   000005   C2AF         CLR     0xa8.7
    402            MAC_MCU_T2_ACCESS_COUNT_VALUE();
   \   000007   75C300       MOV     0xc3,#0x0
    403            T2M0 = (x) & 0xFF;
   \   00000A   EA           MOV     A,R2
   \   00000B   F5A2         MOV     0xa2,A
    404            T2M1 = (x) >> 8;
   \   00000D   EA           MOV     A,R2
   \   00000E   F8           MOV     R0,A
   \   00000F   EB           MOV     A,R3
   \   000010   F9           MOV     R1,A
   \   000011   E4           CLR     A
   \   000012   C9           XCH     A,R1
   \   000013   F8           MOV     R0,A
   \   000014   E8           MOV     A,R0
   \   000015   F5A3         MOV     0xa3,A
    405            HAL_EXIT_CRITICAL_SECTION(s);
   \   000017   EC           MOV     A,R4
   \   000018   F8           MOV     R0,A
   \   000019   EC           MOV     A,R4
   \   00001A   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001C   92AF         MOV     0xa8.7,C
    406          }
   \   00001E   02....       LJMP    ?BRET
   \   000021                REQUIRE _A_IEN0
   \   000021                REQUIRE T2MSEL
   \   000021                REQUIRE T2M0
   \   000021                REQUIRE T2M1
    407          
    408          /**************************************************************************************************
    409           * @fn          macMcuTimerCapture
    410           *
    411           * @brief       Returns the last timer capture.  This capture should have occurred at the
    412           *              receive time of the last frame (the last time SFD transitioned to active).
    413           *
    414           * @param       none
    415           *
    416           * @return      last capture of hardware timer (full 16-bit value)
    417           **************************************************************************************************
    418           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    419          MAC_INTERNAL_API uint16 macMcuTimerCapture(void)
   \                     macMcuTimerCapture:
    420          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    421            uint16         timerCapture;
    422            halIntState_t  s;
    423          
    424            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A2AF         MOV     C,0xa8.7
   \   000002   E4           CLR     A
   \   000003   33           RLC     A
   \   000004   FC           MOV     R4,A
   \   000005   C2AF         CLR     0xa8.7
    425            MAC_MCU_T2_ACCESS_CAPTURE_VALUE();
   \   000007   75C301       MOV     0xc3,#0x1
    426            timerCapture = T2M1 << 8;
   \   00000A   A9A3         MOV     R1,0xa3
   \   00000C   E9           MOV     A,R1
   \   00000D   F9           MOV     R1,A
   \   00000E   E4           CLR     A
   \   00000F   F8           MOV     R0,A
   \   000010   E8           MOV     A,R0
   \   000011   FA           MOV     R2,A
   \   000012   E9           MOV     A,R1
   \   000013   FB           MOV     R3,A
    427            timerCapture |= T2M0;
   \   000014   E5A2         MOV     A,0xa2
   \   000016   F8           MOV     R0,A
   \   000017   7900         MOV     R1,#0x0
   \   000019   E8           MOV     A,R0
   \   00001A   4A           ORL     A,R2
   \   00001B   FA           MOV     R2,A
   \   00001C   E9           MOV     A,R1
   \   00001D   4B           ORL     A,R3
   \   00001E   FB           MOV     R3,A
    428            HAL_EXIT_CRITICAL_SECTION(s);
   \   00001F   EC           MOV     A,R4
   \   000020   F8           MOV     R0,A
   \   000021   EC           MOV     A,R4
   \   000022   A2E0         MOV     C,0xE0 /* A   */.0
   \   000024   92AF         MOV     0xa8.7,C
    429          
    430            return (timerCapture);
   \   000026   02....       LJMP    ?BRET
   \   000029                REQUIRE _A_IEN0
   \   000029                REQUIRE T2MSEL
   \   000029                REQUIRE T2M1
   \   000029                REQUIRE T2M0
    431          }
    432          
    433          
    434          /**************************************************************************************************
    435           * @fn          macMcuOverflowCount
    436           *
    437           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    438           *              The overflow count actually is 24 bits of information.
    439           *
    440           * @param       none
    441           *
    442           * @return      value of overflow counter
    443           **************************************************************************************************
    444           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    445          MAC_INTERNAL_API uint32 macMcuOverflowCount(void)
   \                     macMcuOverflowCount:
    446          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    447            uint32         overflowCount;
    448            halIntState_t  s;
    449          
    450            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    451          
    452            HAL_ENTER_CRITICAL_SECTION(s);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   33           RLC     A
   \   00000E   F9           MOV     R1,A
   \   00000F   C2AF         CLR     0xa8.7
    453          
    454            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    455            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000011   75C300       MOV     0xc3,#0x0
    456          
    457            /* Latch the entire T2MOVFx first by reading T2M0. */
    458            T2M0;
   \   000014   A8A2         MOV     R0,0xa2+0x0
    459            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000016   E5A4         MOV     A,0xa4
   \   000018   C0E0         PUSH    A
   \   00001A   85..82       MOV     DPL,?XSP + 0
   \   00001D   85..83       MOV     DPH,?XSP + 1
   \   000020   D0E0         POP     A
   \   000022   F0           MOVX    @DPTR,A
    460            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
   \   000023   E5A5         MOV     A,0xa5
   \   000025   C0E0         PUSH    A
   \   000027   7401         MOV     A,#0x1
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   D0E0         POP     A
   \   00002E   F0           MOVX    @DPTR,A
    461            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
   \   00002F   E5A6         MOV     A,0xa6
   \   000031   C0E0         PUSH    A
   \   000033   7402         MOV     A,#0x2
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   D0E0         POP     A
   \   00003A   F0           MOVX    @DPTR,A
    462            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
   \   00003B   7403         MOV     A,#0x3
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   7400         MOV     A,#0x0
   \   000042   F0           MOVX    @DPTR,A
    463            HAL_EXIT_CRITICAL_SECTION(s);
   \   000043   E9           MOV     A,R1
   \   000044   FE           MOV     R6,A
   \   000045   E9           MOV     A,R1
   \   000046   A2E0         MOV     C,0xE0 /* A   */.0
   \   000048   92AF         MOV     0xa8.7,C
    464          
    465            return (overflowCount);
   \   00004A   85..82       MOV     DPL,?XSP + 0
   \   00004D   85..83       MOV     DPH,?XSP + 1
   \   000050   12....       LCALL   ?XLOAD_R2345
   \   000053   7404         MOV     A,#0x4
   \   000055   12....       LCALL   ?DEALLOC_XSTACK8
   \   000058   7F01         MOV     R7,#0x1
   \   00005A   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00005D                REQUIRE _A_IEN0
   \   00005D                REQUIRE T2MSEL
   \   00005D                REQUIRE T2M0
   \   00005D                REQUIRE T2MOVF0
   \   00005D                REQUIRE T2MOVF1
   \   00005D                REQUIRE T2MOVF2
    466          }
    467          
    468          
    469          /**************************************************************************************************
    470           * @fn          macMcuOverflowCapture
    471           *
    472           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    473           *              captures the overflow counter when the regular hardware timer is captured.
    474           *
    475           * @param       none
    476           *
    477           * @return      last capture of overflow count
    478           **************************************************************************************************
    479           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    480          MAC_INTERNAL_API uint32 macMcuOverflowCapture(void)
   \                     macMcuOverflowCapture:
    481          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    482            uint32         overflowCapture;
    483            halIntState_t  s;
    484          
    485            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    486            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   33           RLC     A
   \   00000D   F8           MOV     R0,A
   \   00000E   C2AF         CLR     0xa8.7
    487            MAC_MCU_T2_ACCESS_OVF_CAPTURE_VALUE();
   \   000010   75C310       MOV     0xc3,#0x10
    488            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2MOVF0;
   \   000013   E5A4         MOV     A,0xa4
   \   000015   C0E0         PUSH    A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   D0E0         POP     A
   \   00001F   F0           MOVX    @DPTR,A
    489            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2MOVF1;
   \   000020   E5A5         MOV     A,0xa5
   \   000022   C0E0         PUSH    A
   \   000024   7401         MOV     A,#0x1
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   D0E0         POP     A
   \   00002B   F0           MOVX    @DPTR,A
    490            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2MOVF2;
   \   00002C   E5A6         MOV     A,0xa6
   \   00002E   C0E0         PUSH    A
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   D0E0         POP     A
   \   000037   F0           MOVX    @DPTR,A
    491            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
   \   000038   7403         MOV     A,#0x3
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   7400         MOV     A,#0x0
   \   00003F   F0           MOVX    @DPTR,A
    492            HAL_EXIT_CRITICAL_SECTION(s);
   \   000040   E8           MOV     A,R0
   \   000041   F9           MOV     R1,A
   \   000042   E8           MOV     A,R0
   \   000043   A2E0         MOV     C,0xE0 /* A   */.0
   \   000045   92AF         MOV     0xa8.7,C
    493          
    494            return (overflowCapture);
   \   000047   85..82       MOV     DPL,?XSP + 0
   \   00004A   85..83       MOV     DPH,?XSP + 1
   \   00004D   12....       LCALL   ?XLOAD_R2345
   \   000050   7404         MOV     A,#0x4
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   \   000055   D083         POP     DPH
   \   000057   D082         POP     DPL
   \   000059   02....       LJMP    ?BRET
   \   00005C                REQUIRE _A_IEN0
   \   00005C                REQUIRE T2MSEL
   \   00005C                REQUIRE T2MOVF0
   \   00005C                REQUIRE T2MOVF1
   \   00005C                REQUIRE T2MOVF2
    495          }
    496          
    497          
    498          /**************************************************************************************************
    499           * @fn          macMcuOverflowSetCount
    500           *
    501           * @brief       Sets the value of the hardware overflow counter.
    502           *
    503           * @param       count - new overflow count value
    504           *
    505           * @return      none
    506           **************************************************************************************************
    507           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    508          MAC_INTERNAL_API void macMcuOverflowSetCount(uint32 count)
   \                     macMcuOverflowSetCount:
    509          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EC           MOV     A,R4
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   ED           MOV     A,R5
   \   00001A   F0           MOVX    @DPTR,A
    510            halIntState_t  s;
    511          
    512            MAC_ASSERT(! (count >> 24) );   /* illegal count value */
   \   00001B   85..82       MOV     DPL,?XSP + 0
   \   00001E   85..83       MOV     DPH,?XSP + 1
   \   000021   78..         MOV     R0,#?V0
   \   000023   12....       LCALL   ?L_MOV_X
   \   000026   90....       MOV     DPTR,#__Constant_ff000000
   \   000029   78..         MOV     R0,#?V0
   \   00002B   12....       LCALL   ?L_AND_X
   \   00002E   E5..         MOV     A,?V0
   \   000030   45..         ORL     A,?V1
   \   000032   45..         ORL     A,?V2
   \   000034   45..         ORL     A,?V3
   \   000036   6003         JZ      ??macMcuOverflowSetCount_0
   \   000038                ; Setup parameters for call to function halAssertHandler
   \   000038   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    513          
    514            /* save the current overflow count */
    515            accumulatedOverflowCount += macMcuOverflowCount();
   \                     ??macMcuOverflowSetCount_0:
   \   00003B                ; Setup parameters for call to function macMcuOverflowCount
   \   00003B   12....       LCALL   `??macMcuOverflowCount::?relay`; Banked call to: macMcuOverflowCount
   \   00003E   8A..         MOV     ?V0,R2
   \   000040   8B..         MOV     ?V1,R3
   \   000042   8C..         MOV     ?V2,R4
   \   000044   8D..         MOV     ?V3,R5
   \   000046   90....       MOV     DPTR,#accumulatedOverflowCount
   \   000049   78..         MOV     R0,#?V0
   \   00004B   12....       LCALL   ?L_ADD_TO_X
    516          
    517            /* deduct the initial count */
    518            accumulatedOverflowCount -= count;
   \   00004E   85..82       MOV     DPL,?XSP + 0
   \   000051   85..83       MOV     DPH,?XSP + 1
   \   000054   78..         MOV     R0,#?V0
   \   000056   12....       LCALL   ?L_MOV_X
   \   000059   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00005C   78..         MOV     R0,#?V0
   \   00005E   12....       LCALL   ?L_SUB_FROM_X
    519          
    520            HAL_ENTER_CRITICAL_SECTION(s);
   \   000061   A2AF         MOV     C,0xa8.7
   \   000063   E4           CLR     A
   \   000064   33           RLC     A
   \   000065   FE           MOV     R6,A
   \   000066   C2AF         CLR     0xa8.7
    521            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000068   75C300       MOV     0xc3,#0x0
    522          
    523            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    524            /* T2OF2 must be written last */
    525            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   00006B   85..82       MOV     DPL,?XSP + 0
   \   00006E   85..83       MOV     DPH,?XSP + 1
   \   000071   E0           MOVX    A,@DPTR
   \   000072   F5A4         MOV     0xa4,A
    526            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000074   7401         MOV     A,#0x1
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   F5A5         MOV     0xa5,A
    527            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   00007C   7402         MOV     A,#0x2
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F5A6         MOV     0xa6,A
    528            HAL_EXIT_CRITICAL_SECTION(s);
   \   000084   EE           MOV     A,R6
   \   000085   F8           MOV     R0,A
   \   000086   EE           MOV     A,R6
   \   000087   A2E0         MOV     C,0xE0 /* A   */.0
   \   000089   92AF         MOV     0xa8.7,C
    529          }
   \   00008B   7404         MOV     A,#0x4
   \   00008D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000090   7F04         MOV     R7,#0x4
   \   000092   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000095                REQUIRE _A_IEN0
   \   000095                REQUIRE T2MSEL
   \   000095                REQUIRE T2MOVF0
   \   000095                REQUIRE T2MOVF1
   \   000095                REQUIRE T2MOVF2
    530          
    531          
    532          /**************************************************************************************************
    533           * @fn          macMcuOverflowSetCompare
    534           *
    535           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    536           *              count equals this compare value.
    537           *
    538           * @param       count - overflow count compare value
    539           *
    540           * @return      none
    541           **************************************************************************************************
    542           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    543          MAC_INTERNAL_API void macMcuOverflowSetCompare(uint32 count)
   \                     macMcuOverflowSetCompare:
    544          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EC           MOV     A,R4
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   ED           MOV     A,R5
   \   00001A   F0           MOVX    @DPTR,A
    545            halIntState_t  s;
    546            uint8 enableCompareInt = 0;
   \   00001B   7E00         MOV     R6,#0x0
    547          
    548            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   78..         MOV     R0,#?V0
   \   000025   12....       LCALL   ?L_MOV_X
   \   000028   90....       MOV     DPTR,#__Constant_ff000000
   \   00002B   78..         MOV     R0,#?V0
   \   00002D   12....       LCALL   ?L_AND_X
   \   000030   E5..         MOV     A,?V0
   \   000032   45..         ORL     A,?V1
   \   000034   45..         ORL     A,?V2
   \   000036   45..         ORL     A,?V3
   \   000038   6003         JZ      ??macMcuOverflowSetCompare_0
   \   00003A                ; Setup parameters for call to function halAssertHandler
   \   00003A   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    549          
    550            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_0:
   \   00003D   A2AF         MOV     C,0xa8.7
   \   00003F   E4           CLR     A
   \   000040   33           RLC     A
   \   000041   FF           MOV     R7,A
   \   000042   C2AF         CLR     0xa8.7
    551          
    552            /*  Disable overflow compare interrupts. */
    553            if (T2IRQM & TIMER2_OVF_COMPARE1M)
   \   000044   E5A7         MOV     A,0xa7
   \   000046   A2E4         MOV     C,0xE0 /* A   */.4
   \   000048   5005         JNC     ??macMcuOverflowSetCompare_1
    554            {
    555              enableCompareInt = 1;
   \   00004A   7E01         MOV     R6,#0x1
    556              T2IRQM &= ~TIMER2_OVF_COMPARE1M;
   \   00004C   53A7EF       ANL     0xa7,#0xef
    557            }
    558          
    559            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
   \                     ??macMcuOverflowSetCompare_1:
   \   00004F   75C330       MOV     0xc3,#0x30
    560          
    561            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    562            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5A4         MOV     0xa4,A
    563            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00005B   7401         MOV     A,#0x1
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F5A5         MOV     0xa5,A
    564            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F5A6         MOV     0xa6,A
    565          
    566            /*
    567             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    568             *  in case a false match was generated as the multi-byte compare value was written.
    569             */
    570            T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   00006B   75A1EF       MOV     0xa1,#-0x11
    571          
    572            /* re-enable overflow compare interrupts if they were previously enabled */
    573            if (enableCompareInt)
   \   00006E   EE           MOV     A,R6
   \   00006F   6003         JZ      ??macMcuOverflowSetCompare_2
    574            {
    575              T2IRQM |= TIMER2_OVF_COMPARE1M;
   \   000071   43A710       ORL     0xa7,#0x10
    576            }
    577          
    578            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_2:
   \   000074   EF           MOV     A,R7
   \   000075   F8           MOV     R0,A
   \   000076   EF           MOV     A,R7
   \   000077   A2E0         MOV     C,0xE0 /* A   */.0
   \   000079   92AF         MOV     0xa8.7,C
    579          }
   \   00007B   7404         MOV     A,#0x4
   \   00007D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000080   7F04         MOV     R7,#0x4
   \   000082   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000085                REQUIRE _A_IEN0
   \   000085                REQUIRE T2IRQM
   \   000085                REQUIRE T2MSEL
   \   000085                REQUIRE T2MOVF0
   \   000085                REQUIRE T2MOVF1
   \   000085                REQUIRE T2MOVF2
   \   000085                REQUIRE T2IRQF
    580          
    581          
    582          /**************************************************************************************************
    583           * @fn          macMcuOverflowSetPeriod
    584           *
    585           * @brief       Set overflow count period value.  An interrupt is triggered when the overflow
    586           *              count equals this period value.
    587           *
    588           * @param       count - overflow count compare value
    589           *
    590           * @return      none
    591           **************************************************************************************************
    592           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    593          MAC_INTERNAL_API void macMcuOverflowSetPeriod(uint32 count)
   \                     macMcuOverflowSetPeriod:
    594          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   EA           MOV     A,R2
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EB           MOV     A,R3
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EC           MOV     A,R4
   \   000017   F0           MOVX    @DPTR,A
   \   000018   A3           INC     DPTR
   \   000019   ED           MOV     A,R5
   \   00001A   F0           MOVX    @DPTR,A
    595            halIntState_t  s;
    596            uint8 enableCompareInt = 0;
   \   00001B   7E00         MOV     R6,#0x0
    597          
    598            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \   00001D   85..82       MOV     DPL,?XSP + 0
   \   000020   85..83       MOV     DPH,?XSP + 1
   \   000023   78..         MOV     R0,#?V0
   \   000025   12....       LCALL   ?L_MOV_X
   \   000028   90....       MOV     DPTR,#__Constant_ff000000
   \   00002B   78..         MOV     R0,#?V0
   \   00002D   12....       LCALL   ?L_AND_X
   \   000030   E5..         MOV     A,?V0
   \   000032   45..         ORL     A,?V1
   \   000034   45..         ORL     A,?V2
   \   000036   45..         ORL     A,?V3
   \   000038   6003         JZ      ??macMcuOverflowSetPeriod_0
   \   00003A                ; Setup parameters for call to function halAssertHandler
   \   00003A   12....       LCALL   `??halAssertHandler::?relay`; Banked call to: halAssertHandler
    599          
    600            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetPeriod_0:
   \   00003D   A2AF         MOV     C,0xa8.7
   \   00003F   E4           CLR     A
   \   000040   33           RLC     A
   \   000041   FF           MOV     R7,A
   \   000042   C2AF         CLR     0xa8.7
    601          
    602            /*  Disable overflow compare interrupts. */
    603            if (T2IRQM & TIMER2_OVF_PERM)
   \   000044   E5A7         MOV     A,0xa7
   \   000046   A2E3         MOV     C,0xE0 /* A   */.3
   \   000048   5005         JNC     ??macMcuOverflowSetPeriod_1
    604            {
    605              enableCompareInt = 1;
   \   00004A   7E01         MOV     R6,#0x1
    606              T2IRQM &= ~TIMER2_OVF_PERM;
   \   00004C   53A7F7       ANL     0xa7,#0xf7
    607            }
    608          
    609            MAC_MCU_T2_ACCESS_OVF_PERIOD_VALUE();
   \                     ??macMcuOverflowSetPeriod_1:
   \   00004F   75C320       MOV     0xc3,#0x20
    610          
    611            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    612            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   000052   85..82       MOV     DPL,?XSP + 0
   \   000055   85..83       MOV     DPH,?XSP + 1
   \   000058   E0           MOVX    A,@DPTR
   \   000059   F5A4         MOV     0xa4,A
    613            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   00005B   7401         MOV     A,#0x1
   \   00005D   12....       LCALL   ?XSTACK_DISP0_8
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F5A5         MOV     0xa5,A
    614            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F5A6         MOV     0xa6,A
    615          
    616            /*
    617             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    618             *  in case a false match was generated as the multi-byte compare value was written.
    619             */
    620            T2IRQF &= ~TIMER2_OVF_PERF;
   \   00006B   53A1F7       ANL     0xa1,#0xf7
    621          
    622            /* re-enable overflow compare interrupts if they were previously enabled */
    623            if (enableCompareInt)
   \   00006E   EE           MOV     A,R6
   \   00006F   6003         JZ      ??macMcuOverflowSetPeriod_2
    624            {
    625              T2IRQM |= TIMER2_OVF_PERM;
   \   000071   43A708       ORL     0xa7,#0x8
    626            }
    627            halSetMaxSleepLoopTime(count);
   \                     ??macMcuOverflowSetPeriod_2:
   \   000074                ; Setup parameters for call to function halSetMaxSleepLoopTime
   \   000074   85..82       MOV     DPL,?XSP + 0
   \   000077   85..83       MOV     DPH,?XSP + 1
   \   00007A   12....       LCALL   ?XLOAD_R2345
   \   00007D   12....       LCALL   `??halSetMaxSleepLoopTime::?relay`; Banked call to: halSetMaxSleepLoopTime
    628            HAL_EXIT_CRITICAL_SECTION(s);
   \   000080   EF           MOV     A,R7
   \   000081   F8           MOV     R0,A
   \   000082   EF           MOV     A,R7
   \   000083   A2E0         MOV     C,0xE0 /* A   */.0
   \   000085   92AF         MOV     0xa8.7,C
    629          }
   \   000087   7404         MOV     A,#0x4
   \   000089   12....       LCALL   ?DEALLOC_XSTACK8
   \   00008C   7F04         MOV     R7,#0x4
   \   00008E   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000091                REQUIRE _A_IEN0
   \   000091                REQUIRE T2IRQM
   \   000091                REQUIRE T2MSEL
   \   000091                REQUIRE T2MOVF0
   \   000091                REQUIRE T2MOVF1
   \   000091                REQUIRE T2MOVF2
   \   000091                REQUIRE T2IRQF
    630          
    631          
    632          /**************************************************************************************************
    633           * @fn          macMcuOverflowGetCompare
    634           *
    635           * @brief       Get overflow count compare value.
    636           *
    637           * @param       none
    638           *
    639           * @return      overflow count compare value
    640           **************************************************************************************************
    641           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    642          MAC_INTERNAL_API uint32 macMcuOverflowGetCompare(void)
   \                     macMcuOverflowGetCompare:
    643          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 4
   \   000004   74FC         MOV     A,#-0x4
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    644            halIntState_t  s;
    645            uint32         compare;
    646          
    647            HAL_ENTER_CRITICAL_SECTION(s);
   \   000009   A2AF         MOV     C,0xa8.7
   \   00000B   E4           CLR     A
   \   00000C   33           RLC     A
   \   00000D   F8           MOV     R0,A
   \   00000E   C2AF         CLR     0xa8.7
    648          
    649            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
   \   000010   75C330       MOV     0xc3,#0x30
    650          
    651            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    652            ((uint8 *)&compare)[UINT32_NDX0] = T2MOVF0;
   \   000013   E5A4         MOV     A,0xa4
   \   000015   C0E0         PUSH    A
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   D0E0         POP     A
   \   00001F   F0           MOVX    @DPTR,A
    653            ((uint8 *)&compare)[UINT32_NDX1] = T2MOVF1;
   \   000020   E5A5         MOV     A,0xa5
   \   000022   C0E0         PUSH    A
   \   000024   7401         MOV     A,#0x1
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   D0E0         POP     A
   \   00002B   F0           MOVX    @DPTR,A
    654            ((uint8 *)&compare)[UINT32_NDX2] = T2MOVF2;
   \   00002C   E5A6         MOV     A,0xa6
   \   00002E   C0E0         PUSH    A
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   D0E0         POP     A
   \   000037   F0           MOVX    @DPTR,A
    655            ((uint8 *)&compare)[UINT32_NDX3] = 0;
   \   000038   7403         MOV     A,#0x3
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   7400         MOV     A,#0x0
   \   00003F   F0           MOVX    @DPTR,A
    656          
    657            HAL_EXIT_CRITICAL_SECTION(s);
   \   000040   E8           MOV     A,R0
   \   000041   F9           MOV     R1,A
   \   000042   E8           MOV     A,R0
   \   000043   A2E0         MOV     C,0xE0 /* A   */.0
   \   000045   92AF         MOV     0xa8.7,C
    658          
    659            return(compare);
   \   000047   85..82       MOV     DPL,?XSP + 0
   \   00004A   85..83       MOV     DPH,?XSP + 1
   \   00004D   12....       LCALL   ?XLOAD_R2345
   \   000050   7404         MOV     A,#0x4
   \   000052   12....       LCALL   ?DEALLOC_XSTACK8
   \   000055   D083         POP     DPH
   \   000057   D082         POP     DPL
   \   000059   02....       LJMP    ?BRET
   \   00005C                REQUIRE _A_IEN0
   \   00005C                REQUIRE T2MSEL
   \   00005C                REQUIRE T2MOVF0
   \   00005C                REQUIRE T2MOVF1
   \   00005C                REQUIRE T2MOVF2
    660          }
    661          
    662          
    663          /**************************************************************************************************
    664           * @fn          macMcuTimer2Isr
    665           *
    666           * @brief       Interrupt service routine for timer2, the MAC timer.
    667           *
    668           * @param       none
    669           *
    670           * @return      none
    671           **************************************************************************************************
    672           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    673          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
   \                     macMcuTimer2Isr:
    674          {
   \   000000                REQUIRE ?V0
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    675            uint8 t2irqm;
    676            uint8 t2irqf;
    677          
    678            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    679          
    680            t2irqm = T2IRQM;
   \   00000E   85A7..       MOV     ?V0,0xa7+0x0
    681            t2irqf = T2IRQF;
   \   000011   AFA1         MOV     R7,0xa1+0x0
    682          
    683            /*------------------------------------------------------------------------------------------------
    684             *  Overflow compare interrupt - triggers when then overflow counter is
    685             *  equal to the overflow compare register.
    686             */
    687            if ((t2irqf & TIMER2_OVF_COMPARE1F) & t2irqm)
   \   000013   EF           MOV     A,R7
   \   000014   55..         ANL     A,?V0
   \   000016   5410         ANL     A,#0x10
   \   000018   6006         JZ      ??macMcuTimer2Isr_0
    688            {
    689          
    690              /* call function for dealing with the timer compare interrupt */
    691              macBackoffTimerCompareIsr();
   \   00001A                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   00001A   12....       LCALL   `??macBackoffTimerCompareIsr::?relay`; Banked call to: macBackoffTimerCompareIsr
    692          
    693              /* clear overflow compare interrupt flag */
    694              T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   00001D   75A1EF       MOV     0xa1,#-0x11
    695            }
    696          
    697            /*------------------------------------------------------------------------------------------------
    698             *  Overflow compare interrupt - triggers when then overflow counter is
    699             *  equal to the overflow compare register.
    700             */
    701            if ((t2irqf & TIMER2_OVF_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_0:
   \   000020   EF           MOV     A,R7
   \   000021   55..         ANL     A,?V0
   \   000023   5408         ANL     A,#0x8
   \   000025   6008         JZ      ??macMcuTimer2Isr_1
    702            {
    703          
    704              /* call function for dealing with the timer compare interrupt */
    705              macBackoffTimerPeriodIsr();
   \   000027                ; Setup parameters for call to function macBackoffTimerPeriodIsr
   \   000027   12....       LCALL   `??macBackoffTimerPeriodIsr::?relay`; Banked call to: macBackoffTimerPeriodIsr
    706          
    707              /* clear overflow compare interrupt flag */
    708              T2IRQF = (TIMER2_OVF_PERF ^ 0xFF);
   \   00002A   75A1F7       MOV     0xa1,#-0x9
   \   00002D   8013         SJMP    ??macMcuTimer2Isr_2
    709            }
    710          
    711            /*------------------------------------------------------------------------------------------------
    712             *  Overflow interrupt - triggers when the hardware timer rolls over.
    713             */
    714            else if ((t2irqf & TIMER2_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_1:
   \   00002F   EF           MOV     A,R7
   \   000030   A2E0         MOV     C,0xE0 /* A   */.0
   \   000032   92F0         MOV     B.0,C
   \   000034   E5..         MOV     A,?V0
   \   000036   A2E0         MOV     C,0xE0 /* A   */.0
   \   000038   82F0         ANL     C,B.0
   \   00003A   5006         JNC     ??macMcuTimer2Isr_2
    715            {
    716              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    717              mcuRecordMaxRssiIsr();
   \   00003C                ; Setup parameters for call to function mcuRecordMaxRssiIsr
   \   00003C   12....       LCALL   `??mcuRecordMaxRssiIsr::?relay`; Banked call to: mcuRecordMaxRssiIsr
    718          
    719              /* clear the interrupt flag */
    720              T2IRQF = (TIMER2_PERF ^ 0xFF);
   \   00003F   75A1FE       MOV     0xa1,#-0x2
    721            }
    722          
    723            CLEAR_SLEEP_MODE();
    724            HAL_EXIT_ISR();
   \                     ??macMcuTimer2Isr_2:
   \   000042   EE           MOV     A,R6
   \   000043   F8           MOV     R0,A
   \   000044   EE           MOV     A,R6
   \   000045   A2E0         MOV     C,0xE0 /* A   */.0
   \   000047   92AF         MOV     0xa8.7,C
    725          }
   \   000049   7F01         MOV     R7,#0x1
   \   00004B   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   00004E                REQUIRE _A_IEN0
   \   00004E                REQUIRE T2IRQM
   \   00004E                REQUIRE T2IRQF
    726          
    727          
    728          /**************************************************************************************************
    729           * @fn          macMcuTimer2OverflowWorkaround
    730           *
    731           * @brief       For CC2530, T2 interrupt won’t be generated when the current count is greater than
    732           *              the comparator. The interrupt is only generated when the current count is equal to
    733           *              the comparator. When the CC2530 is waking up from sleep, there is a small window
    734           *              that the count may be grater than the comparator, therefore, missing the interrupt.
    735           *              This workaround will call the T2 ISR when the current T2 count is greater than the
    736           *              comparator.
    737           *
    738           * @param       none
    739           *
    740           * @return      none
    741           **************************************************************************************************
    742           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    743          void macMcuTimer2OverflowWorkaround(void)
   \                     macMcuTimer2OverflowWorkaround:
    744          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000                REQUIRE ?V4
   \   000000                REQUIRE ?V5
   \   000000                REQUIRE ?V6
   \   000000                REQUIRE ?V7
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    745            if (T2IRQM & TIMER2_OVF_COMPARE1F)
   \   000005   E5A7         MOV     A,0xa7
   \   000007   A2E4         MOV     C,0xE0 /* A   */.4
   \   000009   502B         JNC     ??macMcuTimer2OverflowWorkaround_0
    746            {
    747              /* T2 comapre 1 interrupt is enabled but T2 compare 1 intererrupt is not generated */
    748              if (!(T2IRQF & TIMER2_OVF_COMPARE1F))
   \   00000B   E5A1         MOV     A,0xa1
   \   00000D   A2E4         MOV     C,0xE0 /* A   */.4
   \   00000F   4025         JC      ??macMcuTimer2OverflowWorkaround_0
    749              {
    750                if (MAC_RADIO_BACKOFF_COUNT() > macMcuOverflowGetCompare())
   \   000011                ; Setup parameters for call to function macMcuOverflowGetCompare
   \   000011   12....       LCALL   `??macMcuOverflowGetCompare::?relay`; Banked call to: macMcuOverflowGetCompare
   \   000014   8A..         MOV     ?V0,R2
   \   000016   8B..         MOV     ?V1,R3
   \   000018   8C..         MOV     ?V2,R4
   \   00001A   8D..         MOV     ?V3,R5
   \   00001C                ; Setup parameters for call to function macMcuOverflowCount
   \   00001C   12....       LCALL   `??macMcuOverflowCount::?relay`; Banked call to: macMcuOverflowCount
   \   00001F   8A..         MOV     ?V4,R2
   \   000021   8B..         MOV     ?V5,R3
   \   000023   8C..         MOV     ?V6,R4
   \   000025   8D..         MOV     ?V7,R5
   \   000027   78..         MOV     R0,#?V4
   \   000029   79..         MOV     R1,#?V0
   \   00002B   12....       LCALL   ?UL_GT
   \   00002E   5006         JNC     ??macMcuTimer2OverflowWorkaround_0
    751                {
    752                  /* Set the flag to trigger the timer compare interrupt */
    753                  macBackoffTimerCompareIsr();
   \   000030                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   000030   12....       LCALL   `??macBackoffTimerCompareIsr::?relay`; Banked call to: macBackoffTimerCompareIsr
    754                  T2IRQF = (TIMER2_OVF_COMPARE1F ^ 0xFF);
   \   000033   75A1EF       MOV     0xa1,#-0x11
    755                }
    756              }
    757            }
    758          }
   \                     ??macMcuTimer2OverflowWorkaround_0:
   \   000036   7F08         MOV     R7,#0x8
   \   000038   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00003B                REQUIRE T2IRQM
   \   00003B                REQUIRE T2IRQF
    759          
    760          
    761          /**************************************************************************************************
    762           * @fn          macMcuPrecisionCount
    763           *
    764           * @brief       This function is used by higher layer to read a free running counter driven by
    765           *              MAC timer.
    766           *
    767           * @param       none
    768           *
    769           * @return      overflowCount
    770           **************************************************************************************************
    771           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    772          uint32 macMcuPrecisionCount(void)
   \                     macMcuPrecisionCount:
    773          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    774            uint32         overflowCount = 0;
   \   00000A   7C00         MOV     R4,#0x0
   \   00000C   7D00         MOV     R5,#0x0
   \   00000E   7E00         MOV     R6,#0x0
   \   000010   7F00         MOV     R7,#0x0
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   EC           MOV     A,R4
   \   000019   F0           MOVX    @DPTR,A
   \   00001A   A3           INC     DPTR
   \   00001B   ED           MOV     A,R5
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   \   00001E   EE           MOV     A,R6
   \   00001F   F0           MOVX    @DPTR,A
   \   000020   A3           INC     DPTR
   \   000021   EF           MOV     A,R7
   \   000022   F0           MOVX    @DPTR,A
    775            halIntState_t  s;
    776          
    777            HAL_ENTER_CRITICAL_SECTION(s);
   \   000023   A2AF         MOV     C,0xa8.7
   \   000025   E4           CLR     A
   \   000026   33           RLC     A
   \   000027   FE           MOV     R6,A
   \   000028   C2AF         CLR     0xa8.7
    778          
    779            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    780            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00002A   75C300       MOV     0xc3,#0x0
    781          
    782            /* Latch the entire T2MOVFx first by reading T2M0.
    783             * T2M0 is discarded.
    784             */
    785            T2M0;
   \   00002D   A9A2         MOV     R1,0xa2+0x0
    786            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   00002F   E5A4         MOV     A,0xa4
   \   000031   C0E0         PUSH    A
   \   000033   85..82       MOV     DPL,?XSP + 0
   \   000036   85..83       MOV     DPH,?XSP + 1
   \   000039   D0E0         POP     A
   \   00003B   F0           MOVX    @DPTR,A
    787            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
   \   00003C   E5A5         MOV     A,0xa5
   \   00003E   C0E0         PUSH    A
   \   000040   7401         MOV     A,#0x1
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   D0E0         POP     A
   \   000047   F0           MOVX    @DPTR,A
    788            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
   \   000048   E5A6         MOV     A,0xa6
   \   00004A   C0E0         PUSH    A
   \   00004C   7402         MOV     A,#0x2
   \   00004E   12....       LCALL   ?XSTACK_DISP0_8
   \   000051   D0E0         POP     A
   \   000053   F0           MOVX    @DPTR,A
    789          
    790            /* the overflowCount needs to account for the accumulated overflow count in Beacon mode */
    791            overflowCount += accumulatedOverflowCount;
   \   000054   90....       MOV     DPTR,#accumulatedOverflowCount
   \   000057   78..         MOV     R0,#?V0
   \   000059   12....       LCALL   ?L_MOV_X
   \   00005C   85..82       MOV     DPL,?XSP + 0
   \   00005F   85..83       MOV     DPH,?XSP + 1
   \   000062   78..         MOV     R0,#?V0
   \   000064   12....       LCALL   ?L_ADD_TO_X
    792          
    793            /*
    794             * Workaround to take care of the case where a rollover just occured and the call to
    795             * macBackoffTimerPeriodIsr() hasn't yet occured or if one rollover occured during
    796             * sleep then update the accumulatedoverflowCount with the rollover
    797             */
    798            if((prevoverflowCount > overflowCount) && (prevAccumulatedOverflowCount == accumulatedOverflowCount))
   \   000067   90....       MOV     DPTR,#prevoverflowCount
   \   00006A   78..         MOV     R0,#?V0
   \   00006C   12....       LCALL   ?L_MOV_X
   \   00006F   85..82       MOV     DPL,?XSP + 0
   \   000072   85..83       MOV     DPH,?XSP + 1
   \   000075   78..         MOV     R0,#?V0
   \   000077   12....       LCALL   ?UL_GT_X
   \   00007A   5041         JNC     ??macMcuPrecisionCount_0
   \   00007C   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00007F   78..         MOV     R0,#?V0
   \   000081   12....       LCALL   ?L_MOV_X
   \   000084   90....       MOV     DPTR,#prevAccumulatedOverflowCount
   \   000087   78..         MOV     R0,#?V0
   \   000089   12....       LCALL   ?L_EQ_X
   \   00008C   702F         JNZ     ??macMcuPrecisionCount_0
    799            {
    800              accumulatedOverflowCount += macGetBackOffTimerRollover();
   \   00008E                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   00008E   12....       LCALL   `??macGetBackOffTimerRollover::?relay`; Banked call to: macGetBackOffTimerRollover
   \   000091   8A..         MOV     ?V0,R2
   \   000093   8B..         MOV     ?V1,R3
   \   000095   8C..         MOV     ?V2,R4
   \   000097   8D..         MOV     ?V3,R5
   \   000099   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00009C   78..         MOV     R0,#?V0
   \   00009E   12....       LCALL   ?L_ADD_TO_X
    801              overflowCount += macGetBackOffTimerRollover();
   \   0000A1                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   0000A1   12....       LCALL   `??macGetBackOffTimerRollover::?relay`; Banked call to: macGetBackOffTimerRollover
   \   0000A4   8A..         MOV     ?V0,R2
   \   0000A6   8B..         MOV     ?V1,R3
   \   0000A8   8C..         MOV     ?V2,R4
   \   0000AA   8D..         MOV     ?V3,R5
   \   0000AC   85..82       MOV     DPL,?XSP + 0
   \   0000AF   85..83       MOV     DPH,?XSP + 1
   \   0000B2   78..         MOV     R0,#?V0
   \   0000B4   12....       LCALL   ?L_ADD_TO_X
    802              /*don't update the rollover since it has been updated already */
    803              updateRolloverflag = TRUE;
   \   0000B7   90....       MOV     DPTR,#updateRolloverflag
   \   0000BA   7401         MOV     A,#0x1
   \   0000BC   F0           MOVX    @DPTR,A
    804            }
    805          
    806            /* store the current value of overflowcount and accumulatedOverflowCount */
    807            prevoverflowCount = overflowCount;
   \                     ??macMcuPrecisionCount_0:
   \   0000BD   85..82       MOV     DPL,?XSP + 0
   \   0000C0   85..83       MOV     DPH,?XSP + 1
   \   0000C3   12....       LCALL   ?XLOAD_R0123
   \   0000C6   90....       MOV     DPTR,#prevoverflowCount
   \   0000C9   12....       LCALL   ?XSTORE_R0123
    808            prevAccumulatedOverflowCount = accumulatedOverflowCount;
   \   0000CC   90....       MOV     DPTR,#accumulatedOverflowCount
   \   0000CF   12....       LCALL   ?XLOAD_R0123
   \   0000D2   90....       MOV     DPTR,#prevAccumulatedOverflowCount
   \   0000D5   12....       LCALL   ?XSTORE_R0123
    809          
    810            HAL_EXIT_CRITICAL_SECTION(s);
   \   0000D8   EE           MOV     A,R6
   \   0000D9   F8           MOV     R0,A
   \   0000DA   EE           MOV     A,R6
   \   0000DB   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000DD   92AF         MOV     0xa8.7,C
    811          
    812            return(overflowCount);
   \   0000DF   85..82       MOV     DPL,?XSP + 0
   \   0000E2   85..83       MOV     DPH,?XSP + 1
   \   0000E5   12....       LCALL   ?XLOAD_R2345
   \   0000E8   7404         MOV     A,#0x4
   \   0000EA   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000ED   7F04         MOV     R7,#0x4
   \   0000EF   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000F2                REQUIRE _A_IEN0
   \   0000F2                REQUIRE T2MSEL
   \   0000F2                REQUIRE T2M0
   \   0000F2                REQUIRE T2MOVF0
   \   0000F2                REQUIRE T2MOVF1
   \   0000F2                REQUIRE T2MOVF2
    813          }
    814          
    815          
    816          /**************************************************************************************************
    817           * @fn          macMcuRfIsr
    818           *
    819           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    820           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    821           *
    822           * @param       none
    823           *
    824           * @return      none
    825           **************************************************************************************************
    826           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    827          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
   \                     macMcuRfIsr:
    828          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    829            uint8 rfim;
    830          
    831            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FF           MOV     R7,A
   \   00000C   D2AF         SETB    0xa8.7
    832          
    833            rfim = RFIRQM1;
   \   00000E   9061A4       MOV     DPTR,#0x61a4
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FE           MOV     R6,A
    834          
    835            /*  The CPU level RF interrupt flag must be cleared here (before clearing RFIRQFx).
    836             *  to allow the interrupts to be nested.
    837             */
    838            S1CON = 0x00;
   \   000013   759B00       MOV     0x9b,#0x0
    839          
    840            if ((RFIRQF1 & IRQ_CSP_MANINT) & rfim)
   \   000016   E591         MOV     A,0x91
   \   000018   5E           ANL     A,R6
   \   000019   5408         ANL     A,#0x8
   \   00001B   6008         JZ      ??macMcuRfIsr_0
    841            {
    842              /*
    843               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    844               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    845               *  long critical sections.
    846               */
    847              /* clear flag */
    848              RFIRQF1 = (IRQ_CSP_MANINT ^ 0xFF);
   \   00001D   7591F7       MOV     0x91,#-0x9
    849              macCspTxIntIsr();
   \   000020                ; Setup parameters for call to function macCspTxIntIsr
   \   000020   12....       LCALL   `??macCspTxIntIsr::?relay`; Banked call to: macCspTxIntIsr
   \   000023   8026         SJMP    ??macMcuRfIsr_1
    850            }
    851            else if ((RFIRQF1 & IRQ_CSP_STOP) & rfim)
   \                     ??macMcuRfIsr_0:
   \   000025   E591         MOV     A,0x91
   \   000027   5E           ANL     A,R6
   \   000028   5410         ANL     A,#0x10
   \   00002A   6008         JZ      ??macMcuRfIsr_2
    852            {
    853              /* clear flag */
    854              RFIRQF1 = (IRQ_CSP_STOP ^ 0xFF);
   \   00002C   7591EF       MOV     0x91,#-0x11
    855              macCspTxStopIsr();
   \   00002F                ; Setup parameters for call to function macCspTxStopIsr
   \   00002F   12....       LCALL   `??macCspTxStopIsr::?relay`; Banked call to: macCspTxStopIsr
   \   000032   8017         SJMP    ??macMcuRfIsr_1
    856            }
    857            else if ((RFIRQF1 & IRQ_TXACKDONE) & rfim)
   \                     ??macMcuRfIsr_2:
   \   000034   E591         MOV     A,0x91
   \   000036   A2E0         MOV     C,0xE0 /* A   */.0
   \   000038   92F0         MOV     B.0,C
   \   00003A   EE           MOV     A,R6
   \   00003B   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003D   82F0         ANL     C,B.0
   \   00003F   500A         JNC     ??macMcuRfIsr_1
    858            {
    859              /* disable interrupt - set up is for "one shot" operation */
    860              RFIRQM1 &= ~IM_TXACKDONE;
   \   000041   9061A4       MOV     DPTR,#0x61a4
   \   000044   E0           MOVX    A,@DPTR
   \   000045   C2E0         CLR     0xE0 /* A   */.0
   \   000047   F0           MOVX    @DPTR,A
    861              macRxAckTxDoneCallback();
   \   000048                ; Setup parameters for call to function macRxAckTxDoneCallback
   \   000048   12....       LCALL   `??macRxAckTxDoneCallback::?relay`; Banked call to: macRxAckTxDoneCallback
    862            }
    863          
    864            rfim = RFIRQM0;
   \                     ??macMcuRfIsr_1:
   \   00004B   9061A3       MOV     DPTR,#0x61a3
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   FE           MOV     R6,A
    865          
    866            /* process RFIRQF0 next */
    867            if ((RFIRQF0 & IRQ_FIFOP) & rfim)
   \   000050   E5E9         MOV     A,0xe9
   \   000052   5E           ANL     A,R6
   \   000053   5404         ANL     A,#0x4
   \   000055   600E         JZ      ??macMcuRfIsr_3
    868            {
    869              /* continue to execute interrup                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        t handler as long as FIFOP is active */
    870              do
    871              {
    872                macRxThresholdIsr();
   \                     ??macMcuRfIsr_4:
   \   000057                ; Setup parameters for call to function macRxThresholdIsr
   \   000057   12....       LCALL   `??macRxThresholdIsr::?relay`; Banked call to: macRxThresholdIsr
    873                RFIRQF0 = (IRQ_FIFOP ^ 0xFF);
   \   00005A   75E9FB       MOV     0xe9,#-0x5
    874              } while (FSMSTAT1 & FIFOP);
   \   00005D   906193       MOV     DPTR,#0x6193
   \   000060   E0           MOVX    A,@DPTR
   \   000061   A2E6         MOV     C,0xE0 /* A   */.6
   \   000063   40F2         JC      ??macMcuRfIsr_4
    875            }
    876          
    877            CLEAR_SLEEP_MODE();
    878            HAL_EXIT_ISR();
   \                     ??macMcuRfIsr_3:
   \   000065   EF           MOV     A,R7
   \   000066   F8           MOV     R0,A
   \   000067   EF           MOV     A,R7
   \   000068   A2E0         MOV     C,0xE0 /* A   */.0
   \   00006A   92AF         MOV     0xa8.7,C
    879          }
   \   00006C   7F01         MOV     R7,#0x1
   \   00006E   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000071                REQUIRE _A_IEN0
   \   000071                REQUIRE S1CON
   \   000071                REQUIRE RFIRQF1
   \   000071                REQUIRE RFIRQF0
    880          
    881          
    882          /**************************************************************************************************
    883           * @fn          macMcuRfErrIsr
    884           *
    885           * @brief       Interrupt service routine that handles all RF Error interrupts.  Only the RX FIFO
    886           *              overflow condition is handled.
    887           *
    888           * @param       none
    889           *
    890           * @return      none
    891           **************************************************************************************************
    892           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    893          HAL_ISR_FUNCTION( macMcuRfErrIsr, RFERR_VECTOR )
   \                     macMcuRfErrIsr:
    894          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    895            uint8 rferrm;
    896          
    897            HAL_ENTER_ISR();
   \   000007   A2AF         MOV     C,0xa8.7
   \   000009   E4           CLR     A
   \   00000A   33           RLC     A
   \   00000B   FE           MOV     R6,A
   \   00000C   D2AF         SETB    0xa8.7
    898          
    899            rferrm = RFERRM;
   \   00000E   9061A5       MOV     DPTR,#0x61a5
   \   000011   E0           MOVX    A,@DPTR
   \   000012   FF           MOV     R7,A
    900          
    901            if ((RFERRF & RFERR_RXOVERF) & rferrm)
   \   000013   E5BF         MOV     A,0xbf
   \   000015   5F           ANL     A,R7
   \   000016   5404         ANL     A,#0x4
   \   000018   6006         JZ      ??macMcuRfErrIsr_0
    902            {
    903              RFERRF = (RFERR_RXOVERF ^ 0xFF);
   \   00001A   75BFFB       MOV     0xbf,#-0x5
    904              macRxFifoOverflowIsr();
   \   00001D                ; Setup parameters for call to function macRxFifoOverflowIsr
   \   00001D   12....       LCALL   `??macRxFifoOverflowIsr::?relay`; Banked call to: macRxFifoOverflowIsr
    905            }
    906          
    907            CLEAR_SLEEP_MODE();
    908            HAL_EXIT_ISR();
   \                     ??macMcuRfErrIsr_0:
   \   000020   EE           MOV     A,R6
   \   000021   F8           MOV     R0,A
   \   000022   EE           MOV     A,R6
   \   000023   A2E0         MOV     C,0xE0 /* A   */.0
   \   000025   92AF         MOV     0xa8.7,C
    909          }
   \   000027   7F01         MOV     R7,#0x1
   \   000029   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   00002C                REQUIRE _A_IEN0
   \   00002C                REQUIRE RFERRF
    910          
    911          
    912          /**************************************************************************************************
    913           * @fn          macMcuRecordMaxRssiStart
    914           *
    915           * @brief       Starts recording of the maximum received RSSI value.
    916           *
    917           * @param       none
    918           *
    919           * @return      none
    920           **************************************************************************************************
    921           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    922          MAC_INTERNAL_API void macMcuRecordMaxRssiStart(void)
   \                     macMcuRecordMaxRssiStart:
    923          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    924            /* start maximum recorded value at the lowest possible value */
    925            maxRssi = -128;
   \   000004   90....       MOV     DPTR,#maxRssi
   \   000007   7480         MOV     A,#-0x80
   \   000009   F0           MOVX    @DPTR,A
    926          
    927            /* enable timer overflow interrupt */
    928            T2IRQM |= TIMER2_PERM;
   \   00000A   43A701       ORL     0xa7,#0x1
    929          }
   \   00000D   D083         POP     DPH
   \   00000F   D082         POP     DPL
   \   000011   02....       LJMP    ?BRET
   \   000014                REQUIRE T2IRQM
    930          
    931          
    932          /**************************************************************************************************
    933           * @fn          macMcuRecordMaxRssiStop
    934           *
    935           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    936           *              received since starting the recording.
    937           *
    938           * @param       none
    939           *
    940           * @return      maximum received RSSI value
    941           **************************************************************************************************
    942           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    943          MAC_INTERNAL_API int8 macMcuRecordMaxRssiStop(void)
   \                     macMcuRecordMaxRssiStop:
    944          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    945            /* disable timer overflow interrupt */
    946            T2IRQM &= ~TIMER2_PERM;
   \   000004   53A7FE       ANL     0xa7,#0xfe
    947          
    948            return(maxRssi);
   \   000007   90....       MOV     DPTR,#maxRssi
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   D083         POP     DPH
   \   00000E   D082         POP     DPL
   \   000010   02....       LJMP    ?BRET
   \   000013                REQUIRE T2IRQM
    949          }
    950          
    951          
    952          /*=================================================================================================
    953           * @fn          macMcuRecordMaxRssiIsr
    954           *
    955           * @brief       Interrupt service routine called during recording of max RSSI value.
    956           *
    957           * @param       none
    958           *
    959           * @return      none
    960           *=================================================================================================
    961           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    962          static void mcuRecordMaxRssiIsr(void)
   \                     mcuRecordMaxRssiIsr:
    963          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    964            int8 rssi;
    965          
    966            /* read latest RSSI value */
    967            rssi = RSSI;
   \   000004   906198       MOV     DPTR,#0x6198
   \   000007   E0           MOVX    A,@DPTR
   \   000008   F8           MOV     R0,A
    968          
    969            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    970            if (rssi > maxRssi)
   \   000009   90....       MOV     DPTR,#maxRssi
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   C3           CLR     C
   \   00000E   98           SUBB    A,R0
   \   00000F   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000011   65D0         XRL     A,PSW
   \   000013   33           RLC     A
   \   000014   5005         JNC     ??mcuRecordMaxRssiIsr_0
    971            {
    972              maxRssi = rssi;
   \   000016   E8           MOV     A,R0
   \   000017   90....       MOV     DPTR,#maxRssi
   \   00001A   F0           MOVX    @DPTR,A
    973            }
    974          }
   \                     ??mcuRecordMaxRssiIsr_0:
   \   00001B   D083         POP     DPH
   \   00001D   D082         POP     DPL
   \   00001F   02....       LJMP    ?BRET
    975          
    976          /**************************************************************************************************
    977           * @fn          macMcuAccumulatedOverFlow
    978           *
    979           * @brief       This function is used to accumulate timer 2 overflow if applicable
    980           *              on the relevant platform
    981           *
    982           * @param       none
    983           *
    984           * @return      none
    985           **************************************************************************************************
    986           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    987          MAC_INTERNAL_API void macMcuAccumulatedOverFlow(void)
   \                     macMcuAccumulatedOverFlow:
    988          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
    989            halIntState_t  s;
    990            HAL_ENTER_CRITICAL_SECTION(s);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   33           RLC     A
   \   000009   FE           MOV     R6,A
   \   00000A   C2AF         CLR     0xa8.7
    991          
    992            if(updateRolloverflag == FALSE)
   \   00000C   90....       MOV     DPTR,#updateRolloverflag
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   7015         JNZ     ??macMcuAccumulatedOverFlow_0
    993            {
    994              accumulatedOverflowCount += macGetBackOffTimerRollover();
   \   000012                ; Setup parameters for call to function macGetBackOffTimerRollover
   \   000012   12....       LCALL   `??macGetBackOffTimerRollover::?relay`; Banked call to: macGetBackOffTimerRollover
   \   000015   8A..         MOV     ?V0,R2
   \   000017   8B..         MOV     ?V1,R3
   \   000019   8C..         MOV     ?V2,R4
   \   00001B   8D..         MOV     ?V3,R5
   \   00001D   90....       MOV     DPTR,#accumulatedOverflowCount
   \   000020   78..         MOV     R0,#?V0
   \   000022   12....       LCALL   ?L_ADD_TO_X
   \   000025   8006         SJMP    ??macMcuAccumulatedOverFlow_1
    995            }
    996            else
    997            {
    998              updateRolloverflag = FALSE;
   \                     ??macMcuAccumulatedOverFlow_0:
   \   000027   90....       MOV     DPTR,#updateRolloverflag
   \   00002A   7400         MOV     A,#0x0
   \   00002C   F0           MOVX    @DPTR,A
    999            }
   1000          
   1001            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuAccumulatedOverFlow_1:
   \   00002D   EE           MOV     A,R6
   \   00002E   F8           MOV     R0,A
   \   00002F   EE           MOV     A,R6
   \   000030   A2E0         MOV     C,0xE0 /* A   */.0
   \   000032   92AF         MOV     0xa8.7,C
   1002          }
   \   000034   7F04         MOV     R7,#0x4
   \   000036   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000039                REQUIRE _A_IEN0

   \                                 In  segment INTVEC, offset 0x3, root
   \                     `??macMcuRfErrIsr::??INTVEC 3`:
   \   000003   02....       LJMP       (macMcuRfErrIsr)

   \                                 In  segment INTVEC, offset 0x53, root
   \                     `??macMcuTimer2Isr::??INTVEC 83`:
   \   000053   02....       LJMP       (macMcuTimer2Isr)

   \                                 In  segment INTVEC, offset 0x83, root
   \                     `??macMcuRfIsr::??INTVEC 131`:
   \   000083   02....       LJMP       (macMcuRfIsr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ff000000:
   \   000000   000000FF     DD 4278190080

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??MAC_SetRandomSeedCB::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    MAC_SetRandomSeedCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuInit::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRandomByte::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomByte

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRandomWord::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomWord

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuTimerForceDelay::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerForceDelay

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuTimerCapture::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowCount::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowCapture::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowSetCount::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowSetCompare::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowSetPeriod::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetPeriod

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuOverflowGetCompare::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowGetCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuTimer2OverflowWorkaround::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimer2OverflowWorkaround

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuPrecisionCount::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuPrecisionCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRecordMaxRssiStart::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuRecordMaxRssiStop::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStop

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??mcuRecordMaxRssiIsr::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    mcuRecordMaxRssiIsr

   \                                 In  segment BANK_RELAYS, align 1
   \                     `??macMcuAccumulatedOverFlow::?relay`:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuAccumulatedOverFlow
   1003          
   1004          
   1005          /**************************************************************************************************
   1006           *                                  Compile Time Integrity Checks
   1007           **************************************************************************************************
   1008           */
   1009          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXACKDONE != IM_TXACKDONE))
   1010          #error "ERROR: Compile time error with RFIRQFx vs RFIRQMx register defines."
   1011          #endif
   1012          
   1013          #if defined (FEATURE_CC253X_LOW_POWER_RX) && !(defined (HAL_MCU_CC2530) || defined (HAL_MCU_CC2533))
   1014          #error "ERROR: FEATURE_CC253X_LOW_POWER_RX can only be used with CC2530 or CC2533."
   1015          #endif
   1016          
   1017          /**************************************************************************************************
   1018          */

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      2      0   MAC_SetRandomSeedCB
      0     12   macMcuAccumulatedOverFlow
        0     12   -> macGetBackOffTimerRollover
      1      9   macMcuInit
        0      9   -> macRxOff
        0      9   -> macRxOn
      3      4   macMcuOverflowCapture
      1     29   macMcuOverflowCount
      3     20   macMcuOverflowGetCompare
      0     16   macMcuOverflowSetCompare
        0     16   -> halAssertHandler
      0     16   macMcuOverflowSetCount
        0     16   -> halAssertHandler
        0     16   -> macMcuOverflowCount
      0     16   macMcuOverflowSetPeriod
        0     16   -> halAssertHandler
        0     16   -> halSetMaxSleepLoopTime
      1     16   macMcuPrecisionCount
        0     16   -> macGetBackOffTimerRollover
      0      0   macMcuRandomByte
      0      0   macMcuRandomWord
      2      0   macMcuRecordMaxRssiStart
      2      0   macMcuRecordMaxRssiStop
      0     14   macMcuRfErrIsr
        0     14   -> macRxFifoOverflowIsr
      0     14   macMcuRfIsr
        0     14   -> macCspTxIntIsr
        0     14   -> macCspTxStopIsr
        0     14   -> macRxAckTxDoneCallback
        0     14   -> macRxThresholdIsr
      0     14   macMcuTimer2Isr
        0     14   -> macBackoffTimerCompareIsr
        0     14   -> macBackoffTimerPeriodIsr
        0     14   -> mcuRecordMaxRssiIsr
      0     16   macMcuTimer2OverflowWorkaround
        0     16   -> macBackoffTimerCompareIsr
        0     16   -> macMcuOverflowCount
        0     16   -> macMcuOverflowGetCompare
      0      0   macMcuTimerCapture
      0      0   macMcuTimerForceDelay
      2     14   mcuRecordMaxRssiIsr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ADCCON1
       1  CLKCONSTA
       1  IEN2
       1  IP0
       1  IP1
      19  MAC_SetRandomSeedCB
       6  MAC_SetRandomSeedCB::?relay
       1  RFERRF
       1  RFIRQF0
       1  RFIRQF1
       1  RNDH
       1  RNDL
       1  S1CON
       1  T2CTRL
       1  T2IRQF
       1  T2IRQM
       1  T2M0
       1  T2M1
       1  T2MOVF0
       1  T2MOVF1
       1  T2MOVF2
       1  T2MSEL
       1  _A_IEN0
       1  _A_IEN1
       4  __Constant_ff000000
       4  accumulatedOverflowCount
       1  macChipVersion
      57  macMcuAccumulatedOverFlow
       6  macMcuAccumulatedOverFlow::?relay
     404  macMcuInit
       6  macMcuInit::?relay
      92  macMcuOverflowCapture
       6  macMcuOverflowCapture::?relay
      93  macMcuOverflowCount
       6  macMcuOverflowCount::?relay
      92  macMcuOverflowGetCompare
       6  macMcuOverflowGetCompare::?relay
     133  macMcuOverflowSetCompare
       6  macMcuOverflowSetCompare::?relay
     149  macMcuOverflowSetCount
       6  macMcuOverflowSetCount::?relay
     145  macMcuOverflowSetPeriod
       6  macMcuOverflowSetPeriod::?relay
     242  macMcuPrecisionCount
       6  macMcuPrecisionCount::?relay
      14  macMcuRandomByte
       6  macMcuRandomByte::?relay
      32  macMcuRandomWord
       6  macMcuRandomWord::?relay
      20  macMcuRecordMaxRssiStart
       6  macMcuRecordMaxRssiStart::?relay
      19  macMcuRecordMaxRssiStop
       6  macMcuRecordMaxRssiStop::?relay
      44  macMcuRfErrIsr
       3  macMcuRfErrIsr::??INTVEC 3
     113  macMcuRfIsr
       3  macMcuRfIsr::??INTVEC 131
      78  macMcuTimer2Isr
       3  macMcuTimer2Isr::??INTVEC 83
      59  macMcuTimer2OverflowWorkaround
       6  macMcuTimer2OverflowWorkaround::?relay
      41  macMcuTimerCapture
       6  macMcuTimerCapture::?relay
      33  macMcuTimerForceDelay
       6  macMcuTimerForceDelay::?relay
       1  maxRssi
      34  mcuRecordMaxRssiIsr
       6  mcuRecordMaxRssiIsr::?relay
       2  pRandomSeedCB
       4  prevAccumulatedOverflowCount
       4  prevoverflowCount
       1  updateRolloverflag

 
 1 678 bytes in segment BANKED_CODE
   108 bytes in segment BANK_RELAYS
     9 bytes in segment INTVEC
   235 bytes in segment NEAR_CODE
    22 bytes in segment SFR_AN
     4 bytes in segment XDATA_ROM_C
    17 bytes in segment XDATA_Z
 
 2 021 bytes of CODE  memory (+  9 bytes shared)
     0 bytes of CONST memory (+  4 bytes shared)
     0 bytes of DATA  memory (+ 22 bytes shared)
    17 bytes of XDATA memory

Errors: none
Warnings: none
